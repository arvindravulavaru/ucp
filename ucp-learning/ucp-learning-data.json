{
  "id": "root",
  "label": "UCP Learning Path",
  "children": [
    {
      "id": "foundations",
      "label": "1. Foundations & Philosophy",
      "description": "Understand the 'why' before the 'how'",
      "content": "<h3>Start Here: Core Concepts</h3><p>The Universal Commerce Protocol (UCP) addresses the fragmented commerce landscape by providing a standardized common language and functional primitives.</p><p><strong>Key Problem:</strong> Different systems (platforms, businesses, payment providers) can't communicate efficiently, leading to custom, one-off integrations.</p><p><strong>Solution:</strong> UCP provides a uniform protocol that works across all parties.</p>",
      "resources": [
        { "type": "doc", "url": "https://ucp.dev/documentation/core-concepts", "label": "Core Concepts Documentation" },
        { "type": "doc", "url": "https://github.com/Universal-Commerce-Protocol/ucp", "label": "GitHub Repository" }
      ],
      "children": [
        {
          "id": "four-actors",
          "label": "Four Actors Model",
          "description": "Platform, Business, CP, PSP",
          "content": "<h3>The Four Primary Actors</h3><p>UCP defines four distinct actors in the commerce lifecycle, each with specific responsibilities and clear boundaries. This separation enables secure, scalable, and compliant commerce without tight coupling.</p><h4>1. Platform (Consumer Surface)</h4><p>The consumer-facing surface acting on behalf of users - AI agents, mobile apps, social media, search engines.</p><p><strong>Responsibilities:</strong></p><ul><li>Discovers business capabilities via <code>/.well-known/ucp</code></li><li>Orchestrates checkout flow on behalf of user</li><li>Presents UI/conversational interface</li><li>Manages user consent for agentic transactions</li></ul><p><strong>Examples:</strong> AI Shopping Assistants, Super Apps (WeChat, Grab), Voice Assistants</p><h4>2. Business (Merchant of Record)</h4><p>The entity selling goods/services, retaining financial liability and order ownership.</p><p><strong>Responsibilities:</strong></p><ul><li>Exposes inventory and pricing via UCP</li><li>Calculates tax and shipping</li><li>Fulfills orders</li><li>Processes payments via chosen PSP</li></ul><p><strong>Examples:</strong> Retailers (Shopify merchants), Airlines, Hotels, SaaS providers</p><h4>3. Credential Provider (CP)</h4><p>Trusted entity managing sensitive user data, especially payment instruments and shipping addresses.</p><p><strong>Responsibilities:</strong></p><ul><li>Authenticates users (OAuth 2.0)</li><li>Issues payment tokens (keeps raw card data secure)</li><li>Holds PII to minimize compliance scope for others</li><li>Exchanges tokens with PSPs for transaction processing</li></ul><p><strong>Examples:</strong> Google Wallet, Apple Pay, Digital Wallet Providers</p><h4>4. Payment Service Provider (PSP)</h4><p>Financial infrastructure provider processing payments on behalf of businesses.</p><p><strong>Responsibilities:</strong></p><ul><li>Authorizes and captures transactions</li><li>Handles settlements with card networks</li><li>Exchanges tokens with CPs for payment data</li><li>Issues AP2 mandates for additional authentication (3DS)</li></ul><p><strong>Examples:</strong> Stripe, Adyen, PayPal, Braintree, Chase Paymentech</p><h4>Example: Complete Transaction Flow</h4><pre><code class=\"language-javascript\">// Platform discovers and initiates checkout\nasync function platformCheckout() {\n  // 1. Platform discovers business capabilities\n  const profile = await fetch('https://shop.example.com/.well-known/ucp');\n  const { capabilities } = await profile.json();\n  \n  // 2. Platform creates checkout session\n  const checkout = await fetch('https://shop.example.com/api/ucp/checkout/create', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      items: [{ sku: 'ABC123', quantity: 1 }],\n      buyer: { email: 'user@example.com' }\n    })\n  });\n  \n  // 3. User selects payment via Credential Provider\n  const paymentToken = await getPaymentFromCP(); // CP tokenizes card\n  \n  // 4. Platform updates checkout with payment\n  const updated = await fetch('https://shop.example.com/api/ucp/checkout/update', {\n    method: 'POST',\n    body: JSON.stringify({\n      checkout_id: checkout.id,\n      payment: { token: paymentToken, provider: 'google_pay' }\n    })\n  });\n  \n  // 5. Business forwards to PSP, PSP exchanges token with CP\n  // (happens server-side at Business)\n  \n  // 6. Platform completes checkout\n  const order = await fetch('https://shop.example.com/api/ucp/checkout/complete', {\n    method: 'POST',\n    body: JSON.stringify({ checkout_id: checkout.id })\n  });\n  \n  return order.order_id; // Transaction complete!\n}\n\n// Credential Provider tokenizes payment\nasync function getPaymentFromCP() {\n  // User provides payment method to CP (outside UCP scope)\n  // CP returns token that Platform sends to Business\n  return 'tok_secure_google_pay_token_12345';\n}\n</code></pre><h4>Key Insights</h4><ul><li><strong>Separation of Concerns:</strong> Each actor focuses on its expertise (Platform=UX, Business=Commerce, CP=Security, PSP=Payments)</li><li><strong>Trust Boundaries:</strong> Raw payment data never touches Platform or Business - only CP and PSP handle it</li><li><strong>Flexibility:</strong> Platform can work with any Business, Business can use any PSP, etc.</li></ul><h4>Common Pitfalls</h4><ul><li><strong>Confusing CP and PSP:</strong> CP holds user credentials and issues tokens; PSP processes the actual transaction with card networks. They exchange tokens securely.</li><li><strong>Assuming Platform is merchant:</strong> Business is always the Merchant of Record (MoR), not the Platform. Platform facilitates but doesn't own the transaction.</li><li><strong>Tight coupling:</strong> Avoid hard-coding business URLs - use discovery (<code>/.well-known/ucp</code>) to find endpoints dynamically.</li></ul>",
          "resources": [
            { "type": "doc", "url": "https://ucp.dev/documentation/core-concepts/#roles-participants", "label": "Roles & Participants" },
            { "type": "spec", "url": "https://ucp.dev/specification/overview/", "label": "UCP Specification Overview" }
          ]
        },
        {
          "id": "governance-model",
          "label": "Governance Model",
          "description": "Reverse-domain namespacing",
          "content": "<h3>Decentralized Governance</h3><p>UCP uses reverse-domain naming to encode governance authority directly into capability identifiers. This eliminates the need for a central registry while ensuring clear ownership and preventing namespace collisions.</p><h4>Namespace Format</h4><p><strong>Required Format:</strong> <code>{reverse-domain}.{service}.{capability}</code></p><p><strong>Components:</strong></p><ul><li><strong>{reverse-domain}</strong> - Authority identifier from domain ownership (e.g., <code>dev.ucp</code>, <code>com.shopify</code>)</li><li><strong>{service}</strong> - Service/vertical category (e.g., <code>shopping</code>, <code>common</code>, <code>payments</code>)</li><li><strong>{capability}</strong> - Specific capability name (e.g., <code>checkout</code>, <code>identity_linking</code>)</li></ul><h4>Official UCP Capabilities</h4><table><tr><th>Name</th><th>Authority</th><th>Service</th><th>Capability</th></tr><tr><td><code>dev.ucp.shopping.checkout</code></td><td>ucp.dev</td><td>shopping</td><td>checkout</td></tr><tr><td><code>dev.ucp.shopping.order</code></td><td>ucp.dev</td><td>shopping</td><td>order</td></tr><tr><td><code>dev.ucp.shopping.discount</code></td><td>ucp.dev</td><td>shopping</td><td>discount</td></tr><tr><td><code>dev.ucp.shopping.fulfillment</code></td><td>ucp.dev</td><td>shopping</td><td>fulfillment</td></tr><tr><td><code>dev.ucp.common.identity_linking</code></td><td>ucp.dev</td><td>common</td><td>identity_linking</td></tr></table><h4>Custom Vendor Capabilities</h4><p>Vendors can create custom capabilities using their own reverse-domain:</p><pre><code>com.shopify.payments.installments  // Shopify's installment payments\ncom.example.loyalty.rewards        // Example.com's loyalty program\norg.acme.shipping.same_day         // Acme.org's same-day delivery\n</code></pre><h4>Spec URL Binding (Security)</h4><p>The <code>spec</code> and <code>schema</code> URLs <strong>MUST</strong> have origins matching the namespace authority. This prevents capability hijacking.</p><table><tr><th>Namespace</th><th>Required Origin</th><th>Valid?</th></tr><tr><td><code>dev.ucp.*</code></td><td><code>https://ucp.dev/...</code></td><td>✅ Yes</td></tr><tr><td><code>dev.ucp.*</code></td><td><code>https://evil.com/...</code></td><td>❌ No (origin mismatch)</td></tr><tr><td><code>com.shopify.*</code></td><td><code>https://shopify.com/...</code></td><td>✅ Yes</td></tr></table><h4>Namespace Validation Code</h4><pre><code class=\"language-javascript\">/**\n * Validates a UCP capability namespace and spec URL binding\n * @param {object} capability - Capability object from profile\n * @returns {boolean} True if valid\n */\nfunction validateCapabilityNamespace(capability) {\n  const { name, spec, schema } = capability;\n  \n  // Parse namespace\n  const parts = name.split('.');\n  if (parts.length < 3) {\n    console.error(`Invalid namespace format: ${name}`);\n    return false;\n  }\n  \n  // Extract authority (reverse-domain)\n  const authority = parts.slice(0, -2).reverse().join('.');\n  console.log(`Authority: ${authority}`);\n  \n  // Validate spec URL origin matches authority\n  try {\n    const specUrl = new URL(spec);\n    const expectedOrigin = `https://${authority}`;\n    \n    if (!specUrl.origin.startsWith(expectedOrigin)) {\n      console.error(\n        `Spec URL origin mismatch: ` +\n        `expected ${expectedOrigin}, got ${specUrl.origin}`\n      );\n      return false;\n    }\n    \n    // Also validate schema URL if present\n    if (schema) {\n      const schemaUrl = new URL(schema);\n      if (!schemaUrl.origin.startsWith(expectedOrigin)) {\n        console.error(\n          `Schema URL origin mismatch: ` +\n          `expected ${expectedOrigin}, got ${schemaUrl.origin}`\n        );\n        return false;\n      }\n    }\n    \n    return true;\n    \n  } catch (error) {\n    console.error(`Invalid URL in capability:`, error);\n    return false;\n  }\n}\n\n// Example usage\nconst capability = {\n  name: 'dev.ucp.shopping.checkout',\n  spec: 'https://ucp.dev/specification/checkout',\n  schema: 'https://ucp.dev/schemas/shopping/checkout.json'\n};\n\nif (validateCapabilityNamespace(capability)) {\n  console.log('✅ Capability is valid');\n} else {\n  console.log('❌ Capability validation failed');\n}\n\n// This would fail (origin mismatch)\nconst malicious = {\n  name: 'dev.ucp.shopping.checkout',\n  spec: 'https://evil.com/fake-spec',  // Wrong origin!\n  schema: 'https://evil.com/fake-schema'\n};\nvalidateCapabilityNamespace(malicious); // => false\n</code></pre><h4>Governance Implications</h4><ul><li><strong>No Central Authority:</strong> Anyone can create capabilities under their domain</li><li><strong>Clear Ownership:</strong> Domain ownership proves authority</li><li><strong>No Collisions:</strong> Each domain controls its own namespace</li><li><strong>Verifiable:</strong> Spec URLs must match namespace origin (security)</li></ul><h4>Common Pitfalls</h4><ul><li><strong>Wrong component order:</strong> Must be reverse-domain first (e.g., <code>dev.ucp</code> not <code>ucp.dev</code>)</li><li><strong>Missing validation:</strong> Always validate spec URL origin matches namespace authority</li><li><strong>Using underscores:</strong> Use dots as separators, not underscores (except in final capability name)</li><li><strong>Assuming centralization:</strong> UCP has no central registry - governance is distributed via DNS</li></ul>",
          "resources": [
            { "type": "spec", "url": "https://ucp.dev/specification/overview/#namespace-governance", "label": "Namespace Governance" },
            { "type": "doc", "url": "https://ucp.dev/documentation/core-concepts/", "label": "Core Concepts" }
          ]
        },
        {
          "id": "server-selects",
          "label": "Server-Selects Architecture",
          "description": "Business chooses protocol version",
          "content": "<h3>Server-Selects Version Negotiation</h3><p>In UCP's server-selects architecture, the <strong>business (server)</strong> chooses the protocol version and capabilities from the intersection of what both parties support. This is the opposite of client-driven negotiation (like HTTP content negotiation).</p><h4>Why Server-Selects?</h4><ul><li><strong>Business Control:</strong> Business knows its implementation best and chooses compatible versions</li><li><strong>Gradual Evolution:</strong> New protocol versions can be deployed without breaking existing clients</li><li><strong>Simplified Clients:</strong> Platforms don't need complex fallback logic</li><li><strong>Testing:</strong> Business can test new versions with specific clients before wide rollout</li></ul><h4>Negotiation Flow</h4><ol><li><strong>Platform</strong> fetches business profile from <code>/.well-known/ucp</code></li><li><strong>Platform</strong> sends request with its supported capabilities in headers or params</li><li><strong>Business</strong> computes intersection of capabilities</li><li><strong>Business</strong> selects version from intersection (usually latest both support)</li><li><strong>Business</strong> responds using selected version</li></ol><h4>Capability Intersection Example</h4><pre><code class=\"language-javascript\">/**\n * Compute capability intersection between platform and business\n * @param {string[]} platformCaps - Platform's supported capabilities\n * @param {string[]} businessCaps - Business's supported capabilities  \n * @returns {string[]} Intersection of capabilities\n */\nfunction computeCapabilityIntersection(platformCaps, businessCaps) {\n  return platformCaps.filter(cap => businessCaps.includes(cap));\n}\n\n// Example: Platform supports checkout v1 and v2\nconst platformCapabilities = [\n  'dev.ucp.shopping.checkout@2026-01-11',\n  'dev.ucp.shopping.checkout@2025-06-01',\n  'dev.ucp.shopping.discount@2026-01-11'\n];\n\n// Business only supports checkout v1 (older)\nconst businessCapabilities = [\n  'dev.ucp.shopping.checkout@2025-06-01',\n  'dev.ucp.shopping.fulfillment@2025-06-01'\n];\n\nconst intersection = computeCapabilityIntersection(\n  platformCapabilities,\n  businessCapabilities\n);\n\nconsole.log('Intersection:', intersection);\n// => ['dev.ucp.shopping.checkout@2025-06-01']\n\n// Business selects from intersection (usually latest)\nconst selectedVersion = intersection[0];\nconsole.log('Business selects:', selectedVersion);\n</code></pre><h4>Implementation Pattern (Business)</h4><pre><code class=\"language-javascript\">// Express.js middleware for version negotiation\napp.use('/api/ucp/*', (req, res, next) => {\n  // Platform sends supported versions in header\n  const platformVersions = req.headers['x-ucp-versions']?.split(',') || [];\n  \n  // Business's supported versions\n  const businessVersions = [\n    'dev.ucp.shopping.checkout@2026-01-11',\n    'dev.ucp.shopping.checkout@2025-06-01'\n  ];\n  \n  // Compute intersection\n  const compatible = platformVersions.filter(v => \n    businessVersions.includes(v)\n  );\n  \n  if (compatible.length === 0) {\n    return res.status(400).json({\n      error: 'no_compatible_version',\n      message: 'No mutually supported protocol version',\n      business_versions: businessVersions\n    });\n  }\n  \n  // Business selects latest compatible version\n  const selected = compatible[0]; // Assume sorted newest first\n  \n  // Store selected version in request for handler use\n  req.ucpVersion = selected;\n  \n  // Return selected version in response header\n  res.setHeader('X-UCP-Version', selected);\n  \n  next();\n});\n\n// Checkout endpoint uses negotiated version\napp.post('/api/ucp/checkout/create', (req, res) => {\n  const version = req.ucpVersion;\n  \n  // Use version-specific logic\n  if (version === 'dev.ucp.shopping.checkout@2026-01-11') {\n    // Handle v2 with new features\n    return handleCheckoutV2(req, res);\n  } else {\n    // Handle v1 (backward compatibility)\n    return handleCheckoutV1(req, res);\n  }\n});\n</code></pre><h4>Caching Considerations</h4><p>Since profiles change infrequently:</p><ul><li>Platform caches business profile (1 hour recommended)</li><li>Business caches platform capabilities (per-session)</li><li>Negotiation happens once per session, not per request</li></ul><h4>Version Format</h4><p>Versions follow ISO date format: <code>YYYY-MM-DD</code></p><ul><li><code>dev.ucp.shopping.checkout@2026-01-11</code> - Explicit version</li><li><code>dev.ucp.shopping.checkout</code> - No version (assumes latest)</li></ul><h4>Common Pitfalls</h4><ul><li><strong>Client selecting version:</strong> Don't implement client-selects - business always chooses</li><li><strong>No intersection:</strong> Handle case where no common version exists gracefully</li><li><strong>Assuming latest:</strong> Business should select from intersection, not assume platform supports latest</li><li><strong>Per-request negotiation:</strong> Cache negotiation result, don't renegotiate every API call</li></ul><h4>Benefits Over Client-Selects</h4><ul><li>Business controls rollout of new versions</li><li>Easier A/B testing (business picks version per client)</li><li>Simpler platform code (no complex fallback chains)</li><li>Business can require minimum version for sensitive operations</li></ul>",
          "resources": [
            { "type": "spec", "url": "https://ucp.dev/specification/overview/#discovery-governance-and-negotiation", "label": "Discovery & Negotiation" },
            { "type": "doc", "url": "https://ucp.dev/documentation/core-concepts/", "label": "Core Concepts" }
          ]
        }
      ]
    },
    {
      "id": "discovery",
      "label": "2. Discovery & Capability System",
      "description": "How parties find and understand each other",
      "content": "<h3>Dynamic Discovery</h3><p>UCP enables platforms to autonomously discover what businesses support without manual configuration.</p>",
      "resources": [
        { "type": "spec", "url": "https://ucp.dev/specification/overview#discovery", "label": "Discovery Specification" }
      ],
      "children": [
        {
          "id": "well-known-ucp",
          "label": "/.well-known/ucp Endpoint",
          "description": "Standard discovery endpoint",
          "content": "<h3>Profile Discovery</h3><p>Every UCP-compliant business <strong>MUST</strong> expose a machine-readable profile at the standard <code>/.well-known/ucp</code> endpoint. This enables platforms to autonomously discover capabilities without manual configuration or API keys.</p><h4>Profile Structure</h4><p>The profile declares:</p><ul><li><strong>capabilities[]</strong> - Supported capabilities and extensions with versions</li><li><strong>services</strong> - Transport bindings (REST, MCP, A2A, Embedded)</li><li><strong>payment.handlers[]</strong> - Instructions for collecting payment instruments</li><li><strong>signing_keys[]</strong> - JWKs (JSON Web Keys) for signature verification</li><li><strong>webhooks</strong> - Callback endpoints for events (optional)</li></ul><h4>Example Profile</h4><pre><code class=\"language-json\">{\n  \"version\": \"2026-01-11\",\n  \"capabilities\": [\n    {\n      \"name\": \"dev.ucp.shopping.checkout\",\n      \"version\": \"2026-01-11\",\n      \"spec\": \"https://ucp.dev/specification/checkout\",\n      \"schema\": \"https://ucp.dev/schemas/shopping/checkout.json\",\n      \"extensions\": [\n        \"dev.ucp.shopping.discount\",\n        \"dev.ucp.shopping.fulfillment\"\n      ]\n    },\n    {\n      \"name\": \"dev.ucp.shopping.order\",\n      \"version\": \"2026-01-11\",\n      \"spec\": \"https://ucp.dev/specification/order\",\n      \"schema\": \"https://ucp.dev/schemas/shopping/order.json\"\n    }\n  ],\n  \"services\": {\n    \"shopping\": {\n      \"version\": \"2026-01-11\",\n      \"spec\": \"https://ucp.dev/services/shopping/\",\n      \"rest\": {\n        \"schema\": \"https://ucp.dev/services/shopping/rest.openapi.json\",\n        \"endpoint\": \"https://shop.example.com/api/ucp\"\n      },\n      \"mcp\": {\n        \"schema\": \"https://ucp.dev/services/shopping/mcp.openrpc.json\",\n        \"endpoint\": \"https://shop.example.com/mcp\"\n      }\n    }\n  },\n  \"payment\": {\n    \"handlers\": [\n      {\n        \"type\": \"google_pay\",\n        \"url\": \"https://shop.example.com/payment/google-pay\"\n      }\n    ]\n  },\n  \"signing_keys\": [\n    {\n      \"kty\": \"RSA\",\n      \"kid\": \"shop-2026-01\",\n      \"use\": \"sig\",\n      \"n\": \"0vx7agoebG...\",\n      \"e\": \"AQAB\"\n    }\n  ]\n}\n</code></pre><h4>Profile Fetching Code</h4><pre><code class=\"language-javascript\">/**\n * Fetch and parse UCP profile from a business\n * @param {string} businessUrl - Base URL of the business\n * @returns {Promise<UCPProfile>} Parsed profile\n */\nasync function fetchUCPProfile(businessUrl) {\n  try {\n    // Construct well-known URL\n    const url = new URL('/.well-known/ucp', businessUrl);\n    \n    const response = await fetch(url.toString(), {\n      headers: {\n        'Accept': 'application/json',\n        'User-Agent': 'MyPlatform/1.0 (UCP Client)'\n      },\n      // Cache profile for performance\n      cache: 'force-cache',\n      // Timeout after 5 seconds\n      signal: AbortSignal.timeout(5000)\n    });\n    \n    if (!response.ok) {\n      throw new Error(`Profile fetch failed: ${response.status}`);\n    }\n    \n    const profile = await response.json();\n    \n    // Validate required fields\n    if (!profile.capabilities || !Array.isArray(profile.capabilities)) {\n      throw new Error('Invalid profile: missing capabilities[]');\n    }\n    \n    if (!profile.services) {\n      throw new Error('Invalid profile: missing services');\n    }\n    \n    console.log(`Discovered ${profile.capabilities.length} capabilities`);\n    return profile;\n    \n  } catch (error) {\n    console.error('Failed to fetch UCP profile:', error);\n    throw error;\n  }\n}\n\n// Check if business supports specific capability\nfunction supportsCapability(profile, capabilityName) {\n  return profile.capabilities.some(cap => cap.name === capabilityName);\n}\n\n// Get REST endpoint for a service\nfunction getRESTEndpoint(profile, serviceName) {\n  const service = profile.services[serviceName];\n  return service?.rest?.endpoint || null;\n}\n\n// Example usage\nconst profile = await fetchUCPProfile('https://shop.example.com');\n\nif (supportsCapability(profile, 'dev.ucp.shopping.checkout')) {\n  const endpoint = getRESTEndpoint(profile, 'shopping');\n  console.log('Checkout endpoint:', endpoint);\n  // => https://shop.example.com/api/ucp\n}\n</code></pre><h4>Caching Strategy</h4><p>Profiles change infrequently, so aggressive caching is recommended:</p><ul><li><strong>HTTP Cache-Control:</strong> Businesses SHOULD set <code>max-age=3600</code> (1 hour)</li><li><strong>Client-Side:</strong> Platforms SHOULD cache profiles for at least 1 hour</li><li><strong>Invalidation:</strong> Refresh on 404/5xx errors or version mismatch</li></ul><h4>Common Pitfalls</h4><ul><li><strong>Forgetting HTTPS:</strong> Profile <strong>MUST</strong> be served over HTTPS in production</li><li><strong>Not caching:</strong> Fetching profile on every request wastes bandwidth - cache aggressively</li><li><strong>Ignoring extensions:</strong> Check <code>capability.extensions[]</code> to see optional features like discounts</li><li><strong>Hard-coding endpoints:</strong> Always read endpoints from profile, never hard-code</li></ul>",
          "resources": [
            { "type": "spec", "url": "https://ucp.dev/specification/overview/#discovery-governance-and-negotiation", "label": "Discovery Specification" },
            { "type": "schema", "url": "https://ucp.dev/schemas/discovery/profile.json", "label": "Profile Schema" }
          ]
        },
        {
          "id": "capabilities-vs-extensions",
          "label": "Capabilities vs Extensions",
          "description": "Core vs optional features",
          "content": "<h3>Composable Architecture</h3><p>UCP separates core functionality (capabilities) from optional enhancements (extensions) to keep the protocol lean while enabling rich feature sets.</p><h4>Capabilities (Core Features)</h4><p><strong>Capabilities</strong> are standalone, complete features that define an entire flow. They are the \"verbs\" of UCP.</p><p><strong>Characteristics:</strong></p><ul><li>Self-contained and independently useful</li><li>Define complete request/response lifecycle</li><li>Can work without any extensions</li><li>Examples: <code>checkout</code>, <code>order</code>, <code>identity_linking</code></li></ul><p><strong>Official UCP Capabilities:</strong></p><table><tr><th>Capability</th><th>Purpose</th><th>Complete Flow?</th></tr><tr><td><code>dev.ucp.shopping.checkout</code></td><td>End-to-end purchase flow</td><td>✅ Yes</td></tr><tr><td><code>dev.ucp.shopping.order</code></td><td>Post-purchase tracking</td><td>✅ Yes</td></tr><tr><td><code>dev.ucp.common.identity_linking</code></td><td>OAuth authorization</td><td>✅ Yes</td></tr></table><h4>Extensions (Optional Features)</h4><p><strong>Extensions</strong> augment a parent capability with additional functionality. They use the <code>extends</code> field to declare their parent.</p><p><strong>Characteristics:</strong></p><ul><li>Cannot work standalone (require parent capability)</li><li>Add optional fields to parent schemas</li><li>Business declares support via <code>capability.extensions[]</code></li><li>Examples: <code>discount</code>, <code>fulfillment</code>, <code>ap2_mandates</code></li></ul><p><strong>Official UCP Extensions:</strong></p><table><tr><th>Extension</th><th>Extends</th><th>Purpose</th></tr><tr><td><code>dev.ucp.shopping.discount</code></td><td>checkout</td><td>Promotional discounts</td></tr><tr><td><code>dev.ucp.shopping.fulfillment</code></td><td>checkout</td><td>Shipping options</td></tr><tr><td><code>dev.ucp.shopping.ap2_mandates</code></td><td>checkout</td><td>Payment authentication</td></tr></table><h4>Declaration Example</h4><pre><code class=\"language-json\">// Business profile declares capability with extensions\n{\n  \"capabilities\": [\n    {\n      \"name\": \"dev.ucp.shopping.checkout\",\n      \"version\": \"2026-01-11\",\n      \"spec\": \"https://ucp.dev/specification/checkout\",\n      \"schema\": \"https://ucp.dev/schemas/shopping/checkout.json\",\n      \n      // Extensions this business supports\n      \"extensions\": [\n        \"dev.ucp.shopping.discount\",\n        \"dev.ucp.shopping.fulfillment\"\n      ]\n    }\n  ]\n}\n</code></pre><h4>Checking for Extension Support</h4><pre><code class=\"language-javascript\">/**\n * Check if business supports a specific extension\n * @param {object} profile - UCP profile from /.well-known/ucp\n * @param {string} capabilityName - Parent capability name\n * @param {string} extensionName - Extension to check\n * @returns {boolean} True if supported\n */\nfunction supportsExtension(profile, capabilityName, extensionName) {\n  const capability = profile.capabilities.find(c => c.name === capabilityName);\n  \n  if (!capability) {\n    return false; // Capability not supported at all\n  }\n  \n  return capability.extensions?.includes(extensionName) || false;\n}\n\n// Example usage\nconst profile = await fetchUCPProfile('https://shop.example.com');\n\n// Check if discounts are supported\nif (supportsExtension(profile, 'dev.ucp.shopping.checkout', 'dev.ucp.shopping.discount')) {\n  console.log('✅ This business supports discount codes!');\n  // Show coupon code input in UI\n} else {\n  console.log('❌ No discount support');\n  // Hide coupon code input\n}\n\n// Check if advanced fulfillment is supported\nif (supportsExtension(profile, 'dev.ucp.shopping.checkout', 'dev.ucp.shopping.fulfillment')) {\n  console.log('✅ Advanced shipping options available');\n} else {\n  console.log('Basic shipping only');\n}\n</code></pre><h4>Schema Composition</h4><p>Extensions modify the parent capability's schema using JSON Schema <code>allOf</code> composition:</p><pre><code class=\"language-json\">// Discount extension adds fields to checkout\n{\n  \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n  \"$id\": \"https://ucp.dev/schemas/shopping/discount.json\",\n  \"title\": \"Discount Extension\",\n  \"extends\": \"dev.ucp.shopping.checkout\",\n  \n  \"allOf\": [\n    {\n      \"$ref\": \"./checkout.json\"  // Base checkout schema\n    },\n    {\n      // Additional fields added by discount extension\n      \"properties\": {\n        \"discount\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"code\": { \"type\": \"string\" },\n            \"amount\": { \"type\": \"integer\" },\n            \"type\": { \"enum\": [\"percentage\", \"fixed\"] }\n          }\n        }\n      }\n    }\n  ]\n}\n</code></pre><h4>Extension Lifecycle</h4><ol><li><strong>Discovery:</strong> Platform reads business profile, sees supported extensions</li><li><strong>Schema Resolution:</strong> Platform fetches extension schemas and composes with base</li><li><strong>Request:</strong> Platform sends request with extension-specific fields (if applicable)</li><li><strong>Response:</strong> Business includes extension fields in response</li></ol><h4>Design Principles</h4><ul><li><strong>Lean Core:</strong> Base capabilities work without extensions (graceful degradation)</li><li><strong>Optional:</strong> Platforms can ignore unsupported extensions</li><li><strong>Composable:</strong> Multiple extensions can augment the same capability</li><li><strong>Self-Describing:</strong> Extension schemas declare what they add</li></ul><h4>Common Pitfalls</h4><ul><li><strong>Assuming extension support:</strong> Always check <code>capability.extensions[]</code> before using extension fields</li><li><strong>Making extensions required:</strong> Extensions should be truly optional - core flow works without them</li><li><strong>Not fetching extension schemas:</strong> Must compose base + extension schemas for validation</li><li><strong>Wrong extends reference:</strong> Extension must reference an actual capability, not another extension</li></ul>",
          "resources": [
            { "type": "spec", "url": "https://ucp.dev/specification/overview/#extensions", "label": "Extensions Specification" },
            { "type": "schema", "url": "https://ucp.dev/schemas/shopping/discount.json", "label": "Discount Extension Schema" }
          ]
        },
        {
          "id": "namespace-format",
          "label": "Namespace Format",
          "description": "Reverse-domain naming convention",
          "content": "<h3>Capability Naming Convention</h3><p>All UCP capabilities and services <strong>MUST</strong> follow the reverse-domain naming format. This ensures global uniqueness and encodes governance authority directly in the name.</p><h4>Required Format</h4><pre><code>{reverse-domain}.{service}.{capability}\n\nExamples:\ndev.ucp.shopping.checkout      // Official UCP capability\ncom.shopify.loyalty.points     // Shopify's custom capability\norg.example.shipping.expedited // Example.org's expedited shipping\n</code></pre><h4>Component Breakdown</h4><table><tr><th>Component</th><th>Purpose</th><th>Rules</th><th>Example</th></tr><tr><td><strong>reverse-domain</strong></td><td>Authority identifier</td><td>Lowercase, dots as separators</td><td><code>dev.ucp</code>, <code>com.shopify</code></td></tr><tr><td><strong>service</strong></td><td>Vertical/category</td><td>Lowercase, single word</td><td><code>shopping</code>, <code>common</code>, <code>payments</code></td></tr><tr><td><strong>capability</strong></td><td>Specific feature name</td><td>Lowercase, underscores OK</td><td><code>checkout</code>, <code>identity_linking</code></td></tr></table><h4>Official UCP Namespaces</h4><p><strong>dev.ucp.shopping.*</strong> - Shopping/Commerce capabilities</p><ul><li><code>dev.ucp.shopping.checkout</code> - Complete checkout flow</li><li><code>dev.ucp.shopping.order</code> - Order tracking and webhooks</li><li><code>dev.ucp.shopping.discount</code> - Promotional discounts (extension)</li><li><code>dev.ucp.shopping.fulfillment</code> - Shipping options (extension)</li><li><code>dev.ucp.shopping.ap2_mandates</code> - Payment auth (extension)</li></ul><p><strong>dev.ucp.common.*</strong> - Cross-domain capabilities</p><ul><li><code>dev.ucp.common.identity_linking</code> - OAuth 2.0 authorization</li></ul><h4>Custom Vendor Namespaces</h4><p>Vendors create capabilities under their reverse-domain:</p><pre><code>// Shopify capabilities\ncom.shopify.payments.installments\ncom.shopify.loyalty.rewards\ncom.shopify.shipping.local_pickup\n\n// PayPal capabilities\ncom.paypal.express.checkout\ncom.paypal.subscription.billing\n\n// Example.com capabilities  \ncom.example.analytics.tracking\ncom.example.returns.rma\n</code></pre><h4>Parsing Utilities</h4><pre><code class=\"language-javascript\">/**\n * Parse a UCP capability namespace\n * @param {string} namespace - Full namespace string\n * @returns {object} Parsed components\n */\nfunction parseNamespace(namespace) {\n  const parts = namespace.split('.');\n  \n  if (parts.length < 3) {\n    throw new Error(`Invalid namespace: ${namespace} (need at least 3 parts)`);\n  }\n  \n  // Last part is capability\n  const capability = parts[parts.length - 1];\n  \n  // Second to last is service\n  const service = parts[parts.length - 2];\n  \n  // Everything before is reverse-domain\n  const reverseDomain = parts.slice(0, -2).join('.');\n  \n  // Convert reverse-domain to normal domain\n  const authority = parts.slice(0, -2).reverse().join('.');\n  \n  return {\n    namespace,\n    reverseDomain,\n    authority,\n    service,\n    capability,\n    // Helper: expected spec origin\n    expectedOrigin: `https://${authority}`\n  };\n}\n\n// Example usage\nconst parsed = parseNamespace('dev.ucp.shopping.checkout');\nconsole.log(parsed);\n/*\n{\n  namespace: 'dev.ucp.shopping.checkout',\n  reverseDomain: 'dev.ucp',\n  authority: 'ucp.dev',\n  service: 'shopping',\n  capability: 'checkout',\n  expectedOrigin: 'https://ucp.dev'\n}\n*/\n\n// Validate a capability's spec URL matches its namespace\nfunction validateSpecURL(capability) {\n  const parsed = parseNamespace(capability.name);\n  const specUrl = new URL(capability.spec);\n  \n  if (!specUrl.origin.startsWith(parsed.expectedOrigin)) {\n    throw new Error(\n      `Spec URL origin mismatch: expected ${parsed.expectedOrigin}, ` +\n      `got ${specUrl.origin}`\n    );\n  }\n  \n  return true;\n}\n\n// Example: validate official UCP capability\nconst ucpCap = {\n  name: 'dev.ucp.shopping.checkout',\n  spec: 'https://ucp.dev/specification/checkout'\n};\nvalidateSpecURL(ucpCap); // ✅ Valid\n\n// Example: detect malicious capability\nconst maliciousCap = {\n  name: 'dev.ucp.shopping.checkout',\n  spec: 'https://evil.com/fake-spec'\n};\ntry {\n  validateSpecURL(maliciousCap); // ❌ Throws error\n} catch (e) {\n  console.error(e.message);\n  // => \"Spec URL origin mismatch: expected https://ucp.dev, got https://evil.com\"\n}\n</code></pre><h4>Version Suffixes (Optional)</h4><p>Capabilities can include version suffixes using <code>@</code>:</p><pre><code>dev.ucp.shopping.checkout@2026-01-11  // Explicit version\ndev.ucp.shopping.checkout             // No version (implies latest)\n</code></pre><p>Version format is ISO date: <code>YYYY-MM-DD</code></p><h4>Naming Rules (RFC)</h4><ul><li><strong>Lowercase only:</strong> <code>dev.ucp</code> not <code>Dev.UCP</code></li><li><strong>Dots as separators:</strong> Between domain parts and components</li><li><strong>Underscores in capability:</strong> OK in final capability name (<code>identity_linking</code>)</li><li><strong>No hyphens:</strong> Use underscores instead</li><li><strong>ASCII only:</strong> No unicode, emojis, or special characters</li></ul><h4>Pattern Matching</h4><pre><code class=\"language-javascript\">// Match all capabilities from a specific authority\nfunction isUCPOfficial(namespace) {\n  return namespace.startsWith('dev.ucp.');\n}\n\n// Match all capabilities in a service\nfunction isShoppingCapability(namespace) {\n  return /^[a-z]+\\.[a-z]+\\.shopping\\./i.test(namespace);\n}\n\n// Extract service name\nfunction getService(namespace) {\n  const parts = namespace.split('.');\n  return parts[parts.length - 2];\n}\n\nconsole.log(getService('dev.ucp.shopping.checkout'));  // => 'shopping'\nconsole.log(getService('com.shopify.loyalty.points')); // => 'loyalty'\n</code></pre><h4>Common Pitfalls</h4><ul><li><strong>Wrong order:</strong> Must be reverse-domain first (<code>dev.ucp</code> not <code>ucp.dev</code>)</li><li><strong>Too few parts:</strong> Need at least 3 parts (reverse-domain.service.capability)</li><li><strong>Using hyphens:</strong> Use underscores in capability names, not hyphens</li><li><strong>Uppercase letters:</strong> All lowercase required</li><li><strong>Not validating origin:</strong> Always check spec URL matches namespace authority</li></ul>",
          "resources": [
            { "type": "spec", "url": "https://ucp.dev/specification/overview/#namespace-governance", "label": "Namespace Governance Spec" },
            { "type": "doc", "url": "https://ucp.dev/documentation/core-concepts/", "label": "Core Concepts" }
          ]
        }
      ]
    },
    {
      "id": "shopping-domain",
      "label": "3. Core Shopping Domain",
      "description": "Main commerce primitives and schemas",
      "content": "<h3>Shopping Domain Overview</h3><p>The shopping domain contains the core schemas for commerce transactions.</p>",
      "children": [
        {
          "id": "checkout-schema",
          "label": "Checkout Schema",
          "description": "Central state object for transactions",
          "content": "<h3>The Checkout Object</h3><p>The checkout schema is the central state object in UCP. It contains:</p><ul><li><strong>items[]</strong> - Cart line items</li><li><strong>buyer</strong> - Customer information</li><li><strong>payment</strong> - Payment methods and instruments</li><li><strong>fulfillment</strong> - Shipping options and addresses</li><li><strong>totals</strong> - Price breakdown (subtotal, tax, shipping)</li><li><strong>discount</strong> - Applied promotions (if supported)</li></ul><p>The checkout object flows through create → update → complete lifecycle.</p>",
          "resources": [
            { "type": "spec", "url": "https://ucp.dev/specification/checkout", "label": "Checkout Specification" }
          ]
        },
        {
          "id": "payment-schema",
          "label": "Payment Schema",
          "description": "Payment instruments and methods",
          "content": "<h3>Payment Structure</h3><p>UCP supports multiple payment instrument types:</p><ul><li><strong>card_payment_instrument</strong> - Tokenized card data</li><li><strong>payment_credential</strong> - Secure credential exchange</li><li><strong>payment_handler</strong> - Instructions for collecting payment</li></ul><p>Payment data is typically tokenized by the Credential Provider (CP) to minimize PCI scope.</p>"
        },
        {
          "id": "fulfillment-schema",
          "label": "Fulfillment Schema",
          "description": "Shipping and delivery",
          "content": "<h3>Fulfillment System</h3><p>Fulfillment includes:</p><ul><li><strong>fulfillment_option[]</strong> - Available shipping methods</li><li><strong>fulfillment_method</strong> - Selected shipping method</li><li><strong>fulfillment_destination</strong> - Delivery address</li><li><strong>fulfillment_group</strong> - Grouped items for multi-shipment</li><li><strong>fulfillment_event</strong> - Tracking updates</li></ul>"
        },
        {
          "id": "order-schema",
          "label": "Order Schema",
          "description": "Post-purchase order tracking",
          "content": "<h3>Order Lifecycle</h3><p>After checkout completes, the order object tracks:</p><ul><li><strong>order_confirmation</strong> - Initial confirmation with order ID</li><li><strong>fulfillment_events</strong> - Shipping updates (shipped, delivered)</li><li><strong>webhooks</strong> - Asynchronous status notifications</li></ul><p>Businesses send order updates to platforms via webhooks.</p>",
          "resources": [
            { "type": "spec", "url": "https://ucp.dev/specification/order", "label": "Order Specification" }
          ]
        }
      ]
    },
    {
      "id": "transports",
      "label": "4. Transport Protocols",
      "description": "REST, MCP, A2A, Embedded",
      "content": "<h3>Multiple Transport Options</h3><p>UCP is transport-agnostic. The same capabilities can be exposed via different protocols.</p>",
      "children": [
        {
          "id": "rest-api",
          "label": "REST API",
          "description": "Traditional HTTP endpoints",
          "content": "<h3>REST Transport</h3><p>Standard HTTP API with JSON request/response:</p><ul><li><code>POST /checkout/create</code> - Initialize checkout</li><li><code>POST /checkout/update</code> - Update checkout state</li><li><code>POST /checkout/complete</code> - Finalize order</li></ul><p>Best for: Traditional web/mobile apps, server-side integrations</p>",
          "resources": [
            { "type": "spec", "url": "https://ucp.dev/specification/checkout-rest", "label": "REST API Documentation" }
          ]
        },
        {
          "id": "mcp-protocol",
          "label": "MCP (Model Context Protocol)",
          "description": "For AI agents and LLMs",
          "content": "<h3>MCP Transport</h3><p>Model Context Protocol exposes UCP as tools for AI agents:</p><ul><li><code>checkout_create</code> - Tool for creating checkout</li><li><code>checkout_update</code> - Tool for updating checkout</li><li><code>checkout_complete</code> - Tool for completing order</li></ul><p>AI agents can call these tools to complete purchases on behalf of users.</p><p>Best for: AI shopping assistants, conversational commerce</p>",
          "resources": [
            { "type": "spec", "url": "https://ucp.dev/specification/checkout-mcp", "label": "MCP Documentation" }
          ]
        },
        {
          "id": "a2a-protocol",
          "label": "A2A (Agent-to-Agent)",
          "description": "Direct agent communication",
          "content": "<h3>A2A Transport</h3><p>Agent-to-Agent protocol for direct machine-to-machine communication.</p><p>Enables autonomous agents to discover, negotiate, and transact without human intervention.</p><p>Best for: Fully autonomous commerce, B2B integrations</p>",
          "resources": [
            { "type": "spec", "url": "https://ucp.dev/specification/checkout-a2a", "label": "A2A Documentation" }
          ]
        },
        {
          "id": "embedded-protocol",
          "label": "Embedded Protocol (ECP)",
          "description": "PostMessage/JSON-RPC in iframes",
          "content": "<h3>Embedded Commerce Protocol (ECP)</h3><p>Enables checkout flows embedded in iframes using postMessage:</p><p><strong>Key Methods:</strong></p><ul><li><code>ec.ready</code> - Handshake and delegation setup</li><li><code>ec.start</code> - Checkout UI visible</li><li><code>ec.update</code> - State changes</li><li><code>ec.complete</code> - Order placed</li></ul><p><strong>Delegations:</strong></p><ul><li><code>payment.instruments_change</code> - Platform provides payment methods</li><li><code>payment.credential</code> - Credential exchange</li></ul><p>Best for: Embedded checkout widgets, white-label solutions</p>",
          "resources": [
            { "type": "spec", "url": "https://ucp.dev/specification/embedded-checkout", "label": "ECP Documentation" }
          ]
        }
      ]
    },
    {
      "id": "security",
      "label": "5. Advanced Security Patterns",
      "description": "AP2, consent, tokenization",
      "content": "<h3>Security-First Design</h3><p>UCP implements multiple layers of security for payment and identity protection.</p>",
      "children": [
        {
          "id": "ap2-mandates",
          "label": "AP2 Mandates",
          "description": "Authentication Protocol 2",
          "content": "<h3>AP2 Mandates</h3><p>Authentication Protocol 2 (AP2) mandates enforce security requirements:</p><ul><li><strong>3DS Authentication</strong> - Strong customer authentication (SCA)</li><li><strong>Step-up Auth</strong> - Additional verification when needed</li><li><strong>Risk Checks</strong> - Fraud detection thresholds</li></ul><p>PSPs include AP2 mandates in checkout responses to request additional authentication.</p>",
          "resources": [
            { "type": "spec", "url": "https://ucp.dev/specification/ap2-mandates", "label": "AP2 Specification" }
          ]
        },
        {
          "id": "buyer-consent",
          "label": "Buyer Consent",
          "description": "Explicit user permissions",
          "content": "<h3>Consent Framework</h3><p>For agentic commerce, explicit buyer consent is required:</p><ul><li><strong>Consent Grant</strong> - User authorizes platform to transact</li><li><strong>Scope Limits</strong> - Budget caps, merchant allowlists</li><li><strong>Revocation</strong> - User can revoke consent anytime</li></ul><p>Prevents unauthorized purchases by AI agents.</p>",
          "resources": [
            { "type": "spec", "url": "https://ucp.dev/specification/buyer-consent", "label": "Consent Documentation" }
          ]
        },
        {
          "id": "tokenization",
          "label": "Payment Tokenization",
          "description": "Secure credential exchange",
          "content": "<h3>Tokenization Flow</h3><p>Payment data flows through secure tokenization:</p><ol><li>User provides payment method to <strong>Credential Provider (CP)</strong></li><li>CP generates a token (no raw card data leaves CP)</li><li>Platform sends token to Business</li><li>Business sends token to <strong>PSP</strong></li><li>PSP exchanges token with CP for actual payment data</li><li>Transaction processed</li></ol><p>This minimizes PCI-DSS scope for Platform and Business.</p>",
          "resources": [
            { "type": "spec", "url": "https://ucp.dev/specification/tokenization-guide", "label": "Tokenization Guide" },
            { "type": "spec", "url": "https://ucp.dev/specification/payment-handler-guide", "label": "Payment Handler Guide" }
          ]
        },
        {
          "id": "signing-keys",
          "label": "JWK Signing Keys",
          "description": "Message signature verification",
          "content": "<h3>Cryptographic Signatures</h3><p>All parties publish JWKs (JSON Web Keys) in their UCP profile:</p><ul><li>Used to sign webhooks, responses, and authenticated messages</li><li>Recipients verify signatures using published public keys</li><li>Prevents message tampering and impersonation</li></ul>"
        }
      ]
    },
    {
      "id": "annotations",
      "label": "6. UCP Annotation System",
      "description": "Source-to-spec generation",
      "content": "<h3>Schema Generation Architecture</h3><p>UCP uses a unique source-to-spec generation model with custom annotations.</p>",
      "resources": [
        { "type": "doc", "url": "https://ucp.dev/documentation/schema-authoring", "label": "Schema Authoring Guide" }
      ],
      "children": [
        {
          "id": "ucp-request",
          "label": "ucp_request Annotation",
          "description": "Controls field behavior in requests",
          "content": "<h3>Request Annotations</h3><p><code>\"ucp_request\": \"omit|optional|required\"</code></p><ul><li><strong>omit</strong> - Field not included in create_req.json or update_req.json</li><li><strong>optional</strong> - Field optional in requests</li><li><strong>required</strong> - Field required in requests</li></ul><p>Enables minimal request payloads (only send what's needed).</p>"
        },
        {
          "id": "ucp-response",
          "label": "ucp_response Annotation",
          "description": "Controls field in responses",
          "content": "<h3>Response Annotations</h3><p><code>\"ucp_response\": \"omit\"</code></p><p>Removes field from response schemas (_resp.json files).</p><p>Useful for internal-only fields that shouldn't be exposed.</p>"
        },
        {
          "id": "ucp-shared-request",
          "label": "ucp_shared_request Annotation",
          "description": "Applies to both create and update",
          "content": "<h3>Shared Request Annotations</h3><p><code>\"ucp_shared_request\": \"optional|required\"</code></p><p>Applies the same rule to both create and update operations.</p><p>Simplifies schemas where create/update behavior is identical.</p>"
        },
        {
          "id": "generation-passes",
          "label": "3-Pass Generation System",
          "description": "How schemas are generated",
          "content": "<h3>Generation Workflow</h3><p><strong>Pass 1-2:</strong> Process annotations → generate per-operation schemas</p><ul><li>type.json → type_create_req.json, type_update_req.json, type_resp.json</li></ul><p><strong>Pass 3:</strong> Generate OpenRPC spec for Embedded Protocol</p><ul><li>Aggregates methods from source/services/shopping/embedded.json</li><li>Combines with extension schemas</li><li>Produces spec/services/shopping/embedded.openrpc.json</li></ul><p><strong>Command:</strong> <code>python generate_schemas.py</code></p>"
        }
      ]
    },
    {
      "id": "extensions",
      "label": "7. Extensions System",
      "description": "Modular feature enhancement",
      "content": "<h3>Extension Architecture</h3><p>Extensions provide optional enhancements to core capabilities without bloating the protocol.</p>",
      "children": [
        {
          "id": "discount-extension",
          "label": "Discount Extension",
          "description": "Promotions and adjustments",
          "content": "<h3>Discount Extension</h3><p><strong>Name:</strong> <code>dev.ucp.shopping.discount</code></p><p><strong>Purpose:</strong> Apply promotional discounts to checkout</p><p><strong>Features:</strong></p><ul><li>Coupon codes</li><li>Automatic discounts (cart total thresholds)</li><li>Line item vs order-level discounts</li><li>Discount stacking rules</li></ul>"
        },
        {
          "id": "fulfillment-extension",
          "label": "Fulfillment Extension",
          "description": "Advanced shipping features",
          "content": "<h3>Fulfillment Extension</h3><p><strong>Name:</strong> <code>dev.ucp.shopping.fulfillment</code></p><p><strong>Purpose:</strong> Enhanced shipping and delivery options</p><p><strong>Features:</strong></p><ul><li>Multiple fulfillment groups (split shipments)</li><li>Real-time shipping rates</li><li>Delivery time estimates</li><li>Pickup options (BOPIS - Buy Online Pickup In Store)</li></ul>"
        },
        {
          "id": "declaring-extensions",
          "label": "Declaring Extensions",
          "description": "How to advertise support",
          "content": "<h3>Extension Declaration</h3><p>Businesses declare extensions in their UCP profile:</p><pre>{\n  \"capabilities\": [\n    {\n      \"name\": \"dev.ucp.shopping.checkout\",\n      \"extensions\": [\"dev.ucp.shopping.discount\", \"dev.ucp.shopping.fulfillment\"]\n    }\n  ]\n}</pre><p>Platforms read this to know which optional features are available.</p>"
        }
      ]
    },
    {
      "id": "capabilities",
      "label": "8. Capabilities Deep Dive",
      "description": "Four foundational capabilities",
      "content": "<h3>Official UCP Capabilities</h3><p>UCP v1 defines four core capabilities for commerce transactions.</p>",
      "children": [
        {
          "id": "checkout-capability",
          "label": "dev.ucp.shopping.checkout",
          "description": "End-to-end checkout flow",
          "content": "<h3>Checkout Capability</h3><p>The most complex capability - handles entire checkout lifecycle:</p><p><strong>Flow:</strong></p><ol><li><strong>create</strong> - Initialize with items, buyer info</li><li><strong>update</strong> - Iteratively add payment, shipping, apply discounts</li><li><strong>update</strong> - Business calculates tax, validates availability</li><li><strong>complete</strong> - Finalize order, return confirmation</li></ol><p><strong>Transports:</strong> REST, MCP, A2A, Embedded</p>",
          "resources": [
            { "type": "spec", "url": "https://ucp.dev/specification/checkout", "label": "Checkout Full Specification" }
          ]
        },
        {
          "id": "identity-linking",
          "label": "dev.ucp.common.identity_linking",
          "description": "OAuth 2.0 authorization",
          "content": "<h3>Identity Linking Capability</h3><p>OAuth 2.0 flow for platforms to obtain authorization:</p><ul><li>Platform requests authorization to act on user's behalf</li><li>User authenticates with Business</li><li>Business issues access token</li><li>Platform uses token for subsequent API calls</li></ul><p>Enables saved payment methods, order history access, etc.</p>",
          "resources": [
            { "type": "spec", "url": "https://ucp.dev/specification/identity-linking", "label": "Identity Linking Spec" }
          ]
        },
        {
          "id": "order-capability",
          "label": "dev.ucp.shopping.order",
          "description": "Post-purchase tracking",
          "content": "<h3>Order Capability</h3><p>Webhook-based updates for order lifecycle:</p><ul><li><strong>order.shipped</strong> - Item shipped with tracking</li><li><strong>order.delivered</strong> - Item delivered</li><li><strong>order.returned</strong> - Return initiated</li><li><strong>order.cancelled</strong> - Order cancelled</li></ul><p>Businesses push these events to platform webhook endpoints.</p>",
          "resources": [
            { "type": "spec", "url": "https://ucp.dev/specification/order", "label": "Order Specification" }
          ]
        },
        {
          "id": "payment-token-exchange",
          "label": "Payment Token Exchange",
          "description": "PSP ↔ CP token flow",
          "content": "<h3>Token Exchange Capability</h3><p>Secure protocol for PSPs to exchange tokens with Credential Providers:</p><ol><li>PSP receives tokenized payment from Business</li><li>PSP calls CP's token exchange endpoint</li><li>CP validates PSP's identity (signing keys)</li><li>CP returns decrypted payment data</li><li>PSP processes transaction</li></ol><p>Example: Google Pay → Stripe token exchange</p>",
          "resources": [
            { "type": "spec", "url": "https://ucp.dev/specification/tokenization-guide", "label": "Tokenization Guide" }
          ]
        }
      ]
    },
    {
      "id": "workflow",
      "label": "9. Development Workflow",
      "description": "Working with the codebase",
      "content": "<h3>Developer Workflow Mastery</h3><p>How to effectively work with UCP's schema generation system.</p>",
      "children": [
        {
          "id": "never-edit-spec",
          "label": "Never Edit spec/ Directly",
          "description": "Golden rule of UCP development",
          "content": "<h3>Critical Rule</h3><p><strong>NEVER manually edit files in spec/</strong></p><p>The spec/ directory is generated. Always:</p><ol><li>Edit schemas in <code>source/</code></li><li>Run <code>python generate_schemas.py</code></li><li>Verify outputs in <code>spec/</code></li></ol><p>Manual edits to spec/ will be overwritten on next generation.</p>"
        },
        {
          "id": "schema-workflow",
          "label": "Schema Development Loop",
          "description": "Edit → Generate → Validate",
          "content": "<h3>Complete Workflow</h3><ol><li><strong>Edit:</strong> Modify <code>source/schemas/shopping/types/buyer.json</code></li><li><strong>Generate:</strong> Run <code>python generate_schemas.py</code></li><li><strong>Validate:</strong> Run <code>python validate_specs.py</code></li><li><strong>Docs:</strong> Run <code>mkdocs serve --watch spec</code></li><li><strong>SDK:</strong> Run <code>bash scripts/ci_check_models.sh</code></li></ol>"
        },
        {
          "id": "adding-new-types",
          "label": "Adding New Schema Types",
          "description": "Step-by-step guide",
          "content": "<h3>New Type Workflow</h3><ol><li>Create <code>source/schemas/shopping/types/my_type.json</code></li><li>Add UCP annotations (<code>ucp_request</code>, <code>ucp_response</code>)</li><li>Run <code>python generate_schemas.py</code></li><li>Verify generated files in <code>spec/schemas/shopping/types/</code></li><li>Update documentation if needed</li><li>Check TypeScript generation works</li><li>May need to extend <code>generate_schemas.py</code> for new patterns</li></ol>"
        },
        {
          "id": "documentation-system",
          "label": "Documentation System",
          "description": "MkDocs with custom macros",
          "content": "<h3>Doc Generation</h3><p>UCP docs use custom MkDocs macros in <code>main.py</code>:</p><ul><li><strong>schema_fields</strong> - Generates tables from JSON schemas</li><li><strong>method_fields</strong> - Generates tables from OpenAPI/OpenRPC</li></ul><p>These macros read directly from <code>spec/</code>, so schema changes automatically propagate to docs.</p><p><strong>Commands:</strong></p><ul><li><code>mkdocs serve --watch spec</code> - Local preview</li><li><code>mkdocs build --strict</code> - Production build (fails on warnings)</li></ul>"
        }
      ]
    },
    {
      "id": "study-strategy",
      "label": "10. Study Strategy by Goal",
      "description": "Learning paths for different roles",
      "content": "<h3>Role-Based Learning Paths</h3><p>Different developers need different perspectives on UCP.</p>",
      "children": [
        {
          "id": "platform-developer",
          "label": "Platform Developers",
          "description": "Building shopping agents/apps",
          "content": "<h3>For Platform Developers</h3><p>Implementing a shopping agent or app that uses UCP:</p><ol><li><strong>core-concepts.md</strong> → Understand the four actors</li><li><strong>discovery/profile_schema.json</strong> → Parse business profiles</li><li><strong>checkout-mcp.md</strong> → MCP implementation for AI agents</li><li><strong>checkout.json + types/*</strong> → Data models</li><li><strong>buyer-consent.md</strong> → User permission framework</li></ol><p><strong>Key Focus:</strong> Calling UCP APIs, handling responses, UI/UX for checkout</p>"
        },
        {
          "id": "business-integrator",
          "label": "Business Integrators",
          "description": "Exposing inventory via UCP",
          "content": "<h3>For Business Integrators</h3><p>Exposing your inventory and implementing UCP endpoints:</p><ol><li><strong>core-concepts.md</strong> → Understand Merchant of Record role</li><li><strong>checkout-rest.md</strong> → REST endpoint implementation</li><li><strong>embedded-checkout.md</strong> → iframe integration patterns</li><li><strong>fulfillment.json</strong> → Shipping logic</li><li><strong>discount.json</strong> → Promotions system</li></ol><p><strong>Key Focus:</strong> Implementing endpoints, calculating tax/shipping, inventory management</p>"
        },
        {
          "id": "psp-cp-developer",
          "label": "PSP/CP Developers",
          "description": "Payment infrastructure",
          "content": "<h3>For PSP/CP Developers</h3><p>Building payment service providers or credential providers:</p><ol><li><strong>tokenization-guide.md</strong> → Token exchange flows</li><li><strong>payment-handler-guide.md</strong> → Handler integration</li><li><strong>handlers/tokenization/google_pay/</strong> → Reference implementation</li><li><strong>ap2-mandates.md</strong> → Security requirements (3DS, SCA)</li></ol><p><strong>Key Focus:</strong> Secure token exchange, PCI compliance, authentication mandates</p>"
        },
        {
          "id": "protocol-contributor",
          "label": "Protocol Contributors",
          "description": "Contributing to UCP itself",
          "content": "<h3>For Protocol Contributors</h3><p>Contributing schemas, documentation, or SDKs to UCP:</p><ol><li><strong>schema-authoring.md</strong> → Annotation system</li><li><strong>generate_schemas.py</strong> → Generation logic</li><li><strong>CONTRIBUTING.md</strong> → Process and conventions</li><li>All of the above 😄</li></ol><p><strong>Key Focus:</strong> Schema design, backward compatibility, documentation quality</p>"
        }
      ]
    },
    {
      "id": "key-insights",
      "label": "11. Key Insights",
      "description": "Critical understanding for mastery",
      "content": "<h3>Core Principles to Internalize</h3><p>These insights represent deep understanding of UCP's design philosophy.</p>",
      "children": [
        {
          "id": "composability",
          "label": "Composable Architecture",
          "description": "Capabilities + Extensions",
          "content": "<h3>Composability Principle</h3><p>UCP breaks commerce into:</p><ul><li><strong>Capabilities</strong> - Complete flows (checkout, order)</li><li><strong>Extensions</strong> - Optional enhancements (discounts, loyalty)</li></ul><p>This allows businesses to implement only what they need while maintaining interoperability.</p><p>New capabilities and extensions can be added without breaking existing implementations.</p>"
        },
        {
          "id": "data-flow",
          "label": "Typical Data Flow",
          "description": "End-to-end transaction",
          "content": "<h3>Standard Checkout Flow</h3><ol><li><strong>Discovery:</strong> Platform discovers Business via /.well-known/ucp</li><li><strong>Capabilities:</strong> Platform reads capabilities[] and payment.handlers[]</li><li><strong>Create:</strong> Platform calls checkout_create with initial state</li><li><strong>Options:</strong> Business responds with fulfillment options, payment methods</li><li><strong>Update:</strong> Platform calls checkout_update iteratively (add payment, select shipping)</li><li><strong>Validate:</strong> Business validates, applies logic (tax calculation, discount)</li><li><strong>Complete:</strong> Platform calls checkout_complete</li><li><strong>Order:</strong> Business places order, returns order_confirmation</li><li><strong>Webhooks:</strong> Business sends order updates (shipped, delivered)</li></ol>"
        },
        {
          "id": "security-layers",
          "label": "Multi-Layer Security",
          "description": "Defense in depth",
          "content": "<h3>Security Architecture</h3><p>UCP implements multiple security layers:</p><ul><li><strong>JWK Signing Keys</strong> - Message verification</li><li><strong>OAuth 2.0</strong> - Identity linking</li><li><strong>PCI-DSS Compliance</strong> - Via tokenization</li><li><strong>AP2 Mandates</strong> - 3DS and risk checks</li><li><strong>Buyer Consent</strong> - Explicit permissions for agents</li></ul><p>Each layer addresses a specific security concern without adding unnecessary complexity.</p>"
        },
        {
          "id": "schema-philosophy",
          "label": "Schema Design Philosophy",
          "description": "Minimal requests, rich responses",
          "content": "<h3>Design Principles</h3><ul><li><strong>Minimal Requests:</strong> Omit fields with sensible defaults</li><li><strong>Rich Responses:</strong> Provide full context to platforms</li><li><strong>Idempotent Operations:</strong> Safe to retry failed requests</li><li><strong>Extensible:</strong> additionalProperties: true allows custom fields</li></ul><p>This reduces bandwidth while giving platforms everything they need.</p>"
        },
        {
          "id": "transport-agnostic",
          "label": "Transport Agnostic Design",
          "description": "One protocol, many transports",
          "content": "<h3>Transport Independence</h3><p>UCP capabilities are defined independently of transport:</p><ul><li>Same checkout capability works over REST, MCP, A2A, or Embedded</li><li>Businesses choose which transports to support</li><li>New transports can be added without changing core protocol</li></ul><p>This future-proofs UCP as new communication protocols emerge.</p>"
        }
      ]
    }
  ]
}
