{
  "id": "root",
  "label": "UCP Learning Path",
  "children": [
    {
      "id": "foundations",
      "label": "1. Foundations & Philosophy",
      "description": "Understand the 'why' before the 'how'",
      "content": "<h3>Start Here: Core Concepts</h3><p>The Universal Commerce Protocol (UCP) addresses the fragmented commerce landscape by providing a standardized common language and functional primitives.</p><p><strong>Key Problem:</strong> Different systems (platforms, businesses, payment providers) can't communicate efficiently, leading to custom, one-off integrations.</p><p><strong>Solution:</strong> UCP provides a uniform protocol that works across all parties.</p>",
      "resources": [
        { "type": "doc", "url": "https://ucp.dev/documentation/core-concepts", "label": "Core Concepts Documentation" },
        { "type": "doc", "url": "https://github.com/Universal-Commerce-Protocol/ucp", "label": "GitHub Repository" }
      ],
      "children": [
        {
          "id": "four-actors",
          "label": "Four Actors Model",
          "description": "Platform, Business, CP, PSP",
          "content": "<h3>The Four Primary Actors</h3><p>UCP defines four distinct actors in the commerce lifecycle, each with specific responsibilities and clear boundaries. This separation enables secure, scalable, and compliant commerce without tight coupling.</p><h4>1. Platform (Consumer Surface)</h4><p>The consumer-facing surface acting on behalf of users - AI agents, mobile apps, social media, search engines.</p><p><strong>Responsibilities:</strong></p><ul><li>Discovers business capabilities via <code>/.well-known/ucp</code></li><li>Orchestrates checkout flow on behalf of user</li><li>Presents UI/conversational interface</li><li>Manages user consent for agentic transactions</li></ul><p><strong>Examples:</strong> AI Shopping Assistants, Super Apps (WeChat, Grab), Voice Assistants</p><h4>2. Business (Merchant of Record)</h4><p>The entity selling goods/services, retaining financial liability and order ownership.</p><p><strong>Responsibilities:</strong></p><ul><li>Exposes inventory and pricing via UCP</li><li>Calculates tax and shipping</li><li>Fulfills orders</li><li>Processes payments via chosen PSP</li></ul><p><strong>Examples:</strong> Retailers (Shopify merchants), Airlines, Hotels, SaaS providers</p><h4>3. Credential Provider (CP)</h4><p>Trusted entity managing sensitive user data, especially payment instruments and shipping addresses.</p><p><strong>Responsibilities:</strong></p><ul><li>Authenticates users (OAuth 2.0)</li><li>Issues payment tokens (keeps raw card data secure)</li><li>Holds PII to minimize compliance scope for others</li><li>Exchanges tokens with PSPs for transaction processing</li></ul><p><strong>Examples:</strong> Google Wallet, Apple Pay, Digital Wallet Providers</p><h4>4. Payment Service Provider (PSP)</h4><p>Financial infrastructure provider processing payments on behalf of businesses.</p><p><strong>Responsibilities:</strong></p><ul><li>Authorizes and captures transactions</li><li>Handles settlements with card networks</li><li>Exchanges tokens with CPs for payment data</li><li>Issues AP2 mandates for additional authentication (3DS)</li></ul><p><strong>Examples:</strong> Stripe, Adyen, PayPal, Braintree, Chase Paymentech</p><h4>Example: Complete Transaction Flow</h4><pre><code class=\"language-javascript\">// Platform discovers and initiates checkout\nasync function platformCheckout() {\n  // 1. Platform discovers business capabilities\n  const profile = await fetch('https://shop.example.com/.well-known/ucp');\n  const { capabilities } = await profile.json();\n  \n  // 2. Platform creates checkout session\n  const checkout = await fetch('https://shop.example.com/api/ucp/checkout/create', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      items: [{ sku: 'ABC123', quantity: 1 }],\n      buyer: { email: 'user@example.com' }\n    })\n  });\n  \n  // 3. User selects payment via Credential Provider\n  const paymentToken = await getPaymentFromCP(); // CP tokenizes card\n  \n  // 4. Platform updates checkout with payment\n  const updated = await fetch('https://shop.example.com/api/ucp/checkout/update', {\n    method: 'POST',\n    body: JSON.stringify({\n      checkout_id: checkout.id,\n      payment: { token: paymentToken, provider: 'google_pay' }\n    })\n  });\n  \n  // 5. Business forwards to PSP, PSP exchanges token with CP\n  // (happens server-side at Business)\n  \n  // 6. Platform completes checkout\n  const order = await fetch('https://shop.example.com/api/ucp/checkout/complete', {\n    method: 'POST',\n    body: JSON.stringify({ checkout_id: checkout.id })\n  });\n  \n  return order.order_id; // Transaction complete!\n}\n\n// Credential Provider tokenizes payment\nasync function getPaymentFromCP() {\n  // User provides payment method to CP (outside UCP scope)\n  // CP returns token that Platform sends to Business\n  return 'tok_secure_google_pay_token_12345';\n}\n</code></pre><h4>Key Insights</h4><ul><li><strong>Separation of Concerns:</strong> Each actor focuses on its expertise (Platform=UX, Business=Commerce, CP=Security, PSP=Payments)</li><li><strong>Trust Boundaries:</strong> Raw payment data never touches Platform or Business - only CP and PSP handle it</li><li><strong>Flexibility:</strong> Platform can work with any Business, Business can use any PSP, etc.</li></ul><h4>Common Pitfalls</h4><ul><li><strong>Confusing CP and PSP:</strong> CP holds user credentials and issues tokens; PSP processes the actual transaction with card networks. They exchange tokens securely.</li><li><strong>Assuming Platform is merchant:</strong> Business is always the Merchant of Record (MoR), not the Platform. Platform facilitates but doesn't own the transaction.</li><li><strong>Tight coupling:</strong> Avoid hard-coding business URLs - use discovery (<code>/.well-known/ucp</code>) to find endpoints dynamically.</li></ul>",
          "resources": [
            { "type": "doc", "url": "https://ucp.dev/documentation/core-concepts/#roles-participants", "label": "Roles & Participants" },
            { "type": "spec", "url": "https://ucp.dev/specification/overview/", "label": "UCP Specification Overview" }
          ]
        },
        {
          "id": "governance-model",
          "label": "Governance Model",
          "description": "Reverse-domain namespacing",
          "content": "<h3>Decentralized Governance</h3><p>UCP uses reverse-domain naming to encode governance authority directly into capability identifiers. This eliminates the need for a central registry while ensuring clear ownership and preventing namespace collisions.</p><h4>Namespace Format</h4><p><strong>Required Format:</strong> <code>{reverse-domain}.{service}.{capability}</code></p><p><strong>Components:</strong></p><ul><li><strong>{reverse-domain}</strong> - Authority identifier from domain ownership (e.g., <code>dev.ucp</code>, <code>com.shopify</code>)</li><li><strong>{service}</strong> - Service/vertical category (e.g., <code>shopping</code>, <code>common</code>, <code>payments</code>)</li><li><strong>{capability}</strong> - Specific capability name (e.g., <code>checkout</code>, <code>identity_linking</code>)</li></ul><h4>Official UCP Capabilities</h4><table><tr><th>Name</th><th>Authority</th><th>Service</th><th>Capability</th></tr><tr><td><code>dev.ucp.shopping.checkout</code></td><td>ucp.dev</td><td>shopping</td><td>checkout</td></tr><tr><td><code>dev.ucp.shopping.order</code></td><td>ucp.dev</td><td>shopping</td><td>order</td></tr><tr><td><code>dev.ucp.shopping.discount</code></td><td>ucp.dev</td><td>shopping</td><td>discount</td></tr><tr><td><code>dev.ucp.shopping.fulfillment</code></td><td>ucp.dev</td><td>shopping</td><td>fulfillment</td></tr><tr><td><code>dev.ucp.common.identity_linking</code></td><td>ucp.dev</td><td>common</td><td>identity_linking</td></tr></table><h4>Custom Vendor Capabilities</h4><p>Vendors can create custom capabilities using their own reverse-domain:</p><pre><code>com.shopify.payments.installments  // Shopify's installment payments\ncom.example.loyalty.rewards        // Example.com's loyalty program\norg.acme.shipping.same_day         // Acme.org's same-day delivery\n</code></pre><h4>Spec URL Binding (Security)</h4><p>The <code>spec</code> and <code>schema</code> URLs <strong>MUST</strong> have origins matching the namespace authority. This prevents capability hijacking.</p><table><tr><th>Namespace</th><th>Required Origin</th><th>Valid?</th></tr><tr><td><code>dev.ucp.*</code></td><td><code>https://ucp.dev/...</code></td><td>✅ Yes</td></tr><tr><td><code>dev.ucp.*</code></td><td><code>https://evil.com/...</code></td><td>❌ No (origin mismatch)</td></tr><tr><td><code>com.shopify.*</code></td><td><code>https://shopify.com/...</code></td><td>✅ Yes</td></tr></table><h4>Namespace Validation Code</h4><pre><code class=\"language-javascript\">/**\n * Validates a UCP capability namespace and spec URL binding\n * @param {object} capability - Capability object from profile\n * @returns {boolean} True if valid\n */\nfunction validateCapabilityNamespace(capability) {\n  const { name, spec, schema } = capability;\n  \n  // Parse namespace\n  const parts = name.split('.');\n  if (parts.length < 3) {\n    console.error(`Invalid namespace format: ${name}`);\n    return false;\n  }\n  \n  // Extract authority (reverse-domain)\n  const authority = parts.slice(0, -2).reverse().join('.');\n  console.log(`Authority: ${authority}`);\n  \n  // Validate spec URL origin matches authority\n  try {\n    const specUrl = new URL(spec);\n    const expectedOrigin = `https://${authority}`;\n    \n    if (!specUrl.origin.startsWith(expectedOrigin)) {\n      console.error(\n        `Spec URL origin mismatch: ` +\n        `expected ${expectedOrigin}, got ${specUrl.origin}`\n      );\n      return false;\n    }\n    \n    // Also validate schema URL if present\n    if (schema) {\n      const schemaUrl = new URL(schema);\n      if (!schemaUrl.origin.startsWith(expectedOrigin)) {\n        console.error(\n          `Schema URL origin mismatch: ` +\n          `expected ${expectedOrigin}, got ${schemaUrl.origin}`\n        );\n        return false;\n      }\n    }\n    \n    return true;\n    \n  } catch (error) {\n    console.error(`Invalid URL in capability:`, error);\n    return false;\n  }\n}\n\n// Example usage\nconst capability = {\n  name: 'dev.ucp.shopping.checkout',\n  spec: 'https://ucp.dev/specification/checkout',\n  schema: 'https://ucp.dev/schemas/shopping/checkout.json'\n};\n\nif (validateCapabilityNamespace(capability)) {\n  console.log('✅ Capability is valid');\n} else {\n  console.log('❌ Capability validation failed');\n}\n\n// This would fail (origin mismatch)\nconst malicious = {\n  name: 'dev.ucp.shopping.checkout',\n  spec: 'https://evil.com/fake-spec',  // Wrong origin!\n  schema: 'https://evil.com/fake-schema'\n};\nvalidateCapabilityNamespace(malicious); // => false\n</code></pre><h4>Governance Implications</h4><ul><li><strong>No Central Authority:</strong> Anyone can create capabilities under their domain</li><li><strong>Clear Ownership:</strong> Domain ownership proves authority</li><li><strong>No Collisions:</strong> Each domain controls its own namespace</li><li><strong>Verifiable:</strong> Spec URLs must match namespace origin (security)</li></ul><h4>Common Pitfalls</h4><ul><li><strong>Wrong component order:</strong> Must be reverse-domain first (e.g., <code>dev.ucp</code> not <code>ucp.dev</code>)</li><li><strong>Missing validation:</strong> Always validate spec URL origin matches namespace authority</li><li><strong>Using underscores:</strong> Use dots as separators, not underscores (except in final capability name)</li><li><strong>Assuming centralization:</strong> UCP has no central registry - governance is distributed via DNS</li></ul>",
          "resources": [
            { "type": "spec", "url": "https://ucp.dev/specification/overview/#namespace-governance", "label": "Namespace Governance" },
            { "type": "doc", "url": "https://ucp.dev/documentation/core-concepts/", "label": "Core Concepts" }
          ]
        },
        {
          "id": "server-selects",
          "label": "Server-Selects Architecture",
          "description": "Business chooses protocol version",
          "content": "<h3>Server-Selects Version Negotiation</h3><p>In UCP's server-selects architecture, the <strong>business (server)</strong> chooses the protocol version and capabilities from the intersection of what both parties support. This is the opposite of client-driven negotiation (like HTTP content negotiation).</p><h4>Why Server-Selects?</h4><ul><li><strong>Business Control:</strong> Business knows its implementation best and chooses compatible versions</li><li><strong>Gradual Evolution:</strong> New protocol versions can be deployed without breaking existing clients</li><li><strong>Simplified Clients:</strong> Platforms don't need complex fallback logic</li><li><strong>Testing:</strong> Business can test new versions with specific clients before wide rollout</li></ul><h4>Negotiation Flow</h4><ol><li><strong>Platform</strong> fetches business profile from <code>/.well-known/ucp</code></li><li><strong>Platform</strong> sends request with its supported capabilities in headers or params</li><li><strong>Business</strong> computes intersection of capabilities</li><li><strong>Business</strong> selects version from intersection (usually latest both support)</li><li><strong>Business</strong> responds using selected version</li></ol><h4>Capability Intersection Example</h4><pre><code class=\"language-javascript\">/**\n * Compute capability intersection between platform and business\n * @param {string[]} platformCaps - Platform's supported capabilities\n * @param {string[]} businessCaps - Business's supported capabilities  \n * @returns {string[]} Intersection of capabilities\n */\nfunction computeCapabilityIntersection(platformCaps, businessCaps) {\n  return platformCaps.filter(cap => businessCaps.includes(cap));\n}\n\n// Example: Platform supports checkout v1 and v2\nconst platformCapabilities = [\n  'dev.ucp.shopping.checkout@2026-01-11',\n  'dev.ucp.shopping.checkout@2025-06-01',\n  'dev.ucp.shopping.discount@2026-01-11'\n];\n\n// Business only supports checkout v1 (older)\nconst businessCapabilities = [\n  'dev.ucp.shopping.checkout@2025-06-01',\n  'dev.ucp.shopping.fulfillment@2025-06-01'\n];\n\nconst intersection = computeCapabilityIntersection(\n  platformCapabilities,\n  businessCapabilities\n);\n\nconsole.log('Intersection:', intersection);\n// => ['dev.ucp.shopping.checkout@2025-06-01']\n\n// Business selects from intersection (usually latest)\nconst selectedVersion = intersection[0];\nconsole.log('Business selects:', selectedVersion);\n</code></pre><h4>Implementation Pattern (Business)</h4><pre><code class=\"language-javascript\">// Express.js middleware for version negotiation\napp.use('/api/ucp/*', (req, res, next) => {\n  // Platform sends supported versions in header\n  const platformVersions = req.headers['x-ucp-versions']?.split(',') || [];\n  \n  // Business's supported versions\n  const businessVersions = [\n    'dev.ucp.shopping.checkout@2026-01-11',\n    'dev.ucp.shopping.checkout@2025-06-01'\n  ];\n  \n  // Compute intersection\n  const compatible = platformVersions.filter(v => \n    businessVersions.includes(v)\n  );\n  \n  if (compatible.length === 0) {\n    return res.status(400).json({\n      error: 'no_compatible_version',\n      message: 'No mutually supported protocol version',\n      business_versions: businessVersions\n    });\n  }\n  \n  // Business selects latest compatible version\n  const selected = compatible[0]; // Assume sorted newest first\n  \n  // Store selected version in request for handler use\n  req.ucpVersion = selected;\n  \n  // Return selected version in response header\n  res.setHeader('X-UCP-Version', selected);\n  \n  next();\n});\n\n// Checkout endpoint uses negotiated version\napp.post('/api/ucp/checkout/create', (req, res) => {\n  const version = req.ucpVersion;\n  \n  // Use version-specific logic\n  if (version === 'dev.ucp.shopping.checkout@2026-01-11') {\n    // Handle v2 with new features\n    return handleCheckoutV2(req, res);\n  } else {\n    // Handle v1 (backward compatibility)\n    return handleCheckoutV1(req, res);\n  }\n});\n</code></pre><h4>Caching Considerations</h4><p>Since profiles change infrequently:</p><ul><li>Platform caches business profile (1 hour recommended)</li><li>Business caches platform capabilities (per-session)</li><li>Negotiation happens once per session, not per request</li></ul><h4>Version Format</h4><p>Versions follow ISO date format: <code>YYYY-MM-DD</code></p><ul><li><code>dev.ucp.shopping.checkout@2026-01-11</code> - Explicit version</li><li><code>dev.ucp.shopping.checkout</code> - No version (assumes latest)</li></ul><h4>Common Pitfalls</h4><ul><li><strong>Client selecting version:</strong> Don't implement client-selects - business always chooses</li><li><strong>No intersection:</strong> Handle case where no common version exists gracefully</li><li><strong>Assuming latest:</strong> Business should select from intersection, not assume platform supports latest</li><li><strong>Per-request negotiation:</strong> Cache negotiation result, don't renegotiate every API call</li></ul><h4>Benefits Over Client-Selects</h4><ul><li>Business controls rollout of new versions</li><li>Easier A/B testing (business picks version per client)</li><li>Simpler platform code (no complex fallback chains)</li><li>Business can require minimum version for sensitive operations</li></ul>",
          "resources": [
            { "type": "spec", "url": "https://ucp.dev/specification/overview/#discovery-governance-and-negotiation", "label": "Discovery & Negotiation" },
            { "type": "doc", "url": "https://ucp.dev/documentation/core-concepts/", "label": "Core Concepts" }
          ]
        }
      ]
    },
    {
      "id": "discovery",
      "label": "2. Discovery & Capability System",
      "description": "How parties find and understand each other",
      "content": "<h3>Dynamic Discovery</h3><p>UCP enables platforms to autonomously discover what businesses support without manual configuration.</p>",
      "resources": [
        { "type": "spec", "url": "https://ucp.dev/specification/overview#discovery", "label": "Discovery Specification" }
      ],
      "children": [
        {
          "id": "well-known-ucp",
          "label": "/.well-known/ucp Endpoint",
          "description": "Standard discovery endpoint",
          "content": "<h3>Profile Discovery</h3><p>Every UCP-compliant business <strong>MUST</strong> expose a machine-readable profile at the standard <code>/.well-known/ucp</code> endpoint. This enables platforms to autonomously discover capabilities without manual configuration or API keys.</p><h4>Profile Structure</h4><p>The profile declares:</p><ul><li><strong>capabilities[]</strong> - Supported capabilities and extensions with versions</li><li><strong>services</strong> - Transport bindings (REST, MCP, A2A, Embedded)</li><li><strong>payment.handlers[]</strong> - Instructions for collecting payment instruments</li><li><strong>signing_keys[]</strong> - JWKs (JSON Web Keys) for signature verification</li><li><strong>webhooks</strong> - Callback endpoints for events (optional)</li></ul><h4>Example Profile</h4><pre><code class=\"language-json\">{\n  \"version\": \"2026-01-11\",\n  \"capabilities\": [\n    {\n      \"name\": \"dev.ucp.shopping.checkout\",\n      \"version\": \"2026-01-11\",\n      \"spec\": \"https://ucp.dev/specification/checkout\",\n      \"schema\": \"https://ucp.dev/schemas/shopping/checkout.json\",\n      \"extensions\": [\n        \"dev.ucp.shopping.discount\",\n        \"dev.ucp.shopping.fulfillment\"\n      ]\n    },\n    {\n      \"name\": \"dev.ucp.shopping.order\",\n      \"version\": \"2026-01-11\",\n      \"spec\": \"https://ucp.dev/specification/order\",\n      \"schema\": \"https://ucp.dev/schemas/shopping/order.json\"\n    }\n  ],\n  \"services\": {\n    \"shopping\": {\n      \"version\": \"2026-01-11\",\n      \"spec\": \"https://ucp.dev/services/shopping/\",\n      \"rest\": {\n        \"schema\": \"https://ucp.dev/services/shopping/rest.openapi.json\",\n        \"endpoint\": \"https://shop.example.com/api/ucp\"\n      },\n      \"mcp\": {\n        \"schema\": \"https://ucp.dev/services/shopping/mcp.openrpc.json\",\n        \"endpoint\": \"https://shop.example.com/mcp\"\n      }\n    }\n  },\n  \"payment\": {\n    \"handlers\": [\n      {\n        \"type\": \"google_pay\",\n        \"url\": \"https://shop.example.com/payment/google-pay\"\n      }\n    ]\n  },\n  \"signing_keys\": [\n    {\n      \"kty\": \"RSA\",\n      \"kid\": \"shop-2026-01\",\n      \"use\": \"sig\",\n      \"n\": \"0vx7agoebG...\",\n      \"e\": \"AQAB\"\n    }\n  ]\n}\n</code></pre><h4>Profile Fetching Code</h4><pre><code class=\"language-javascript\">/**\n * Fetch and parse UCP profile from a business\n * @param {string} businessUrl - Base URL of the business\n * @returns {Promise<UCPProfile>} Parsed profile\n */\nasync function fetchUCPProfile(businessUrl) {\n  try {\n    // Construct well-known URL\n    const url = new URL('/.well-known/ucp', businessUrl);\n    \n    const response = await fetch(url.toString(), {\n      headers: {\n        'Accept': 'application/json',\n        'User-Agent': 'MyPlatform/1.0 (UCP Client)'\n      },\n      // Cache profile for performance\n      cache: 'force-cache',\n      // Timeout after 5 seconds\n      signal: AbortSignal.timeout(5000)\n    });\n    \n    if (!response.ok) {\n      throw new Error(`Profile fetch failed: ${response.status}`);\n    }\n    \n    const profile = await response.json();\n    \n    // Validate required fields\n    if (!profile.capabilities || !Array.isArray(profile.capabilities)) {\n      throw new Error('Invalid profile: missing capabilities[]');\n    }\n    \n    if (!profile.services) {\n      throw new Error('Invalid profile: missing services');\n    }\n    \n    console.log(`Discovered ${profile.capabilities.length} capabilities`);\n    return profile;\n    \n  } catch (error) {\n    console.error('Failed to fetch UCP profile:', error);\n    throw error;\n  }\n}\n\n// Check if business supports specific capability\nfunction supportsCapability(profile, capabilityName) {\n  return profile.capabilities.some(cap => cap.name === capabilityName);\n}\n\n// Get REST endpoint for a service\nfunction getRESTEndpoint(profile, serviceName) {\n  const service = profile.services[serviceName];\n  return service?.rest?.endpoint || null;\n}\n\n// Example usage\nconst profile = await fetchUCPProfile('https://shop.example.com');\n\nif (supportsCapability(profile, 'dev.ucp.shopping.checkout')) {\n  const endpoint = getRESTEndpoint(profile, 'shopping');\n  console.log('Checkout endpoint:', endpoint);\n  // => https://shop.example.com/api/ucp\n}\n</code></pre><h4>Caching Strategy</h4><p>Profiles change infrequently, so aggressive caching is recommended:</p><ul><li><strong>HTTP Cache-Control:</strong> Businesses SHOULD set <code>max-age=3600</code> (1 hour)</li><li><strong>Client-Side:</strong> Platforms SHOULD cache profiles for at least 1 hour</li><li><strong>Invalidation:</strong> Refresh on 404/5xx errors or version mismatch</li></ul><h4>Common Pitfalls</h4><ul><li><strong>Forgetting HTTPS:</strong> Profile <strong>MUST</strong> be served over HTTPS in production</li><li><strong>Not caching:</strong> Fetching profile on every request wastes bandwidth - cache aggressively</li><li><strong>Ignoring extensions:</strong> Check <code>capability.extensions[]</code> to see optional features like discounts</li><li><strong>Hard-coding endpoints:</strong> Always read endpoints from profile, never hard-code</li></ul>",
          "resources": [
            { "type": "spec", "url": "https://ucp.dev/specification/overview/#discovery-governance-and-negotiation", "label": "Discovery Specification" },
            { "type": "schema", "url": "https://ucp.dev/schemas/discovery/profile.json", "label": "Profile Schema" }
          ]
        },
        {
          "id": "capabilities-vs-extensions",
          "label": "Capabilities vs Extensions",
          "description": "Core vs optional features",
          "content": "<h3>Composable Architecture</h3><p>UCP separates core functionality (capabilities) from optional enhancements (extensions) to keep the protocol lean while enabling rich feature sets.</p><h4>Capabilities (Core Features)</h4><p><strong>Capabilities</strong> are standalone, complete features that define an entire flow. They are the \"verbs\" of UCP.</p><p><strong>Characteristics:</strong></p><ul><li>Self-contained and independently useful</li><li>Define complete request/response lifecycle</li><li>Can work without any extensions</li><li>Examples: <code>checkout</code>, <code>order</code>, <code>identity_linking</code></li></ul><p><strong>Official UCP Capabilities:</strong></p><table><tr><th>Capability</th><th>Purpose</th><th>Complete Flow?</th></tr><tr><td><code>dev.ucp.shopping.checkout</code></td><td>End-to-end purchase flow</td><td>✅ Yes</td></tr><tr><td><code>dev.ucp.shopping.order</code></td><td>Post-purchase tracking</td><td>✅ Yes</td></tr><tr><td><code>dev.ucp.common.identity_linking</code></td><td>OAuth authorization</td><td>✅ Yes</td></tr></table><h4>Extensions (Optional Features)</h4><p><strong>Extensions</strong> augment a parent capability with additional functionality. They use the <code>extends</code> field to declare their parent.</p><p><strong>Characteristics:</strong></p><ul><li>Cannot work standalone (require parent capability)</li><li>Add optional fields to parent schemas</li><li>Business declares support via <code>capability.extensions[]</code></li><li>Examples: <code>discount</code>, <code>fulfillment</code>, <code>ap2_mandates</code></li></ul><p><strong>Official UCP Extensions:</strong></p><table><tr><th>Extension</th><th>Extends</th><th>Purpose</th></tr><tr><td><code>dev.ucp.shopping.discount</code></td><td>checkout</td><td>Promotional discounts</td></tr><tr><td><code>dev.ucp.shopping.fulfillment</code></td><td>checkout</td><td>Shipping options</td></tr><tr><td><code>dev.ucp.shopping.ap2_mandates</code></td><td>checkout</td><td>Payment authentication</td></tr></table><h4>Declaration Example</h4><pre><code class=\"language-json\">// Business profile declares capability with extensions\n{\n  \"capabilities\": [\n    {\n      \"name\": \"dev.ucp.shopping.checkout\",\n      \"version\": \"2026-01-11\",\n      \"spec\": \"https://ucp.dev/specification/checkout\",\n      \"schema\": \"https://ucp.dev/schemas/shopping/checkout.json\",\n      \n      // Extensions this business supports\n      \"extensions\": [\n        \"dev.ucp.shopping.discount\",\n        \"dev.ucp.shopping.fulfillment\"\n      ]\n    }\n  ]\n}\n</code></pre><h4>Checking for Extension Support</h4><pre><code class=\"language-javascript\">/**\n * Check if business supports a specific extension\n * @param {object} profile - UCP profile from /.well-known/ucp\n * @param {string} capabilityName - Parent capability name\n * @param {string} extensionName - Extension to check\n * @returns {boolean} True if supported\n */\nfunction supportsExtension(profile, capabilityName, extensionName) {\n  const capability = profile.capabilities.find(c => c.name === capabilityName);\n  \n  if (!capability) {\n    return false; // Capability not supported at all\n  }\n  \n  return capability.extensions?.includes(extensionName) || false;\n}\n\n// Example usage\nconst profile = await fetchUCPProfile('https://shop.example.com');\n\n// Check if discounts are supported\nif (supportsExtension(profile, 'dev.ucp.shopping.checkout', 'dev.ucp.shopping.discount')) {\n  console.log('✅ This business supports discount codes!');\n  // Show coupon code input in UI\n} else {\n  console.log('❌ No discount support');\n  // Hide coupon code input\n}\n\n// Check if advanced fulfillment is supported\nif (supportsExtension(profile, 'dev.ucp.shopping.checkout', 'dev.ucp.shopping.fulfillment')) {\n  console.log('✅ Advanced shipping options available');\n} else {\n  console.log('Basic shipping only');\n}\n</code></pre><h4>Schema Composition</h4><p>Extensions modify the parent capability's schema using JSON Schema <code>allOf</code> composition:</p><pre><code class=\"language-json\">// Discount extension adds fields to checkout\n{\n  \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n  \"$id\": \"https://ucp.dev/schemas/shopping/discount.json\",\n  \"title\": \"Discount Extension\",\n  \"extends\": \"dev.ucp.shopping.checkout\",\n  \n  \"allOf\": [\n    {\n      \"$ref\": \"./checkout.json\"  // Base checkout schema\n    },\n    {\n      // Additional fields added by discount extension\n      \"properties\": {\n        \"discount\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"code\": { \"type\": \"string\" },\n            \"amount\": { \"type\": \"integer\" },\n            \"type\": { \"enum\": [\"percentage\", \"fixed\"] }\n          }\n        }\n      }\n    }\n  ]\n}\n</code></pre><h4>Extension Lifecycle</h4><ol><li><strong>Discovery:</strong> Platform reads business profile, sees supported extensions</li><li><strong>Schema Resolution:</strong> Platform fetches extension schemas and composes with base</li><li><strong>Request:</strong> Platform sends request with extension-specific fields (if applicable)</li><li><strong>Response:</strong> Business includes extension fields in response</li></ol><h4>Design Principles</h4><ul><li><strong>Lean Core:</strong> Base capabilities work without extensions (graceful degradation)</li><li><strong>Optional:</strong> Platforms can ignore unsupported extensions</li><li><strong>Composable:</strong> Multiple extensions can augment the same capability</li><li><strong>Self-Describing:</strong> Extension schemas declare what they add</li></ul><h4>Common Pitfalls</h4><ul><li><strong>Assuming extension support:</strong> Always check <code>capability.extensions[]</code> before using extension fields</li><li><strong>Making extensions required:</strong> Extensions should be truly optional - core flow works without them</li><li><strong>Not fetching extension schemas:</strong> Must compose base + extension schemas for validation</li><li><strong>Wrong extends reference:</strong> Extension must reference an actual capability, not another extension</li></ul>",
          "resources": [
            { "type": "spec", "url": "https://ucp.dev/specification/overview/#extensions", "label": "Extensions Specification" },
            { "type": "schema", "url": "https://ucp.dev/schemas/shopping/discount.json", "label": "Discount Extension Schema" }
          ]
        },
        {
          "id": "namespace-format",
          "label": "Namespace Format",
          "description": "Reverse-domain naming convention",
          "content": "<h3>Capability Naming Convention</h3><p>All UCP capabilities and services <strong>MUST</strong> follow the reverse-domain naming format. This ensures global uniqueness and encodes governance authority directly in the name.</p><h4>Required Format</h4><pre><code>{reverse-domain}.{service}.{capability}\n\nExamples:\ndev.ucp.shopping.checkout      // Official UCP capability\ncom.shopify.loyalty.points     // Shopify's custom capability\norg.example.shipping.expedited // Example.org's expedited shipping\n</code></pre><h4>Component Breakdown</h4><table><tr><th>Component</th><th>Purpose</th><th>Rules</th><th>Example</th></tr><tr><td><strong>reverse-domain</strong></td><td>Authority identifier</td><td>Lowercase, dots as separators</td><td><code>dev.ucp</code>, <code>com.shopify</code></td></tr><tr><td><strong>service</strong></td><td>Vertical/category</td><td>Lowercase, single word</td><td><code>shopping</code>, <code>common</code>, <code>payments</code></td></tr><tr><td><strong>capability</strong></td><td>Specific feature name</td><td>Lowercase, underscores OK</td><td><code>checkout</code>, <code>identity_linking</code></td></tr></table><h4>Official UCP Namespaces</h4><p><strong>dev.ucp.shopping.*</strong> - Shopping/Commerce capabilities</p><ul><li><code>dev.ucp.shopping.checkout</code> - Complete checkout flow</li><li><code>dev.ucp.shopping.order</code> - Order tracking and webhooks</li><li><code>dev.ucp.shopping.discount</code> - Promotional discounts (extension)</li><li><code>dev.ucp.shopping.fulfillment</code> - Shipping options (extension)</li><li><code>dev.ucp.shopping.ap2_mandates</code> - Payment auth (extension)</li></ul><p><strong>dev.ucp.common.*</strong> - Cross-domain capabilities</p><ul><li><code>dev.ucp.common.identity_linking</code> - OAuth 2.0 authorization</li></ul><h4>Custom Vendor Namespaces</h4><p>Vendors create capabilities under their reverse-domain:</p><pre><code>// Shopify capabilities\ncom.shopify.payments.installments\ncom.shopify.loyalty.rewards\ncom.shopify.shipping.local_pickup\n\n// PayPal capabilities\ncom.paypal.express.checkout\ncom.paypal.subscription.billing\n\n// Example.com capabilities  \ncom.example.analytics.tracking\ncom.example.returns.rma\n</code></pre><h4>Parsing Utilities</h4><pre><code class=\"language-javascript\">/**\n * Parse a UCP capability namespace\n * @param {string} namespace - Full namespace string\n * @returns {object} Parsed components\n */\nfunction parseNamespace(namespace) {\n  const parts = namespace.split('.');\n  \n  if (parts.length < 3) {\n    throw new Error(`Invalid namespace: ${namespace} (need at least 3 parts)`);\n  }\n  \n  // Last part is capability\n  const capability = parts[parts.length - 1];\n  \n  // Second to last is service\n  const service = parts[parts.length - 2];\n  \n  // Everything before is reverse-domain\n  const reverseDomain = parts.slice(0, -2).join('.');\n  \n  // Convert reverse-domain to normal domain\n  const authority = parts.slice(0, -2).reverse().join('.');\n  \n  return {\n    namespace,\n    reverseDomain,\n    authority,\n    service,\n    capability,\n    // Helper: expected spec origin\n    expectedOrigin: `https://${authority}`\n  };\n}\n\n// Example usage\nconst parsed = parseNamespace('dev.ucp.shopping.checkout');\nconsole.log(parsed);\n/*\n{\n  namespace: 'dev.ucp.shopping.checkout',\n  reverseDomain: 'dev.ucp',\n  authority: 'ucp.dev',\n  service: 'shopping',\n  capability: 'checkout',\n  expectedOrigin: 'https://ucp.dev'\n}\n*/\n\n// Validate a capability's spec URL matches its namespace\nfunction validateSpecURL(capability) {\n  const parsed = parseNamespace(capability.name);\n  const specUrl = new URL(capability.spec);\n  \n  if (!specUrl.origin.startsWith(parsed.expectedOrigin)) {\n    throw new Error(\n      `Spec URL origin mismatch: expected ${parsed.expectedOrigin}, ` +\n      `got ${specUrl.origin}`\n    );\n  }\n  \n  return true;\n}\n\n// Example: validate official UCP capability\nconst ucpCap = {\n  name: 'dev.ucp.shopping.checkout',\n  spec: 'https://ucp.dev/specification/checkout'\n};\nvalidateSpecURL(ucpCap); // ✅ Valid\n\n// Example: detect malicious capability\nconst maliciousCap = {\n  name: 'dev.ucp.shopping.checkout',\n  spec: 'https://evil.com/fake-spec'\n};\ntry {\n  validateSpecURL(maliciousCap); // ❌ Throws error\n} catch (e) {\n  console.error(e.message);\n  // => \"Spec URL origin mismatch: expected https://ucp.dev, got https://evil.com\"\n}\n</code></pre><h4>Version Suffixes (Optional)</h4><p>Capabilities can include version suffixes using <code>@</code>:</p><pre><code>dev.ucp.shopping.checkout@2026-01-11  // Explicit version\ndev.ucp.shopping.checkout             // No version (implies latest)\n</code></pre><p>Version format is ISO date: <code>YYYY-MM-DD</code></p><h4>Naming Rules (RFC)</h4><ul><li><strong>Lowercase only:</strong> <code>dev.ucp</code> not <code>Dev.UCP</code></li><li><strong>Dots as separators:</strong> Between domain parts and components</li><li><strong>Underscores in capability:</strong> OK in final capability name (<code>identity_linking</code>)</li><li><strong>No hyphens:</strong> Use underscores instead</li><li><strong>ASCII only:</strong> No unicode, emojis, or special characters</li></ul><h4>Pattern Matching</h4><pre><code class=\"language-javascript\">// Match all capabilities from a specific authority\nfunction isUCPOfficial(namespace) {\n  return namespace.startsWith('dev.ucp.');\n}\n\n// Match all capabilities in a service\nfunction isShoppingCapability(namespace) {\n  return /^[a-z]+\\.[a-z]+\\.shopping\\./i.test(namespace);\n}\n\n// Extract service name\nfunction getService(namespace) {\n  const parts = namespace.split('.');\n  return parts[parts.length - 2];\n}\n\nconsole.log(getService('dev.ucp.shopping.checkout'));  // => 'shopping'\nconsole.log(getService('com.shopify.loyalty.points')); // => 'loyalty'\n</code></pre><h4>Common Pitfalls</h4><ul><li><strong>Wrong order:</strong> Must be reverse-domain first (<code>dev.ucp</code> not <code>ucp.dev</code>)</li><li><strong>Too few parts:</strong> Need at least 3 parts (reverse-domain.service.capability)</li><li><strong>Using hyphens:</strong> Use underscores in capability names, not hyphens</li><li><strong>Uppercase letters:</strong> All lowercase required</li><li><strong>Not validating origin:</strong> Always check spec URL matches namespace authority</li></ul>",
          "resources": [
            { "type": "spec", "url": "https://ucp.dev/specification/overview/#namespace-governance", "label": "Namespace Governance Spec" },
            { "type": "doc", "url": "https://ucp.dev/documentation/core-concepts/", "label": "Core Concepts" }
          ]
        }
      ]
    },
    {
      "id": "shopping-domain",
      "label": "3. Core Shopping Domain",
      "description": "Main commerce primitives and schemas",
      "content": "<h3>Shopping Domain Overview</h3><p>The shopping domain contains the core schemas for commerce transactions.</p>",
      "children": [
        {
          "id": "checkout-schema",
          "label": "Checkout Schema",
          "description": "Central state object for transactions",
          "content": "<h3>The Checkout Object</h3><p>The checkout schema (<code>dev.ucp.shopping.checkout</code>) is the central state object in UCP, flowing through the entire purchase lifecycle. It represents a shopping cart progressing toward an order.</p><h4>Core Fields (Required)</h4><table><tr><th>Field</th><th>Type</th><th>Description</th></tr><tr><td><code>id</code></td><td>string</td><td>Unique checkout session identifier</td></tr><tr><td><code>line_items[]</code></td><td>array</td><td>Cart items with SKU, quantity, price</td></tr><tr><td><code>status</code></td><td>enum</td><td>Checkout state (incomplete, ready_for_complete, completed, etc.)</td></tr><tr><td><code>currency</code></td><td>string</td><td>ISO 4217 code (USD, EUR, GBP)</td></tr><tr><td><code>totals[]</code></td><td>array</td><td>Price breakdown (subtotal, tax, shipping, total)</td></tr><tr><td><code>payment</code></td><td>object</td><td>Payment handlers and selected instruments</td></tr><tr><td><code>links[]</code></td><td>array</td><td>HATEOAS links (continue_url, cancel_url)</td></tr></table><h4>Optional Fields</h4><ul><li><code>buyer</code> - Customer email, name, phone</li><li><code>messages[]</code> - Errors, warnings, info messages</li><li><code>metadata</code> - Business-specific data</li><li><code>fulfillment</code> - Shipping options/addresses (if extension supported)</li><li><code>discount</code> - Applied promotions (if extension supported)</li></ul><h4>Checkout Status Lifecycle</h4><pre><code>incomplete → (gather info via updates) → ready_for_complete → complete_in_progress → completed\n      ↓                                                                    ↓\nrequires_escalation (buyer handoff)                                  canceled\n</code></pre><p><strong>Status Values:</strong></p><ul><li><code>incomplete</code> - Missing required data, check <code>messages[]</code> for what's needed</li><li><code>requires_escalation</code> - Needs buyer handoff via <code>continue_url</code> link</li><li><code>ready_for_complete</code> - All data collected, platform can call complete</li><li><code>complete_in_progress</code> - Business processing order</li><li><code>completed</code> - Order placed successfully</li><li><code>canceled</code> - Session expired or invalidated</li></ul><h4>Complete Checkout Lifecycle Example</h4><pre><code class=\"language-javascript\">// Step 1: CREATE checkout with initial items\nconst createReq = {\n  line_items: [\n    {\n      sku: 'WIDGET-123',\n      quantity: 2,\n      title: 'Blue Widget',\n      price: 2999  // $29.99 in cents (minor units)\n    }\n  ],\n  currency: 'USD',\n  buyer: {\n    email: 'user@example.com',\n    first_name: 'Jane',\n    last_name: 'Doe'\n  }\n};\n\nconst createResp = await fetch('https://shop.example.com/api/ucp/checkout/create', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify(createReq)\n});\n\nconst checkout = await createResp.json();\nconsole.log('Checkout created:', checkout.id);\nconsole.log('Status:', checkout.status);  // => 'incomplete'\n\n/*\nResponse structure:\n{\n  \"id\": \"chk_abc123\",\n  \"status\": \"incomplete\",\n  \"line_items\": [...],\n  \"currency\": \"USD\",\n  \"totals\": [\n    { \"type\": \"subtotal\", \"amount\": 5998 },\n    { \"type\": \"tax\", \"amount\": 0 },\n    { \"type\": \"total\", \"amount\": 5998 }\n  ],\n  \"payment\": {\n    \"handlers\": [  // How to collect payment\n      {\n        \"type\": \"google_pay\",\n        \"url\": \"https://shop.example.com/payment/google-pay\"\n      }\n    ],\n    \"instruments\": []  // Empty - no payment collected yet\n  },\n  \"messages\": [\n    {\n      \"type\": \"info\",\n      \"message\": \"Payment method required\"\n    }\n  ],\n  \"links\": [\n    {\n      \"rel\": \"continue\",\n      \"href\": \"https://shop.example.com/checkout/chk_abc123\"\n    }\n  ]\n}\n*/\n\n// Step 2: UPDATE with payment instrument\nconst updateReq = {\n  id: checkout.id,\n  payment: {\n    instruments: [\n      {\n        type: 'card_payment_instrument',\n        token: 'tok_google_pay_xyz789',  // From Credential Provider\n        provider: 'google_pay',\n        last4: '4242',\n        brand: 'visa'\n      }\n    ]\n  }\n};\n\nconst updateResp = await fetch('https://shop.example.com/api/ucp/checkout/update', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify(updateReq)\n});\n\nconst updated = await updateResp.json();\nconsole.log('Status:', updated.status);  // => 'ready_for_complete'\n\n// Step 3: COMPLETE checkout\nif (updated.status === 'ready_for_complete') {\n  const completeReq = {\n    id: checkout.id\n  };\n  \n  const completeResp = await fetch('https://shop.example.com/api/ucp/checkout/complete', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(completeReq)\n  });\n  \n  const final = await completeResp.json();\n  console.log('Status:', final.status);  // => 'completed'\n  console.log('Order ID:', final.order_id);  // Business's order ID\n  \n  /*\n  Completed response:\n  {\n    \"id\": \"chk_abc123\",\n    \"status\": \"completed\",\n    \"order_id\": \"ORDER-2026-001\",\n    \"line_items\": [...],\n    \"totals\": [\n      { \"type\": \"subtotal\", \"amount\": 5998 },\n      { \"type\": \"tax\", \"amount\": 479 },\n      { \"type\": \"shipping\", \"amount\": 500 },\n      { \"type\": \"total\", \"amount\": 6977 }\n    ],\n    \"payment\": {\n      \"status\": \"authorized\",\n      \"instruments\": [...]\n    },\n    \"links\": [\n      {\n        \"rel\": \"order\",\n        \"href\": \"https://shop.example.com/orders/ORDER-2026-001\"\n      }\n    ]\n  }\n  */\n}\n</code></pre><h4>Handling Checkout Messages</h4><pre><code class=\"language-javascript\">// Check messages for errors/warnings\nfunction handleCheckoutMessages(checkout) {\n  if (!checkout.messages || checkout.messages.length === 0) {\n    return;\n  }\n  \n  checkout.messages.forEach(msg => {\n    switch (msg.type) {\n      case 'error':\n        console.error('❌ Error:', msg.message);\n        // Show error to user\n        break;\n      case 'warning':\n        console.warn('⚠️  Warning:', msg.message);\n        break;\n      case 'info':\n        console.log('ℹ️  Info:', msg.message);\n        break;\n    }\n  });\n}\n\n// Example messages\nconst messages = [\n  {\n    type: 'error',\n    code: 'invalid_payment',\n    message: 'Payment instrument declined'\n  },\n  {\n    type: 'warning',\n    code: 'low_inventory',\n    message: 'Only 2 items remaining in stock'\n  },\n  {\n    type: 'info',\n    message: 'Free shipping on orders over $50'\n  }\n];\n</code></pre><h4>Totals Array Structure</h4><pre><code class=\"language-javascript\">// Totals show price breakdown\nconst totals = [\n  { type: 'subtotal', amount: 5998, label: 'Subtotal' },\n  { type: 'tax', amount: 479, label: 'Sales Tax (8%)' },\n  { type: 'shipping', amount: 500, label: 'Standard Shipping' },\n  { type: 'discount', amount: -1000, label: 'Coupon: SAVE10' },  // If discount extension\n  { type: 'total', amount: 5977, label: 'Total' }\n];\n\n// Amounts are always in minor units (cents for USD)\n// To display: amount / 100\nconsole.log('Total: $' + (5977 / 100).toFixed(2));  // => \"Total: $59.77\"\n</code></pre><h4>Common Pitfalls</h4><ul><li><strong>Forgetting minor units:</strong> Amounts are in cents (5998 = $59.98), not dollars</li><li><strong>Ignoring status:</strong> Always check <code>status</code> before calling complete</li><li><strong>Not reading messages:</strong> <code>messages[]</code> explains errors - don't ignore them</li><li><strong>Modifying read-only fields:</strong> <code>status</code>, <code>totals</code>, <code>ucp</code> are set by business, not platform</li><li><strong>Missing required fields:</strong> <code>line_items</code>, <code>currency</code>, <code>payment</code> are required</li></ul>",
          "resources": [
            { "type": "spec", "url": "https://ucp.dev/specification/checkout/", "label": "Checkout Capability Specification" },
            { "type": "schema", "url": "https://ucp.dev/schemas/shopping/checkout.json", "label": "Checkout Schema (JSON)" }
          ]
        },
        {
          "id": "payment-schema",
          "label": "Payment Schema",
          "description": "Payment instruments and methods",
          "content": "<h3>Payment Structure</h3><p>UCP uses payment handlers to define how platforms collect payment instruments. The checkout object contains <code>payment.handlers[]</code> (instructions from business) and <code>payment.instruments[]</code> (collected by platform).</p><h4>Core Payment Concepts</h4><ul><li><strong>Payment Handler</strong> - Instructions for how to collect payment (e.g., Google Pay configuration)</li><li><strong>Payment Instrument</strong> - Collected payment method with display info (last4, brand, expiry)</li><li><strong>Payment Credential</strong> - Actual payment data (token, encrypted card) inside instrument</li></ul><h4>Payment Handler Structure</h4><p>Businesses declare supported payment handlers in checkout responses:</p><pre><code class=\"language-json\">{\n  \"payment\": {\n    \"handlers\": [\n      {\n        \"id\": \"gpay_handler_1\",\n        \"name\": \"com.google.pay\",\n        \"version\": \"2026-01-11\",\n        \"spec\": \"https://ucp.dev/handlers/google-pay\",\n        \"config_schema\": \"https://ucp.dev/handlers/google-pay/config.json\",\n        \"instrument_schemas\": [\n          \"https://ucp.dev/handlers/google-pay/instrument.json\"\n        ],\n        \"config\": {\n          \"merchant_id\": \"BCR2DN6TW3QFC4ZU\",\n          \"merchant_name\": \"Example Store\",\n          \"gateway\": \"stripe\",\n          \"gateway_merchant_id\": \"acct_1234567890\",\n          \"allowed_card_networks\": [\"VISA\", \"MASTERCARD\", \"AMEX\"],\n          \"environment\": \"PRODUCTION\"\n        }\n      }\n    ],\n    \"instruments\": []  // Populated by platform after collection\n  }\n}\n</code></pre><h4>Payment Instrument with Tokenization</h4><p>After the platform collects payment via handler, it sends the instrument back in checkout update:</p><pre><code class=\"language-javascript\">// Platform collects Google Pay token from buyer\nconst googlePayToken = await collectGooglePay(handler.config);\n\n// Platform creates payment instrument\nconst instrument = {\n  id: 'inst_gpay_123',\n  handler_id: 'gpay_handler_1',  // References handler from business\n  type: 'card',\n  brand: 'visa',\n  last_digits: '4242',\n  expiry_month: 12,\n  expiry_year: 2026,\n  \n  // Credential contains tokenized payment data\n  credential: {\n    type: 'token',\n    token: googlePayToken  // Encrypted token from Google\n  },\n  \n  billing_address: {\n    street_address: '123 Main St',\n    address_locality: 'Austin',\n    address_region: 'TX',\n    postal_code: '78701',\n    address_country: 'US'\n  }\n};\n\n// Update checkout with collected instrument\nconst updateReq = {\n  id: checkout.id,\n  payment: {\n    instruments: [instrument]\n  }\n};\n\nawait fetch('https://shop.example.com/api/ucp/checkout/update', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify(updateReq)\n});\n</code></pre><h4>Complete Google Pay Example</h4><pre><code class=\"language-javascript\">// Step 1: Platform receives handler config from business\nconst checkout = await createCheckout();\nconst googlePayHandler = checkout.payment.handlers.find(\n  h => h.name === 'com.google.pay'\n);\n\nif (!googlePayHandler) {\n  console.error('Google Pay not supported');\n  return;\n}\n\n// Step 2: Platform initializes Google Pay with business config\nconst paymentsClient = new google.payments.api.PaymentsClient({\n  environment: googlePayHandler.config.environment  // 'TEST' or 'PRODUCTION'\n});\n\nconst paymentDataRequest = {\n  apiVersion: 2,\n  apiVersionMinor: 0,\n  allowedPaymentMethods: [{\n    type: 'CARD',\n    parameters: {\n      allowedAuthMethods: ['PAN_ONLY', 'CRYPTOGRAM_3DS'],\n      allowedCardNetworks: googlePayHandler.config.allowed_card_networks\n    },\n    tokenizationSpecification: {\n      type: 'PAYMENT_GATEWAY',\n      parameters: {\n        gateway: googlePayHandler.config.gateway,\n        gatewayMerchantId: googlePayHandler.config.gateway_merchant_id\n      }\n    }\n  }],\n  merchantInfo: {\n    merchantId: googlePayHandler.config.merchant_id,\n    merchantName: googlePayHandler.config.merchant_name\n  },\n  transactionInfo: {\n    totalPriceStatus: 'FINAL',\n    totalPrice: (checkout.totals.find(t => t.type === 'total').amount / 100).toFixed(2),\n    currencyCode: checkout.currency\n  }\n};\n\n// Step 3: Collect payment from buyer\nconst paymentData = await paymentsClient.loadPaymentData(paymentDataRequest);\nconst token = paymentData.paymentMethodData.tokenizationData.token;\n\n// Step 4: Create instrument with token credential\nconst instrument = {\n  id: 'inst_gpay_' + Date.now(),\n  handler_id: googlePayHandler.id,\n  type: 'card',\n  brand: paymentData.paymentMethodData.info.cardNetwork.toLowerCase(),\n  last_digits: paymentData.paymentMethodData.info.cardDetails.slice(-4),\n  credential: {\n    type: 'token',\n    token: token  // Google Pay token - business forwards to PSP\n  },\n  billing_address: {\n    street_address: paymentData.paymentMethodData.info.billingAddress.address1,\n    address_locality: paymentData.paymentMethodData.info.billingAddress.locality,\n    address_region: paymentData.paymentMethodData.info.billingAddress.administrativeArea,\n    postal_code: paymentData.paymentMethodData.info.billingAddress.postalCode,\n    address_country: paymentData.paymentMethodData.info.billingAddress.countryCode\n  }\n};\n\n// Step 5: Update checkout with instrument\nawait updateCheckoutWithPayment(checkout.id, instrument);\n</code></pre><h4>Token Credential Flow</h4><p>The token credential moves through the system without exposing raw card data:</p><pre><code>1. Buyer provides card to Google Pay (outside UCP)\n2. Google Pay generates encrypted token\n3. Platform receives token, creates instrument with token credential\n4. Platform sends instrument to Business in checkout update\n5. Business forwards token to PSP (Stripe, Adyen, etc.)\n6. PSP exchanges token with Google for actual card data\n7. PSP processes payment with card networks\n</code></pre><p>This flow keeps raw card data out of Platform and Business systems, minimizing PCI-DSS compliance scope.</p><h4>Credential Types</h4><table><tr><th>Type</th><th>Use Case</th><th>Example</th></tr><tr><td><code>token</code></td><td>Tokenized payment (Google Pay, Apple Pay)</td><td><code>{\"type\": \"token\", \"token\": \"tok_gpay_xyz\"}</code></td></tr><tr><td><code>card</code></td><td>Raw card data (rarely used - PCI scope)</td><td><code>{\"type\": \"card\", \"number\": \"4111...\", \"cvc\": \"123\"}</code></td></tr></table><h4>Common Pitfalls</h4><ul><li><strong>Missing handler_id:</strong> Instrument must reference which handler produced it via <code>handler_id</code></li><li><strong>Exposing token in response:</strong> Token credential has <code>\"ucp_response\": \"omit\"</code> - business never sends token back to platform</li><li><strong>Wrong handler config:</strong> Must use exact config from business handler declaration, don't modify values</li><li><strong>Forgetting binding:</strong> When using tokenization handlers, include <code>checkout_id</code> in binding to prevent token reuse</li><li><strong>Not validating handler:</strong> Always check <code>handler.name</code> and <code>handler.version</code> match what platform supports</li></ul>",
          "resources": [
            { "type": "spec", "url": "https://ucp.dev/specification/checkout/#payment-handler-response", "label": "Payment Handler Specification" },
            { "type": "spec", "url": "https://ucp.dev/specification/tokenization-guide/", "label": "Tokenization Guide" },
            { "type": "schema", "url": "https://ucp.dev/schemas/shopping/types/payment_handler.json", "label": "Payment Handler Schema" },
            { "type": "schema", "url": "https://ucp.dev/schemas/shopping/types/payment_instrument.json", "label": "Payment Instrument Schema" },
            { "type": "schema", "url": "https://ucp.dev/schemas/shopping/types/token_credential.json", "label": "Token Credential Schema" }
          ]
        },
        {
          "id": "fulfillment-schema",
          "label": "Fulfillment Schema",
          "description": "Shipping and delivery",
          "content": "<h3>Fulfillment System</h3><p>The fulfillment extension (<code>dev.ucp.shopping.fulfillment</code>) enables shipping, pickup, and delivery options. It structures fulfillment as:</p><ul><li><strong>Methods</strong> - Fulfillment types (shipping, pickup) with destinations</li><li><strong>Groups</strong> - Packages within a method (items grouped for fulfillment)</li><li><strong>Options</strong> - Selectable choices per group (Standard vs Express shipping)</li></ul><h4>Core Structure</h4><pre><code class=\"language-json\">{\n  \"fulfillment\": {\n    \"methods\": [\n      {\n        \"id\": \"method_1\",\n        \"type\": \"shipping\",\n        \"line_item_ids\": [\"shirt\", \"pants\"],\n        \"selected_destination_id\": \"dest_1\",\n        \"destinations\": [{\n          \"id\": \"dest_1\",\n          \"street_address\": \"123 Main St\",\n          \"address_locality\": \"Austin\",\n          \"address_region\": \"TX\",\n          \"postal_code\": \"78701\",\n          \"address_country\": \"US\"\n        }],\n        \"groups\": [\n          {\n            \"id\": \"package_1\",\n            \"line_item_ids\": [\"shirt\", \"pants\"],\n            \"selected_option_id\": \"standard\",\n            \"options\": [\n              {\n                \"id\": \"standard\",\n                \"title\": \"Standard Shipping\",\n                \"description\": \"Arrives Dec 12-15 via USPS\",\n                \"totals\": [{\"type\": \"total\", \"amount\": 500}]\n              },\n              {\n                \"id\": \"express\",\n                \"title\": \"Express Shipping\",\n                \"description\": \"Arrives Dec 10-11 via FedEx\",\n                \"totals\": [{\"type\": \"total\", \"amount\": 1000}]\n              }\n            ]\n          }\n        ]\n      }\n    ]\n  }\n}\n</code></pre><h4>Selecting Shipping Options</h4><pre><code class=\"language-javascript\">// Step 1: Platform receives fulfillment options from business\nconst checkout = await createCheckout({\n  line_items: [\n    { sku: 'SHIRT-001', quantity: 1 },\n    { sku: 'PANTS-001', quantity: 1 }\n  ],\n  currency: 'USD'\n});\n\n// Business returns fulfillment structure\nconst method = checkout.fulfillment.methods[0];\nconst group = method.groups[0];\n\nconsole.log('Available shipping options:');\ngroup.options.forEach(opt => {\n  console.log(`${opt.id}: ${opt.title} - $${opt.totals[0].amount / 100}`);\n  console.log(`  ${opt.description}`);\n});\n\n// Output:\n// standard: Standard Shipping - $5.00\n//   Arrives Dec 12-15 via USPS\n// express: Express Shipping - $10.00\n//   Arrives Dec 10-11 via FedEx\n\n// Step 2: Buyer selects express shipping\nconst updatedGroup = {\n  ...group,\n  selected_option_id: 'express'\n};\n\nconst updatedMethod = {\n  ...method,\n  groups: [updatedGroup]\n};\n\n// Step 3: Update checkout with selection\nconst updateReq = {\n  id: checkout.id,\n  fulfillment: {\n    methods: [updatedMethod]\n  }\n};\n\nconst updated = await fetch('https://shop.example.com/api/ucp/checkout/update', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify(updateReq)\n});\n\nconst result = await updated.json();\n\n// Business recalculates totals with new shipping cost\nconsole.log('Updated total:', result.totals.find(t => t.type === 'total').amount);\n</code></pre><h4>Multi-Group Fulfillment (Split Shipments)</h4><p>When platform supports <code>supports_multi_group: true</code>, business can split items into multiple packages:</p><pre><code class=\"language-javascript\">// Platform declares multi-group support in profile\nconst platformProfile = {\n  capabilities: [{\n    name: 'dev.ucp.shopping.fulfillment',\n    version: '2026-01-11',\n    config: {\n      supports_multi_group: true\n    }\n  }]\n};\n\n// Business returns split packages from different warehouses\nconst checkout = {\n  fulfillment: {\n    methods: [{\n      id: 'method_1',\n      type: 'shipping',\n      line_item_ids: ['shirt', 'pants'],\n      selected_destination_id: 'dest_1',\n      destinations: [{...}],\n      \n      // Two separate packages\n      groups: [\n        {\n          id: 'package_1',\n          line_item_ids: ['shirt'],  // Ships from Warehouse A\n          selected_option_id: 'standard',\n          options: [\n            {\n              id: 'standard',\n              title: 'Standard',\n              description: 'Ships from TX, arrives Dec 12-15',\n              totals: [{type: 'total', amount: 500}]\n            },\n            {\n              id: 'express',\n              title: 'Express',\n              description: 'Ships from TX, arrives Dec 10-11',\n              totals: [{type: 'total', amount: 1000}]\n            }\n          ]\n        },\n        {\n          id: 'package_2',\n          line_item_ids: ['pants'],  // Ships from Warehouse B\n          selected_option_id: 'express',\n          options: [\n            {\n              id: 'standard',\n              title: 'Standard',\n              description: 'Ships from CA, arrives Dec 14-17',\n              totals: [{type: 'total', amount: 600}]\n            },\n            {\n              id: 'express',\n              title: 'Express',\n              description: 'Ships from CA, arrives Dec 11-12',\n              totals: [{type: 'total', amount: 1200}]\n            }\n          ]\n        }\n      ]\n    }]\n  }\n};\n\n// Buyer can select different shipping speed per package\nfunction selectShippingPerPackage(method) {\n  return {\n    ...method,\n    groups: method.groups.map(group => ({\n      ...group,\n      // User selects standard for package 1, express for package 2\n      selected_option_id: group.id === 'package_1' ? 'standard' : 'express'\n    }))\n  };\n}\n\nconst updated = selectShippingPerPackage(checkout.fulfillment.methods[0]);\n\n// Total shipping: $5 (package 1 standard) + $12 (package 2 express) = $17\n</code></pre><h4>Multi-Destination Example (Split Shipping)</h4><p>When business supports <code>allows_multi_destination.shipping: true</code>, items can ship to different addresses:</p><pre><code class=\"language-javascript\">// Business declares multi-destination support in profile\nconst businessProfile = {\n  capabilities: [{\n    name: 'dev.ucp.shopping.fulfillment',\n    version: '2026-01-11',\n    config: {\n      allows_multi_destination: {\n        shipping: true\n      }\n    }\n  }]\n};\n\n// Platform creates checkout with items for two recipients\nconst checkout = {\n  line_items: [\n    { id: 'shirt', sku: 'SHIRT-001', quantity: 1 },  // Gift for Mom\n    { id: 'pants', sku: 'PANTS-001', quantity: 1 }   // Gift for Grandma\n  ],\n  fulfillment: {\n    methods: [\n      {\n        id: 'method_1',\n        type: 'shipping',\n        line_item_ids: ['shirt'],\n        selected_destination_id: 'dest_mom',\n        destinations: [\n          {\n            id: 'dest_mom',\n            street_address: '123 Mom St',\n            address_locality: 'Austin',\n            address_region: 'TX',\n            postal_code: '78701',\n            address_country: 'US'\n          }\n        ],\n        groups: [{\n          id: 'package_1',\n          line_item_ids: ['shirt'],\n          selected_option_id: 'standard',\n          options: [\n            {id: 'standard', title: 'Standard', totals: [{type: 'total', amount: 500}]},\n            {id: 'express', title: 'Express', totals: [{type: 'total', amount: 1000}]}\n          ]\n        }]\n      },\n      {\n        id: 'method_2',\n        type: 'shipping',\n        line_item_ids: ['pants'],\n        selected_destination_id: 'dest_grandma',\n        destinations: [\n          {\n            id: 'dest_grandma',\n            street_address: '88 Queensway',\n            address_locality: 'Hong Kong',\n            address_country: 'HK'\n          }\n        ],\n        groups: [{\n          id: 'package_2',\n          line_item_ids: ['pants'],\n          selected_option_id: 'standard',\n          options: [\n            {id: 'standard', title: 'International Standard', totals: [{type: 'total', amount: 2500}]},\n            {id: 'express', title: 'International Express', totals: [{type: 'total', amount: 4500}]}\n          ]\n        }]\n      }\n    ]\n  }\n};\n\n// Two separate shipments, each with own destination\nconsole.log('Shirt ships to:', checkout.fulfillment.methods[0].destinations[0].address_locality);\n// => \"Austin\"\nconsole.log('Pants ship to:', checkout.fulfillment.methods[1].destinations[0].address_locality);\n// => \"Hong Kong\"\n</code></pre><h4>Rendering Fulfillment Options</h4><p>Platforms render options using provided human-readable fields:</p><pre><code class=\"language-javascript\">function renderFulfillmentOptions(group) {\n  return group.options.map(option => {\n    const price = option.totals.find(t => t.type === 'total').amount;\n    \n    return {\n      id: option.id,\n      selected: option.id === group.selected_option_id,\n      // Use business-provided strings directly\n      title: option.title,\n      description: option.description,\n      price: `$${(price / 100).toFixed(2)}`,\n      // Platform displays verbatim - no interpretation needed\n      displayText: `${option.title} - $${(price / 100).toFixed(2)}`,\n      displaySubtext: option.description\n    };\n  });\n}\n\n// Example output for UI:\n// ○ Standard Shipping - $5.00\n//   Arrives Dec 12-15 via USPS\n// ● Express Shipping - $10.00  ← selected\n//   Arrives Dec 10-11 via FedEx\n</code></pre><h4>Common Pitfalls</h4><ul><li><strong>Mixing up groups and options:</strong> Groups are packages, options are choices per package (Standard vs Express)</li><li><strong>Not checking supports_multi_group:</strong> If platform doesn't support it, business consolidates into single group per method</li><li><strong>Assuming method types:</strong> Use <code>title</code> and <code>description</code> for rendering, not hardcoded type-specific UI</li><li><strong>Forgetting selected_option_id:</strong> Must specify which option is selected when updating</li><li><strong>Not preserving full structure:</strong> Update operations require full replacement - send entire fulfillment object back</li><li><strong>Ignoring available_methods:</strong> Check this array for alternative fulfillment options (e.g., pickup alternatives)</li></ul>",
          "resources": [
            { "type": "spec", "url": "https://ucp.dev/specification/fulfillment/", "label": "Fulfillment Extension Specification" },
            { "type": "schema", "url": "https://ucp.dev/schemas/shopping/fulfillment.json", "label": "Fulfillment Schema" }
          ]
        },
        {
          "id": "order-schema",
          "label": "Order Schema",
          "description": "Post-purchase order tracking",
          "content": "<h3>Order Lifecycle</h3><p>After checkout completes, the order object tracks post-purchase events. Orders are immutable records with append-only event logs for fulfillment and adjustments.</p><h4>Order Structure</h4><pre><code class=\"language-json\">{\n  \"ucp\": {\n    \"version\": \"2026-01-11\",\n    \"capabilities\": [{\"name\": \"dev.ucp.shopping.order\", \"version\": \"2026-01-11\"}]\n  },\n  \"id\": \"order_abc123\",\n  \"checkout_id\": \"checkout_xyz789\",\n  \"permalink_url\": \"https://business.com/orders/abc123\",\n  \"line_items\": [\n    {\n      \"id\": \"li_shoes\",\n      \"item\": {\"id\": \"prod_shoes\", \"title\": \"Running Shoes\", \"price\": 3000},\n      \"quantity\": {\"total\": 3, \"fulfilled\": 2},\n      \"status\": \"partial\"\n    }\n  ],\n  \"fulfillment\": {\n    \"expectations\": [{...}],  // Current buyer-facing promises\n    \"events\": [{...}]         // Append-only log of what happened\n  },\n  \"adjustments\": [{...}],     // Refunds, returns, etc.\n  \"totals\": [{\"type\": \"total\", \"amount\": 15342}]\n}\n</code></pre><h4>Webhook Configuration</h4><p>Platform provides webhook URL in capability config during negotiation:</p><pre><code class=\"language-javascript\">// Platform's UCP profile declares order capability with webhook endpoint\nconst platformProfile = {\n  capabilities: [\n    {\n      name: 'dev.ucp.shopping.order',\n      version: '2026-01-11',\n      config: {\n        webhook_url: 'https://platform.example.com/webhooks/ucp/orders'\n      }\n    }\n  ],\n  signing_keys: [\n    {\n      kty: 'RSA',\n      kid: 'platform-2026-01',\n      use: 'sig',\n      n: '0vx7agoebG...',\n      e: 'AQAB'\n    }\n  ]\n};\n\n// Business discovers webhook URL from platform profile\nconst orderConfig = platformProfile.capabilities.find(\n  c => c.name === 'dev.ucp.shopping.order'\n).config;\n\nconst webhookUrl = orderConfig.webhook_url;\nconsole.log('Send order events to:', webhookUrl);\n// => https://platform.example.com/webhooks/ucp/orders\n</code></pre><h4>Sending Order Event Webhooks</h4><p>Business sends order lifecycle events to platform's webhook URL with signature:</p><pre><code class=\"language-javascript\">const jose = require('jose');  // JWT library\n\n/**\n * Send order event webhook with JWT signature\n */\nasync function sendOrderEventWebhook(platformWebhookUrl, orderEvent, signingKey) {\n  // Step 1: Prepare order event payload\n  const payload = JSON.stringify({\n    ucp: {\n      version: '2026-01-11',\n      capabilities: [\n        {name: 'dev.ucp.shopping.order', version: '2026-01-11'}\n      ]\n    },\n    event_type: 'order.updated',\n    occurred_at: new Date().toISOString(),\n    order: orderEvent  // Full order object\n  });\n\n  // Step 2: Create detached JWT signature (RFC 7797)\n  // The signature covers the entire request body\n  const privateKey = await jose.importJWK(signingKey, 'RS256');\n  \n  const jwt = await new jose.CompactSign(\n    new TextEncoder().encode(payload)\n  )\n    .setProtectedHeader({\n      alg: 'RS256',\n      kid: signingKey.kid,  // Key ID for verification\n      b64: false,           // Detached payload (RFC 7797)\n      crit: ['b64']\n    })\n    .sign(privateKey);\n\n  // Step 3: POST to platform webhook with signature header\n  const response = await fetch(platformWebhookUrl, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'Request-Signature': jwt,  // Detached JWT signature\n      'X-Business-Id': 'business_12345'  // Business identifier\n    },\n    body: payload\n  });\n\n  if (!response.ok) {\n    throw new Error(`Webhook delivery failed: ${response.status}`);\n  }\n\n  return response;\n}\n\n// Example: Send order shipped event\nconst orderEvent = {\n  id: 'order_abc123',\n  checkout_id: 'checkout_xyz789',\n  permalink_url: 'https://business.com/orders/abc123',\n  line_items: [...],\n  fulfillment: {\n    expectations: [...],\n    events: [\n      {\n        id: 'evt_1',\n        occurred_at: '2025-01-08T10:30:00Z',\n        type: 'shipped',\n        line_items: [{id: 'li_shoes', quantity: 3}],\n        tracking_number: '123456789',\n        tracking_url: 'https://fedex.com/track/123456789',\n        description: 'Shipped via FedEx'\n      }\n    ]\n  },\n  totals: [...]\n};\n\nconst businessSigningKey = {\n  kty: 'RSA',\n  kid: 'business-2026-01',\n  use: 'sig',\n  d: 'private_key_data...',  // Private key\n  n: '0vx7agoebG...',\n  e: 'AQAB'\n};\n\nawait sendOrderEventWebhook(\n  'https://platform.example.com/webhooks/ucp/orders',\n  orderEvent,\n  businessSigningKey\n);\n</code></pre><h4>Verifying Webhook Signatures (Platform)</h4><p>Platform verifies webhook authenticity using business's public key:</p><pre><code class=\"language-javascript\">const jose = require('jose');\n\n/**\n * Verify webhook signature and extract order event\n */\nasync function verifyOrderWebhook(request) {\n  // Step 1: Extract signature header\n  const signature = request.headers['request-signature'];\n  if (!signature) {\n    throw new Error('Missing Request-Signature header');\n  }\n\n  // Step 2: Parse JWT header to get key ID\n  const jwtParts = signature.split('.');\n  const header = JSON.parse(\n    Buffer.from(jwtParts[0], 'base64').toString('utf8')\n  );\n  const kid = header.kid;\n\n  if (!kid) {\n    throw new Error('Missing kid in JWT header');\n  }\n\n  // Step 3: Fetch business's UCP profile (cache this!)\n  const businessId = request.headers['x-business-id'];\n  const profile = await fetchBusinessProfile(businessId);\n  \n  // Step 4: Find matching signing key\n  const publicKey = profile.signing_keys.find(k => k.kid === kid);\n  if (!publicKey) {\n    throw new Error(`Unknown signing key: ${kid}`);\n  }\n\n  // Step 5: Verify JWT signature against request body\n  const requestBody = await request.text();\n  \n  try {\n    const jwk = await jose.importJWK(publicKey, 'RS256');\n    \n    // Verify detached signature (RFC 7797)\n    const verified = await jose.compactVerify(\n      signature,\n      jwk,\n      {\n        detached: Buffer.from(requestBody)\n      }\n    );\n    \n    console.log('✅ Signature verified');\n    \n    // Step 6: Parse and return order event\n    return JSON.parse(requestBody);\n    \n  } catch (error) {\n    console.error('❌ Signature verification failed:', error);\n    throw new Error('Invalid webhook signature');\n  }\n}\n\n// Express.js webhook endpoint\napp.post('/webhooks/ucp/orders', async (req, res) => {\n  try {\n    // Verify signature and extract order\n    const orderEvent = await verifyOrderWebhook(req);\n    \n    // Respond quickly (2xx) - process asynchronously\n    res.status(200).json({received: true});\n    \n    // Process order event asynchronously\n    processOrderEventAsync(orderEvent).catch(err => {\n      console.error('Error processing order event:', err);\n    });\n    \n  } catch (error) {\n    console.error('Webhook verification failed:', error);\n    res.status(401).json({error: 'Signature verification failed'});\n  }\n});\n\n// Async processing after webhook response\nasync function processOrderEventAsync(orderEvent) {\n  const order = orderEvent.order;\n  \n  // Update local database\n  await db.orders.update(order.id, {\n    status: order.line_items[0].status,\n    fulfillment_events: order.fulfillment.events,\n    updated_at: orderEvent.occurred_at\n  });\n  \n  // Notify buyer\n  if (orderEvent.event_type === 'order.updated') {\n    const latestEvent = order.fulfillment.events[order.fulfillment.events.length - 1];\n    \n    if (latestEvent.type === 'shipped') {\n      await sendEmail(order.buyer.email, {\n        subject: 'Your order has shipped!',\n        body: `Tracking: ${latestEvent.tracking_url}`\n      });\n    }\n  }\n  \n  console.log(`Processed order event: ${order.id}`);\n}\n</code></pre><h4>Common Order Event Types</h4><pre><code class=\"language-javascript\">// Fulfillment events (append-only log)\nconst fulfillmentEvents = [\n  {\n    type: 'processing',\n    description: 'Order received, preparing for shipment'\n  },\n  {\n    type: 'shipped',\n    tracking_number: '123456789',\n    tracking_url: 'https://fedex.com/track/123456789',\n    description: 'Shipped via FedEx'\n  },\n  {\n    type: 'in_transit',\n    description: 'Package in transit to destination'\n  },\n  {\n    type: 'delivered',\n    description: 'Delivered to front door'\n  },\n  {\n    type: 'failed_attempt',\n    description: 'Delivery attempted, recipient not available'\n  }\n];\n\n// Adjustment events (refunds, returns, etc.)\nconst adjustments = [\n  {\n    type: 'refund',\n    status: 'completed',\n    amount: 3000,\n    line_items: [{id: 'li_shoes', quantity: 1}],\n    description: 'Defective item refund'\n  },\n  {\n    type: 'return',\n    status: 'pending',\n    line_items: [{id: 'li_shoes', quantity: 1}],\n    description: 'Return initiated by buyer'\n  },\n  {\n    type: 'cancellation',\n    status: 'completed',\n    amount: 15342,\n    description: 'Order cancelled before shipment'\n  }\n];\n</code></pre><h4>Key Rotation Example</h4><pre><code class=\"language-javascript\">// Business publishes multiple keys in profile for zero-downtime rotation\nconst businessProfile = {\n  signing_keys: [\n    {\n      kty: 'RSA',\n      kid: 'business-2026-01',  // Current key\n      use: 'sig',\n      n: 'current_key_n...',\n      e: 'AQAB'\n    },\n    {\n      kty: 'RSA',\n      kid: 'business-2025-12',  // Old key (still valid for in-flight webhooks)\n      use: 'sig',\n      n: 'old_key_n...',\n      e: 'AQAB'\n    }\n  ]\n};\n\n// Rotation process:\n// 1. Add new key to signing_keys array\n// 2. Start signing new webhooks with new key (kid: 'business-2026-01')\n// 3. Wait for all in-flight webhooks with old key to be delivered (~24 hours)\n// 4. Remove old key from signing_keys array\n</code></pre><h4>Common Pitfalls</h4><ul><li><strong>Not verifying signatures:</strong> MUST verify Request-Signature header to prevent spoofed webhooks</li><li><strong>Slow webhook response:</strong> Respond with 2xx immediately, process asynchronously after</li><li><strong>Missing kid in JWT:</strong> Always include kid (key ID) in JWT header for key lookup</li><li><strong>Not caching business profiles:</strong> Cache profile and signing keys to avoid fetching on every webhook</li><li><strong>Forgetting detached signature:</strong> Use RFC 7797 detached JWT (b64: false, crit: ['b64'])</li><li><strong>Hardcoding webhook URLs:</strong> Always read webhook_url from platform's capability config</li><li><strong>Not handling retries:</strong> Business should retry failed webhooks with exponential backoff</li></ul>",
          "resources": [
            { "type": "spec", "url": "https://ucp.dev/specification/order/", "label": "Order Specification" },
            { "type": "spec", "url": "https://ucp.dev/specification/order/#webhook-signature-verification", "label": "Webhook Signature Verification" },
            { "type": "schema", "url": "https://ucp.dev/schemas/shopping/order.json", "label": "Order Schema" }
          ]
        }
      ]
    },
    {
      "id": "transports",
      "label": "4. Transport Protocols",
      "description": "REST, MCP, A2A, Embedded",
      "content": "<h3>Multiple Transport Options</h3><p>UCP is transport-agnostic. The same capabilities can be exposed via different protocols.</p>",
      "children": [
        {
          "id": "rest-api",
          "label": "REST API",
          "description": "Traditional HTTP endpoints",
          "content": "<h3>REST Transport Overview</h3><p>Standard HTTPS API with JSON request/response. Traditional approach for web/mobile apps requiring direct HTTP control over checkout operations.</p><h4>REST Endpoint Discovery</h4><pre><code class=\"language-javascript\">// 1. Fetch business UCP profile for service discovery\nconst profileRes = await fetch('https://shop.example.com/.well-known/ucp');\nconst profile = await profileRes.json();\n\n// 2. Extract REST endpoint from services\nconst restEndpoint = profile.services['dev.ucp.shopping'].rest.endpoint;\n// => \"https://shop.example.com/ucp/v1\"\n</code></pre><h4>Complete REST Checkout Flow</h4><pre><code class=\"language-javascript\">/**\n * Complete checkout workflow using UCP REST API\n * Demonstrates: create → update buyer → update fulfillment → complete\n */\nasync function completeCheckoutViaREST() {\n  const baseUrl = 'https://shop.example.com/ucp/v1';\n  const headers = {\n    'Content-Type': 'application/json',\n    // Platform profile required for capability negotiation\n    'UCP-Agent': 'profile=\"https://platform.example/profile\"'\n  };\n\n  try {\n    // STEP 1: CREATE checkout session\n    const createRes = await fetch(`${baseUrl}/checkout-sessions`, {\n      method: 'POST',\n      headers,\n      body: JSON.stringify({\n        line_items: [\n          {\n            id: 'li_1',\n            item: {\n              id: 'item_123',\n              title: 'Red T-Shirt',\n              price: 2500  // Amount in cents\n            },\n            quantity: 2\n          }\n        ]\n      })\n    });\n\n    if (!createRes.ok) {\n      throw new Error(`Create failed: ${createRes.status}`);\n    }\n\n    const checkout = await createRes.json();\n    console.log('Checkout created:', checkout.id);\n    console.log('Status:', checkout.status);  // \"incomplete\"\n    console.log('Messages:', checkout.messages);  // Validation errors\n\n    // STEP 2: UPDATE with buyer information\n    const updateBuyerRes = await fetch(\n      `${baseUrl}/checkout-sessions/${checkout.id}`,\n      {\n        method: 'PUT',\n        headers,\n        body: JSON.stringify({\n          id: checkout.id,\n          buyer: {\n            email: 'jane@example.com',\n            first_name: 'Jane',\n            last_name: 'Doe'\n          },\n          line_items: checkout.line_items  // Must include all fields\n        })\n      }\n    );\n\n    const checkoutWithBuyer = await updateBuyerRes.json();\n    console.log('Buyer added');\n\n    // STEP 3: UPDATE with fulfillment address\n    const updateFulfillmentRes = await fetch(\n      `${baseUrl}/checkout-sessions/${checkout.id}`,\n      {\n        method: 'PUT',\n        headers,\n        body: JSON.stringify({\n          id: checkout.id,\n          buyer: checkoutWithBuyer.buyer,\n          line_items: checkoutWithBuyer.line_items,\n          fulfillment: {\n            methods: [\n              {\n                type: 'shipping',\n                destinations: [\n                  {\n                    street_address: '123 Main St',\n                    address_locality: 'Springfield',\n                    address_region: 'IL',\n                    postal_code: '62701',\n                    address_country: 'US'\n                  }\n                ]\n              }\n            ]\n          }\n        })\n      }\n    );\n\n    const checkoutWithFulfillment = await updateFulfillmentRes.json();\n    console.log('Fulfillment options:', checkoutWithFulfillment.fulfillment);\n\n    // STEP 4: SELECT shipping option\n    const shippingMethod = checkoutWithFulfillment.fulfillment.methods[0];\n    const selectShippingRes = await fetch(\n      `${baseUrl}/checkout-sessions/${checkout.id}`,\n      {\n        method: 'PUT',\n        headers,\n        body: JSON.stringify({\n          id: checkout.id,\n          buyer: checkoutWithFulfillment.buyer,\n          line_items: checkoutWithFulfillment.line_items,\n          fulfillment: {\n            methods: [\n              {\n                id: shippingMethod.id,\n                groups: [\n                  {\n                    id: shippingMethod.groups[0].id,\n                    selected_option_id: 'express'  // Choose express shipping\n                  }\n                ]\n              }\n            ]\n          }\n        })\n      }\n    );\n\n    const readyCheckout = await selectShippingRes.json();\n    console.log('Status:', readyCheckout.status);  // \"ready_for_complete\"\n\n    // STEP 5: COMPLETE checkout with payment\n    const completeRes = await fetch(\n      `${baseUrl}/checkout-sessions/${checkout.id}/complete`,\n      {\n        method: 'POST',\n        headers: {\n          ...headers,\n          'Idempotency-Key': crypto.randomUUID()  // Prevent duplicate orders\n        },\n        body: JSON.stringify({\n          payment_data: {\n            id: 'pi_gpay_5678',\n            handler_id: 'com.google.pay',\n            type: 'card',\n            brand: 'mastercard',\n            last_digits: '5678',\n            credential: {\n              type: 'PAYMENT_GATEWAY',\n              token: 'examplePaymentMethodToken'\n            },\n            billing_address: {\n              street_address: '123 Main St',\n              address_locality: 'Springfield',\n              address_region: 'IL',\n              postal_code: '62701',\n              address_country: 'US'\n            }\n          }\n        })\n      }\n    );\n\n    const completedCheckout = await completeRes.json();\n    console.log('Order placed!');\n    console.log('Order ID:', completedCheckout.order.id);\n    console.log('Order URL:', completedCheckout.order.permalink_url);\n\n    return completedCheckout;\n\n  } catch (error) {\n    console.error('Checkout failed:', error);\n    throw error;\n  }\n}\n</code></pre><h4>Common Pitfalls</h4><ul><li><strong>Missing UCP-Agent header:</strong> REST requires platform profile in UCP-Agent header for capability negotiation. Without it, businesses cannot validate compatibility.</li><li><strong>PUT replaces entire state:</strong> Update operations use PUT semantics. You must include ALL previously set fields you want to retain, not just the changes.</li><li><strong>Status codes matter:</strong> Check HTTP status codes. 201 for create, 200 for update/complete, 400 for validation errors, 409 for conflicts.</li><li><strong>Idempotency-Key required for mutations:</strong> Always include Idempotency-Key header on create/complete operations to prevent duplicate orders if requests are retried.</li><li><strong>TLS 1.3+ required:</strong> All REST endpoints must use HTTPS with minimum TLS 1.3 for security compliance.</li></ul>",
          "resources": [
            { "type": "spec", "url": "https://ucp.dev/specification/checkout-rest/", "label": "REST Specification" }
          ]
        },
        {
          "id": "mcp-protocol",
          "label": "MCP (Model Context Protocol)",
          "description": "For AI agents and LLMs",
          "content": "<h3>MCP Transport Overview</h3><p>Model Context Protocol (MCP) exposes UCP capabilities as tools that AI agents and LLMs can invoke directly. Uses JSON-RPC 2.0 over HTTP with streaming support for real-time agent interactions.</p><p><strong>When to use:</strong> AI shopping assistants, conversational commerce, autonomous purchasing agents that need structured tool calling.</p><h4>MCP Endpoint Discovery</h4><pre><code class=\"language-javascript\">// Discover MCP endpoint from business profile\nconst profileRes = await fetch('https://shop.example.com/.well-known/ucp');\nconst profile = await profileRes.json();\n\nconst mcpEndpoint = profile.services['dev.ucp.shopping'].mcp.endpoint;\n// => \"https://shop.example.com/ucp/mcp\"\n\nconst mcpSchema = profile.services['dev.ucp.shopping'].mcp.schema;\n// => \"https://ucp.dev/services/shopping/mcp.openrpc.json\"\n</code></pre><h4>Complete MCP Checkout Flow</h4><pre><code class=\"language-javascript\">/**\n * AI Agent checkout using MCP tools\n * Demonstrates: create_checkout → update_checkout → complete_checkout\n */\nclass UCPShoppingAgent {\n  constructor(mcpEndpoint, platformProfile) {\n    this.endpoint = mcpEndpoint;\n    this.profile = platformProfile;\n    this.requestId = 1;\n  }\n\n  async callTool(method, params) {\n    const response = await fetch(this.endpoint, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        jsonrpc: '2.0',\n        id: this.requestId++,\n        method,\n        params: {\n          _meta: {\n            ucp: {\n              profile: this.profile  // Platform profile for negotiation\n            }\n          },\n          ...params\n        }\n      })\n    });\n\n    const result = await response.json();\n    if (result.error) {\n      throw new Error(`Tool error: ${result.error.message}`);\n    }\n    return result.result;\n  }\n\n  async completeCheckout(userRequest) {\n    try {\n      // STEP 1: CREATE checkout with initial items\n      console.log('Agent: Creating checkout...');\n      const createResult = await this.callTool('create_checkout', {\n        idempotency_key: crypto.randomUUID(),\n        buyer: {\n          email: userRequest.email,\n          first_name: userRequest.firstName,\n          last_name: userRequest.lastName\n        },\n        line_items: [\n          {\n            item: { id: userRequest.productId },\n            quantity: userRequest.quantity\n          }\n        ],\n        currency: 'USD'\n      });\n\n      const checkoutId = createResult.id;\n      console.log(`Agent: Checkout created (${checkoutId})`);\n      console.log(`Status: ${createResult.status}`);\n\n      // Check for errors that need resolution\n      if (createResult.messages?.length > 0) {\n        console.log('Agent: Validation messages:', createResult.messages);\n      }\n\n      // STEP 2: UPDATE with fulfillment details\n      console.log('Agent: Adding shipping address...');\n      const updateResult = await this.callTool('update_checkout', {\n        id: checkoutId,\n        buyer: createResult.buyer,\n        line_items: createResult.line_items,\n        fulfillment: {\n          methods: [\n            {\n              type: 'shipping',\n              destinations: [\n                {\n                  street_address: userRequest.address.street,\n                  address_locality: userRequest.address.city,\n                  address_region: userRequest.address.state,\n                  postal_code: userRequest.address.zip,\n                  address_country: 'US'\n                }\n              ]\n            }\n          ]\n        }\n      });\n\n      // STEP 3: Select shipping option\n      const shippingOptions = updateResult.fulfillment?.methods[0]?.groups[0]?.options;\n      if (shippingOptions && shippingOptions.length > 0) {\n        console.log('Agent: Available shipping options:');\n        shippingOptions.forEach(opt => {\n          console.log(`  - ${opt.title}: $${opt.totals[0].amount / 100}`);\n        });\n\n        // Choose standard shipping (agent decision logic)\n        const selectedOption = shippingOptions.find(o => o.id === 'standard');\n        console.log(`Agent: Selecting ${selectedOption.title}`);\n\n        const selectResult = await this.callTool('update_checkout', {\n          id: checkoutId,\n          buyer: updateResult.buyer,\n          line_items: updateResult.line_items,\n          fulfillment: {\n            methods: [\n              {\n                id: updateResult.fulfillment.methods[0].id,\n                groups: [\n                  {\n                    id: updateResult.fulfillment.methods[0].groups[0].id,\n                    selected_option_id: 'standard'\n                  }\n                ]\n              }\n            ]\n          }\n        });\n\n        console.log(`Agent: Checkout ready - Total: $${selectResult.totals.find(t => t.type === 'total').amount / 100}`);\n\n        // STEP 4: COMPLETE checkout\n        console.log('Agent: Completing checkout...');\n        const completeResult = await this.callTool('complete_checkout', {\n          id: checkoutId,\n          idempotency_key: crypto.randomUUID(),\n          payment_data: {\n            id: userRequest.paymentInstrumentId,\n            handler_id: 'com.google.pay',\n            type: 'card',\n            credential: userRequest.paymentCredential\n          }\n        });\n\n        console.log('Agent: Order completed!');\n        console.log(`Order ID: ${completeResult.order.id}`);\n        console.log(`Order URL: ${completeResult.order.permalink_url}`);\n\n        return completeResult;\n      }\n\n    } catch (error) {\n      console.error('Agent: Checkout failed:', error);\n      throw error;\n    }\n  }\n}\n\n// Usage example\nconst agent = new UCPShoppingAgent(\n  'https://shop.example.com/ucp/mcp',\n  'https://platform.example/profiles/v2026-01/shopping-agent.json'\n);\n\nconst order = await agent.completeCheckout({\n  email: 'jane@example.com',\n  firstName: 'Jane',\n  lastName: 'Doe',\n  productId: 'item_123',\n  quantity: 1,\n  address: {\n    street: '123 Main St',\n    city: 'Springfield',\n    state: 'IL',\n    zip: '62701'\n  },\n  paymentInstrumentId: 'pi_saved_card_123',\n  paymentCredential: { type: 'PAYMENT_GATEWAY', token: 'tok_...' }\n});\n</code></pre><h4>MCP Tool Identifier Pattern</h4><p>MCP uses a consistent naming pattern for tools. In requests, the <code>id</code> parameter identifies the resource, and is separate from the payload:</p><pre><code class=\"language-javascript\">// For update_checkout, id is a top-level param\n{\n  \"jsonrpc\": \"2.0\",\n  \"method\": \"update_checkout\",\n  \"params\": {\n    \"_meta\": { \"ucp\": { \"profile\": \"https://...\" } },\n    \"id\": \"checkout_abc123\",  // Resource identifier\n    \"buyer\": { ... },          // Payload (no id field here)\n    \"line_items\": [ ... ]\n  }\n}\n\n// Response includes id in the checkout object\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 2,\n  \"result\": {\n    \"id\": \"checkout_abc123\",  // In response payload\n    \"status\": \"incomplete\",\n    ...\n  }\n}\n</code></pre><h4>Common Pitfalls</h4><ul><li><strong>Missing _meta.ucp.profile:</strong> Every MCP tool call MUST include platform profile in params._meta.ucp.profile for capability negotiation.</li><li><strong>Forgetting idempotency_key:</strong> create_checkout and complete_checkout require idempotency_key to prevent duplicate operations.</li><li><strong>Resource ID confusion:</strong> For get/update/complete/cancel operations, the checkout id is a top-level param, not inside the checkout object.</li><li><strong>Error handling:</strong> Check result.error before accessing result.result. MCP errors follow JSON-RPC 2.0 format with UCP error details in error.data.</li><li><strong>State validation:</strong> Agent must check checkout.status and checkout.messages to determine if checkout is ready for completion.</li></ul>",
          "resources": [
            { "type": "spec", "url": "https://ucp.dev/specification/checkout-mcp/", "label": "MCP Specification" }
          ]
        },
        {
          "id": "a2a-protocol",
          "label": "A2A (Agent-to-Agent)",
          "description": "Direct agent communication",
          "content": "<h3>A2A Transport Overview</h3><p>Agent-to-Agent (A2A) protocol enables autonomous agents to discover services, negotiate capabilities, and execute transactions without human intervention. Built on MCP foundation but adds agent identity, trust negotiation, and autonomous decision-making.</p><p><strong>When to use:</strong> Fully autonomous commerce, supply chain automation, B2B agent integrations, smart contracts requiring atomic transactions.</p><h4>A2A Discovery and Negotiation</h4><pre><code class=\"language-javascript\">/**\n * A2A agent discovers and validates business capabilities\n * before initiating transaction\n */\nclass A2AAgent {\n  constructor(agentProfile) {\n    this.profile = agentProfile;  // Agent's identity and capabilities\n    this.trustStore = new Map();  // Cached trust relationships\n  }\n\n  // Discover and validate business UCP capabilities\n  async discoverBusiness(businessUrl) {\n    // 1. Fetch UCP profile\n    const profileRes = await fetch(`${businessUrl}/.well-known/ucp`);\n    const profile = await profileRes.json();\n\n    // 2. Verify supported capabilities\n    const capabilities = profile.capabilities.map(c => c.name);\n    console.log('Business capabilities:', capabilities);\n\n    // 3. Check for A2A support (via MCP endpoint + agent auth)\n    if (!profile.services['dev.ucp.shopping']?.mcp) {\n      throw new Error('Business does not support agent protocols');\n    }\n\n    // 4. Validate version compatibility\n    const ucpVersion = profile.ucp.version;\n    if (!this.isVersionCompatible(ucpVersion)) {\n      throw new Error(`Incompatible UCP version: ${ucpVersion}`);\n    }\n\n    return {\n      endpoint: profile.services['dev.ucp.shopping'].mcp.endpoint,\n      capabilities,\n      version: ucpVersion\n    };\n  }\n\n  isVersionCompatible(version) {\n    // Agent's version compatibility logic\n    return version >= '2026-01-11';\n  }\n\n  // Establish trust with business agent\n  async negotiateTrust(businessEndpoint) {\n    // A2A uses mutual authentication\n    const trustReq = {\n      jsonrpc: '2.0',\n      id: 'trust_1',\n      method: 'a2a.handshake',\n      params: {\n        agent: {\n          id: this.profile.id,\n          name: this.profile.name,\n          profile: this.profile.url,\n          public_key: this.profile.publicKey\n        },\n        requested_capabilities: ['checkout', 'fulfillment']\n      }\n    };\n\n    const response = await fetch(businessEndpoint, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(trustReq)\n    });\n\n    const trustResult = await response.json();\n    if (trustResult.error) {\n      throw new Error(`Trust negotiation failed: ${trustResult.error.message}`);\n    }\n\n    // Cache trust token for subsequent calls\n    this.trustStore.set(businessEndpoint, trustResult.result.token);\n    return trustResult.result;\n  }\n}\n</code></pre><h4>Complete A2A Autonomous Transaction</h4><pre><code class=\"language-javascript\">/**\n * Fully autonomous agent-to-agent checkout\n * No human intervention from discovery to order placement\n */\nclass AutonomousPurchasingAgent extends A2AAgent {\n  async executePurchase(businessUrl, purchaseIntent) {\n    try {\n      // PHASE 1: DISCOVERY\n      console.log('[Agent] Discovering business capabilities...');\n      const business = await this.discoverBusiness(businessUrl);\n\n      // PHASE 2: TRUST NEGOTIATION\n      console.log('[Agent] Negotiating trust...');\n      const trust = await this.negotiateTrust(business.endpoint);\n      console.log('[Agent] Trust established');\n\n      // PHASE 3: AUTONOMOUS CHECKOUT\n      console.log('[Agent] Initiating autonomous checkout...');\n\n      // CREATE with agent context\n      const createResult = await this.agentCall(business.endpoint, 'create_checkout', {\n        _meta: {\n          ucp: { profile: this.profile.url },\n          a2a: {\n            agent_id: this.profile.id,\n            trust_token: this.trustStore.get(business.endpoint),\n            intent: 'autonomous_purchase'  // Signals no human in the loop\n          }\n        },\n        idempotency_key: `${this.profile.id}_${Date.now()}`,\n        buyer: {\n          // Agent provides buyer details from purchaseIntent\n          email: purchaseIntent.buyer.email,\n          first_name: purchaseIntent.buyer.firstName,\n          last_name: purchaseIntent.buyer.lastName\n        },\n        line_items: purchaseIntent.items.map(item => ({\n          item: { id: item.productId },\n          quantity: item.quantity\n        })),\n        currency: purchaseIntent.currency || 'USD'\n      });\n\n      const checkoutId = createResult.id;\n\n      // Agent autonomous decision: evaluate and select fulfillment\n      const updateResult = await this.agentCall(business.endpoint, 'update_checkout', {\n        _meta: {\n          ucp: { profile: this.profile.url },\n          a2a: {\n            agent_id: this.profile.id,\n            trust_token: this.trustStore.get(business.endpoint)\n          }\n        },\n        id: checkoutId,\n        buyer: createResult.buyer,\n        line_items: createResult.line_items,\n        fulfillment: {\n          methods: [\n            {\n              type: 'shipping',\n              destinations: [purchaseIntent.shippingAddress]\n            }\n          ]\n        }\n      });\n\n      // Agent decision logic: select optimal shipping\n      const shippingOptions = updateResult.fulfillment.methods[0].groups[0].options;\n      const optimalShipping = this.selectOptimalShipping(\n        shippingOptions,\n        purchaseIntent.preferences\n      );\n\n      console.log(`[Agent] Selected shipping: ${optimalShipping.title}`);\n\n      await this.agentCall(business.endpoint, 'update_checkout', {\n        _meta: {\n          ucp: { profile: this.profile.url },\n          a2a: {\n            agent_id: this.profile.id,\n            trust_token: this.trustStore.get(business.endpoint)\n          }\n        },\n        id: checkoutId,\n        buyer: updateResult.buyer,\n        line_items: updateResult.line_items,\n        fulfillment: {\n          methods: [\n            {\n              id: updateResult.fulfillment.methods[0].id,\n              groups: [\n                {\n                  id: updateResult.fulfillment.methods[0].groups[0].id,\n                  selected_option_id: optimalShipping.id\n                }\n              ]\n            }\n          ]\n        }\n      });\n\n      // COMPLETE with agent-managed payment\n      console.log('[Agent] Completing autonomous purchase...');\n      const completeResult = await this.agentCall(business.endpoint, 'complete_checkout', {\n        _meta: {\n          ucp: { profile: this.profile.url },\n          a2a: {\n            agent_id: this.profile.id,\n            trust_token: this.trustStore.get(business.endpoint),\n            autonomous_completion: true\n          }\n        },\n        id: checkoutId,\n        idempotency_key: `${this.profile.id}_complete_${Date.now()}`,\n        payment_data: await this.getAgentPaymentCredential(purchaseIntent)\n      });\n\n      console.log('[Agent] Purchase completed autonomously');\n      console.log(`Order ID: ${completeResult.order.id}`);\n\n      // PHASE 4: POST-TRANSACTION\n      await this.recordTransaction({\n        business: businessUrl,\n        order: completeResult.order,\n        timestamp: new Date().toISOString(),\n        autonomous: true\n      });\n\n      return completeResult;\n\n    } catch (error) {\n      console.error('[Agent] Autonomous purchase failed:', error);\n      await this.recordFailure(businessUrl, error);\n      throw error;\n    }\n  }\n\n  async agentCall(endpoint, method, params) {\n    const response = await fetch(endpoint, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        jsonrpc: '2.0',\n        id: crypto.randomUUID(),\n        method,\n        params\n      })\n    });\n\n    const result = await response.json();\n    if (result.error) {\n      throw new Error(`Agent call failed: ${result.error.message}`);\n    }\n    return result.result;\n  }\n\n  selectOptimalShipping(options, preferences) {\n    // Agent decision logic based on cost vs speed\n    if (preferences.priority === 'cost') {\n      return options.reduce((min, opt) =>\n        opt.totals[0].amount < min.totals[0].amount ? opt : min\n      );\n    } else if (preferences.priority === 'speed') {\n      return options.find(o => o.id.includes('express')) || options[0];\n    }\n    return options[0];  // Default to first option\n  }\n\n  async getAgentPaymentCredential(intent) {\n    // Agent retrieves payment credential from secure vault\n    // Implementation depends on agent's payment provider integration\n    return intent.paymentCredential;\n  }\n\n  async recordTransaction(record) {\n    // Agent logs transaction to its internal ledger\n    console.log('[Agent] Transaction recorded:', record.order.id);\n  }\n\n  async recordFailure(business, error) {\n    // Agent logs failure for learning and retry logic\n    console.log('[Agent] Failure recorded:', error.message);\n  }\n}\n\n// Usage: Autonomous agent executing purchase\nconst agent = new AutonomousPurchasingAgent({\n  id: 'agent_supply_chain_bot_001',\n  name: 'Supply Chain Purchasing Agent',\n  url: 'https://company.example/agents/purchasing-bot',\n  publicKey: '-----BEGIN PUBLIC KEY-----\\n...'\n});\n\nawait agent.executePurchase('https://supplier.example.com', {\n  buyer: {\n    email: 'procurement@company.example',\n    firstName: 'Procurement',\n    lastName: 'Department'\n  },\n  items: [\n    { productId: 'raw_material_steel_001', quantity: 100 }\n  ],\n  shippingAddress: {\n    street_address: '500 Industrial Blvd',\n    address_locality: 'Detroit',\n    address_region: 'MI',\n    postal_code: '48201',\n    address_country: 'US'\n  },\n  preferences: {\n    priority: 'cost'  // Agent optimizes for cost over speed\n  },\n  paymentCredential: {\n    type: 'PAYMENT_GATEWAY',\n    token: 'corp_payment_token_...'\n  }\n});\n</code></pre><h4>Common Pitfalls</h4><ul><li><strong>Missing agent identity:</strong> A2A requires agent profile URL and identity in _meta.a2a for trust establishment.</li><li><strong>Trust token expiration:</strong> Agents must handle trust token refresh when tokens expire during long-running transactions.</li><li><strong>Autonomous vs delegated:</strong> Signal autonomous_completion: true in _meta.a2a to inform business no human confirmation is required.</li><li><strong>Version compatibility:</strong> Always check UCP version compatibility before initiating transactions to avoid runtime failures.</li><li><strong>Error recovery:</strong> Agents must implement retry logic with exponential backoff for transient failures, and record failures for learning.</li></ul>",
          "resources": [
            { "type": "spec", "url": "https://ucp.dev/specification/agent-protocols/", "label": "Agent Protocols Documentation" }
          ]
        },
        {
          "id": "embedded-protocol",
          "label": "Embedded Protocol (ECP)",
          "description": "PostMessage/JSON-RPC in iframes",
          "content": "<h3>Embedded Protocol Overview</h3><p>Embedded Checkout Protocol (ECP) enables hosts to embed a business's checkout UI in an iframe/webview and delegate specific actions (payment selection, address entry) to native host experiences. Uses postMessage with JSON-RPC 2.0.</p><p><strong>When to use:</strong> Super apps, browser extensions, AI assistants with native UI, white-label checkout integrations.</p><h4>ECP Initialization with Delegations</h4><pre><code class=\"language-javascript\">/**\n * Host initializes embedded checkout with payment delegation\n * Host will handle payment method selection and credential collection\n */\nclass EmbeddedCheckoutHost {\n  constructor(checkoutUrl) {\n    this.checkoutUrl = checkoutUrl;\n    this.iframe = null;\n    this.messageChannel = null;\n    this.pendingRequests = new Map();\n  }\n\n  // Initialize iframe with ECP parameters\n  async init(container) {\n    // Build URL with ECP parameters\n    const url = new URL(this.checkoutUrl);\n    url.searchParams.set('ec_version', '2026-01-11');\n\n    // Request delegations for native payment UI\n    url.searchParams.set(\n      'ec_delegate',\n      'payment.instruments_change,payment.credential,fulfillment.address_change'\n    );\n\n    // Optional: Add authentication if required\n    // url.searchParams.set('ec_auth', await this.getAuthToken());\n\n    // Create sandboxed iframe\n    this.iframe = document.createElement('iframe');\n    this.iframe.src = url.toString();\n    this.iframe.sandbox = 'allow-scripts allow-forms allow-same-origin';\n    this.iframe.credentialless = true;  // Privacy protection\n\n    // Set up message listener BEFORE appending iframe\n    window.addEventListener('message', this.handleMessage.bind(this));\n\n    container.appendChild(this.iframe);\n    console.log('[Host] Embedded checkout initialized');\n  }\n\n  handleMessage(event) {\n    // Validate origin\n    const checkoutOrigin = new URL(this.checkoutUrl).origin;\n    if (event.origin !== checkoutOrigin) {\n      console.warn('[Host] Ignoring message from untrusted origin:', event.origin);\n      return;\n    }\n\n    const message = event.data;\n    if (!message.jsonrpc || message.jsonrpc !== '2.0') {\n      return;  // Not a JSON-RPC message\n    }\n\n    console.log('[Host] Received:', message.method || 'response');\n\n    // Route message based on type\n    if (message.method) {\n      if (message.id) {\n        // Request - requires response\n        this.handleRequest(message);\n      } else {\n        // Notification - no response needed\n        this.handleNotification(message);\n      }\n    } else if (message.id) {\n      // Response to our request\n      this.handleResponse(message);\n    }\n  }\n\n  async handleRequest(message) {\n    const { method, params, id } = message;\n\n    try {\n      let result;\n\n      switch (method) {\n        case 'ec.ready':\n          result = await this.handleReady(params);\n          break;\n\n        case 'ec.payment.instruments_change_request':\n          result = await this.handlePaymentInstrumentsChange(params);\n          break;\n\n        case 'ec.payment.credential_request':\n          result = await this.handlePaymentCredential(params);\n          break;\n\n        case 'ec.fulfillment.address_change_request':\n          result = await this.handleAddressChange(params);\n          break;\n\n        default:\n          throw { code: 'not_supported_error', message: `Method ${method} not supported` };\n      }\n\n      // Send success response\n      this.sendResponse(id, result);\n\n    } catch (error) {\n      // Send error response\n      this.sendError(id, error);\n    }\n  }\n\n  async handleReady(params) {\n    console.log('[Host] Handshake received');\n    console.log('[Host] Accepted delegations:', params.delegate);\n\n    // Option 1: Upgrade to MessageChannel for better isolation\n    const channel = new MessageChannel();\n    this.messageChannel = channel.port1;\n    this.messageChannel.onmessage = (e) => this.handleMessage({ data: e.data, origin: this.checkoutUrl });\n\n    // Transfer port2 to iframe\n    this.iframe.contentWindow.postMessage(\n      {\n        jsonrpc: '2.0',\n        id: 'ready_upgrade',\n        result: {\n          upgrade: { port: channel.port2 }\n        }\n      },\n      new URL(this.checkoutUrl).origin,\n      [channel.port2]  // Transfer port\n    );\n\n    // Wait for second ec.ready on MessageChannel\n    return new Promise((resolve) => {\n      const handler = (e) => {\n        if (e.data.method === 'ec.ready') {\n          this.messageChannel.removeEventListener('message', handler);\n\n          // Provide saved payment instruments if delegation accepted\n          const result = {};\n          if (params.delegate.includes('payment.instruments_change')) {\n            result.checkout = {\n              payment: {\n                instruments: this.getSavedPaymentInstruments()\n              }\n            };\n          }\n\n          resolve(result);\n        }\n      };\n      this.messageChannel.addEventListener('message', handler);\n    });\n  }\n\n  async handlePaymentInstrumentsChange(params) {\n    console.log('[Host] Showing native payment picker...');\n\n    // Show native payment method selection UI\n    const selectedInstrument = await this.showNativePaymentPicker(\n      params.checkout.payment\n    );\n\n    if (!selectedInstrument) {\n      throw { code: 'abort_error', message: 'User cancelled payment selection' };\n    }\n\n    // Return updated payment state\n    return {\n      checkout: {\n        payment: {\n          selected_instrument_id: selectedInstrument.id,\n          instruments: [selectedInstrument]\n        }\n      }\n    };\n  }\n\n  async handlePaymentCredential(params) {\n    console.log('[Host] Requesting payment credential...');\n\n    const selectedInstrument = params.checkout.payment.instruments.find(\n      i => i.id === params.checkout.payment.selected_instrument_id\n    );\n\n    // Show native biometric/PIN authentication\n    const credential = await this.authenticateAndGetCredential(\n      selectedInstrument,\n      params.checkout.totals.find(t => t.type === 'total').amount\n    );\n\n    if (!credential) {\n      throw { code: 'abort_error', message: 'User cancelled authentication' };\n    }\n\n    // Return instrument with credential\n    return {\n      checkout: {\n        payment: {\n          instruments: [\n            {\n              ...selectedInstrument,\n              credential\n            }\n          ]\n        }\n      }\n    };\n  }\n\n  async handleAddressChange(params) {\n    console.log('[Host] Showing native address picker...');\n\n    const address = await this.showNativeAddressPicker();\n\n    if (!address) {\n      throw { code: 'abort_error', message: 'User cancelled address selection' };\n    }\n\n    return {\n      checkout: {\n        fulfillment: {\n          methods: [\n            {\n              id: params.checkout.fulfillment.methods[0].id,\n              type: 'shipping',\n              selected_destination_id: 'new_address',\n              destinations: [{ id: 'new_address', ...address }]\n            }\n          ]\n        }\n      }\n    };\n  }\n\n  handleNotification(message) {\n    const { method, params } = message;\n\n    switch (method) {\n      case 'ec.start':\n        console.log('[Host] Checkout started');\n        this.onCheckoutStart?.(params.checkout);\n        break;\n\n      case 'ec.complete':\n        console.log('[Host] Order completed!');\n        console.log('[Host] Order ID:', params.checkout.order.id);\n        this.onCheckoutComplete?.(params.checkout);\n        break;\n\n      case 'ec.line_items.change':\n        console.log('[Host] Line items updated');\n        this.onLineItemsChange?.(params.checkout);\n        break;\n\n      case 'ec.messages.change':\n        console.log('[Host] Messages:', params.checkout.messages);\n        this.onMessagesChange?.(params.checkout);\n        break;\n\n      default:\n        console.log('[Host] Unhandled notification:', method);\n    }\n  }\n\n  sendResponse(id, result) {\n    const message = {\n      jsonrpc: '2.0',\n      id,\n      result\n    };\n\n    if (this.messageChannel) {\n      this.messageChannel.postMessage(message);\n    } else {\n      this.iframe.contentWindow.postMessage(\n        message,\n        new URL(this.checkoutUrl).origin\n      );\n    }\n  }\n\n  sendError(id, error) {\n    const message = {\n      jsonrpc: '2.0',\n      id,\n      error: {\n        code: error.code || 'internal_error',\n        message: error.message || 'Internal error'\n      }\n    };\n\n    if (this.messageChannel) {\n      this.messageChannel.postMessage(message);\n    } else {\n      this.iframe.contentWindow.postMessage(\n        message,\n        new URL(this.checkoutUrl).origin\n      );\n    }\n  }\n\n  // Native UI methods (host-specific implementations)\n  getSavedPaymentInstruments() {\n    // Return user's saved payment methods\n    return [\n      {\n        id: 'card_123',\n        handler_id: 'host_payment_handler',\n        type: 'card',\n        brand: 'visa',\n        last_digits: '4242',\n        expiry_month: 12,\n        expiry_year: 2027,\n        summary: 'Visa •••• 4242'\n      }\n    ];\n  }\n\n  async showNativePaymentPicker(currentPayment) {\n    // Show native payment sheet\n    return new Promise((resolve) => {\n      // Implementation depends on host platform\n      // iOS: PKPaymentAuthorizationViewController\n      // Android: Google Pay API\n      // Web: Custom modal\n      resolve(this.getSavedPaymentInstruments()[0]);\n    });\n  }\n\n  async authenticateAndGetCredential(instrument, amount) {\n    // Show biometric prompt and return credential\n    return new Promise((resolve) => {\n      // Platform-specific authentication\n      // iOS: LocalAuthentication framework\n      // Android: BiometricPrompt API\n      // Web: WebAuthn\n      resolve({\n        type: 'PAYMENT_GATEWAY',\n        token: 'tok_authenticated_' + Date.now()\n      });\n    });\n  }\n\n  async showNativeAddressPicker() {\n    // Show native address picker\n    return {\n      street_address: '456 New St',\n      address_locality: 'San Francisco',\n      address_region: 'CA',\n      postal_code: '94102',\n      address_country: 'US'\n    };\n  }\n}\n\n// Usage\nconst host = new EmbeddedCheckoutHost(\n  'https://shop.example.com/checkout/abc123'\n);\n\n// Set up event handlers\nhost.onCheckoutComplete = (checkout) => {\n  console.log('Success! Order:', checkout.order.id);\n  // Navigate to order confirmation\n};\n\nhost.onMessagesChange = (checkout) => {\n  // Show validation errors in host UI\n  checkout.messages.forEach(msg => {\n    if (msg.severity === 'recoverable') {\n      console.warn(msg.content);\n    }\n  });\n};\n\n// Initialize in container\nawait host.init(document.getElementById('checkout-container'));\n</code></pre><h4>Common Pitfalls</h4><ul><li><strong>Origin validation missing:</strong> ALWAYS validate event.origin matches checkout URL before processing messages. Security critical.</li><li><strong>Responding to notifications:</strong> Notifications (no id field) must NOT receive responses. Only requests (with id) require responses.</li><li><strong>MessageChannel transfer:</strong> When upgrading to MessageChannel, must use transferable objects array in postMessage: postMessage(msg, origin, [port]).</li><li><strong>Delegation contract violation:</strong> Once delegation is accepted in ec.ready, host MUST respond to ALL delegation requests. Not responding breaks checkout flow.</li><li><strong>Sandbox restrictions:</strong> Embedded iframes should use restrictive sandbox attributes. Minimum: allow-scripts allow-forms allow-same-origin.</li><li><strong>Error codes:</strong> Use W3C DOMException names for errors: abort_error (user cancelled), not_supported_error (feature not available), security_error (origin mismatch).</li></ul>",
          "resources": [
            { "type": "spec", "url": "https://ucp.dev/specification/embedded-checkout/", "label": "Embedded Protocol Specification" }
          ]
        }
      ]
    },
    {
      "id": "security",
      "label": "5. Advanced Security Patterns",
      "description": "AP2, consent, tokenization",
      "content": "<h3>Security-First Design</h3><p>UCP implements multiple layers of security for payment and identity protection.</p>",
      "children": [
        {
          "id": "ap2-mandates",
          "label": "AP2 Mandates",
          "description": "Authentication Protocol 2",
          "content": "<h3>AP2 Mandates</h3><p>Authentication Protocol 2 (AP2) mandates enforce security requirements:</p><ul><li><strong>3DS Authentication</strong> - Strong customer authentication (SCA)</li><li><strong>Step-up Auth</strong> - Additional verification when needed</li><li><strong>Risk Checks</strong> - Fraud detection thresholds</li></ul><p>PSPs include AP2 mandates in checkout responses to request additional authentication.</p>",
          "resources": [
            { "type": "spec", "url": "https://ucp.dev/specification/ap2-mandates", "label": "AP2 Specification" }
          ]
        },
        {
          "id": "buyer-consent",
          "label": "Buyer Consent",
          "description": "Explicit user permissions",
          "content": "<h3>Consent Framework</h3><p>For agentic commerce, explicit buyer consent is required:</p><ul><li><strong>Consent Grant</strong> - User authorizes platform to transact</li><li><strong>Scope Limits</strong> - Budget caps, merchant allowlists</li><li><strong>Revocation</strong> - User can revoke consent anytime</li></ul><p>Prevents unauthorized purchases by AI agents.</p>",
          "resources": [
            { "type": "spec", "url": "https://ucp.dev/specification/buyer-consent", "label": "Consent Documentation" }
          ]
        },
        {
          "id": "tokenization",
          "label": "Payment Tokenization",
          "description": "Secure credential exchange",
          "content": "<h3>Tokenization Flow</h3><p>Payment data flows through secure tokenization:</p><ol><li>User provides payment method to <strong>Credential Provider (CP)</strong></li><li>CP generates a token (no raw card data leaves CP)</li><li>Platform sends token to Business</li><li>Business sends token to <strong>PSP</strong></li><li>PSP exchanges token with CP for actual payment data</li><li>Transaction processed</li></ol><p>This minimizes PCI-DSS scope for Platform and Business.</p>",
          "resources": [
            { "type": "spec", "url": "https://ucp.dev/specification/tokenization-guide", "label": "Tokenization Guide" },
            { "type": "spec", "url": "https://ucp.dev/specification/payment-handler-guide", "label": "Payment Handler Guide" }
          ]
        },
        {
          "id": "signing-keys",
          "label": "JWK Signing Keys",
          "description": "Message signature verification",
          "content": "<h3>Cryptographic Signatures</h3><p>All parties publish JWKs (JSON Web Keys) in their UCP profile:</p><ul><li>Used to sign webhooks, responses, and authenticated messages</li><li>Recipients verify signatures using published public keys</li><li>Prevents message tampering and impersonation</li></ul>"
        }
      ]
    },
    {
      "id": "annotations",
      "label": "6. UCP Annotation System",
      "description": "Source-to-spec generation",
      "content": "<h3>Schema Generation Architecture</h3><p>UCP uses a unique source-to-spec generation model with custom annotations.</p>",
      "resources": [
        { "type": "doc", "url": "https://ucp.dev/documentation/schema-authoring", "label": "Schema Authoring Guide" }
      ],
      "children": [
        {
          "id": "ucp-request",
          "label": "ucp_request Annotation",
          "description": "Controls field behavior in requests",
          "content": "<h3>Request Annotations</h3><p><code>\"ucp_request\": \"omit|optional|required\"</code></p><ul><li><strong>omit</strong> - Field not included in create_req.json or update_req.json</li><li><strong>optional</strong> - Field optional in requests</li><li><strong>required</strong> - Field required in requests</li></ul><p>Enables minimal request payloads (only send what's needed).</p>"
        },
        {
          "id": "ucp-response",
          "label": "ucp_response Annotation",
          "description": "Controls field in responses",
          "content": "<h3>Response Annotations</h3><p><code>\"ucp_response\": \"omit\"</code></p><p>Removes field from response schemas (_resp.json files).</p><p>Useful for internal-only fields that shouldn't be exposed.</p>"
        },
        {
          "id": "ucp-shared-request",
          "label": "ucp_shared_request Annotation",
          "description": "Applies to both create and update",
          "content": "<h3>Shared Request Annotations</h3><p><code>\"ucp_shared_request\": \"optional|required\"</code></p><p>Applies the same rule to both create and update operations.</p><p>Simplifies schemas where create/update behavior is identical.</p>"
        },
        {
          "id": "generation-passes",
          "label": "3-Pass Generation System",
          "description": "How schemas are generated",
          "content": "<h3>Generation Workflow</h3><p><strong>Pass 1-2:</strong> Process annotations → generate per-operation schemas</p><ul><li>type.json → type_create_req.json, type_update_req.json, type_resp.json</li></ul><p><strong>Pass 3:</strong> Generate OpenRPC spec for Embedded Protocol</p><ul><li>Aggregates methods from source/services/shopping/embedded.json</li><li>Combines with extension schemas</li><li>Produces spec/services/shopping/embedded.openrpc.json</li></ul><p><strong>Command:</strong> <code>python generate_schemas.py</code></p>"
        }
      ]
    },
    {
      "id": "extensions",
      "label": "7. Extensions System",
      "description": "Modular feature enhancement",
      "content": "<h3>Extension Architecture</h3><p>Extensions provide optional enhancements to core capabilities without bloating the protocol.</p>",
      "children": [
        {
          "id": "discount-extension",
          "label": "Discount Extension",
          "description": "Promotions and adjustments",
          "content": "<h3>Discount Extension</h3><p><strong>Name:</strong> <code>dev.ucp.shopping.discount</code></p><p><strong>Purpose:</strong> Apply promotional discounts to checkout</p><p><strong>Features:</strong></p><ul><li>Coupon codes</li><li>Automatic discounts (cart total thresholds)</li><li>Line item vs order-level discounts</li><li>Discount stacking rules</li></ul>"
        },
        {
          "id": "fulfillment-extension",
          "label": "Fulfillment Extension",
          "description": "Advanced shipping features",
          "content": "<h3>Fulfillment Extension</h3><p><strong>Name:</strong> <code>dev.ucp.shopping.fulfillment</code></p><p><strong>Purpose:</strong> Enhanced shipping and delivery options</p><p><strong>Features:</strong></p><ul><li>Multiple fulfillment groups (split shipments)</li><li>Real-time shipping rates</li><li>Delivery time estimates</li><li>Pickup options (BOPIS - Buy Online Pickup In Store)</li></ul>"
        },
        {
          "id": "declaring-extensions",
          "label": "Declaring Extensions",
          "description": "How to advertise support",
          "content": "<h3>Extension Declaration</h3><p>Businesses declare extensions in their UCP profile:</p><pre>{\n  \"capabilities\": [\n    {\n      \"name\": \"dev.ucp.shopping.checkout\",\n      \"extensions\": [\"dev.ucp.shopping.discount\", \"dev.ucp.shopping.fulfillment\"]\n    }\n  ]\n}</pre><p>Platforms read this to know which optional features are available.</p>"
        }
      ]
    },
    {
      "id": "capabilities",
      "label": "8. Capabilities Deep Dive",
      "description": "Four foundational capabilities",
      "content": "<h3>Official UCP Capabilities</h3><p>UCP v1 defines four core capabilities for commerce transactions.</p>",
      "children": [
        {
          "id": "checkout-capability",
          "label": "dev.ucp.shopping.checkout",
          "description": "End-to-end checkout flow",
          "content": "<h3>Checkout Capability</h3><p>The most complex capability - handles entire checkout lifecycle:</p><p><strong>Flow:</strong></p><ol><li><strong>create</strong> - Initialize with items, buyer info</li><li><strong>update</strong> - Iteratively add payment, shipping, apply discounts</li><li><strong>update</strong> - Business calculates tax, validates availability</li><li><strong>complete</strong> - Finalize order, return confirmation</li></ol><p><strong>Transports:</strong> REST, MCP, A2A, Embedded</p>",
          "resources": [
            { "type": "spec", "url": "https://ucp.dev/specification/checkout", "label": "Checkout Full Specification" }
          ]
        },
        {
          "id": "identity-linking",
          "label": "dev.ucp.common.identity_linking",
          "description": "OAuth 2.0 authorization",
          "content": "<h3>Identity Linking Capability</h3><p>OAuth 2.0 flow for platforms to obtain authorization:</p><ul><li>Platform requests authorization to act on user's behalf</li><li>User authenticates with Business</li><li>Business issues access token</li><li>Platform uses token for subsequent API calls</li></ul><p>Enables saved payment methods, order history access, etc.</p>",
          "resources": [
            { "type": "spec", "url": "https://ucp.dev/specification/identity-linking", "label": "Identity Linking Spec" }
          ]
        },
        {
          "id": "order-capability",
          "label": "dev.ucp.shopping.order",
          "description": "Post-purchase tracking",
          "content": "<h3>Order Capability</h3><p>Webhook-based updates for order lifecycle:</p><ul><li><strong>order.shipped</strong> - Item shipped with tracking</li><li><strong>order.delivered</strong> - Item delivered</li><li><strong>order.returned</strong> - Return initiated</li><li><strong>order.cancelled</strong> - Order cancelled</li></ul><p>Businesses push these events to platform webhook endpoints.</p>",
          "resources": [
            { "type": "spec", "url": "https://ucp.dev/specification/order", "label": "Order Specification" }
          ]
        },
        {
          "id": "payment-token-exchange",
          "label": "Payment Token Exchange",
          "description": "PSP ↔ CP token flow",
          "content": "<h3>Token Exchange Capability</h3><p>Secure protocol for PSPs to exchange tokens with Credential Providers:</p><ol><li>PSP receives tokenized payment from Business</li><li>PSP calls CP's token exchange endpoint</li><li>CP validates PSP's identity (signing keys)</li><li>CP returns decrypted payment data</li><li>PSP processes transaction</li></ol><p>Example: Google Pay → Stripe token exchange</p>",
          "resources": [
            { "type": "spec", "url": "https://ucp.dev/specification/tokenization-guide", "label": "Tokenization Guide" }
          ]
        }
      ]
    },
    {
      "id": "workflow",
      "label": "9. Development Workflow",
      "description": "Working with the codebase",
      "content": "<h3>Developer Workflow Mastery</h3><p>How to effectively work with UCP's schema generation system.</p>",
      "children": [
        {
          "id": "never-edit-spec",
          "label": "Never Edit spec/ Directly",
          "description": "Golden rule of UCP development",
          "content": "<h3>Critical Rule</h3><p><strong>NEVER manually edit files in spec/</strong></p><p>The spec/ directory is generated. Always:</p><ol><li>Edit schemas in <code>source/</code></li><li>Run <code>python generate_schemas.py</code></li><li>Verify outputs in <code>spec/</code></li></ol><p>Manual edits to spec/ will be overwritten on next generation.</p>"
        },
        {
          "id": "schema-workflow",
          "label": "Schema Development Loop",
          "description": "Edit → Generate → Validate",
          "content": "<h3>Complete Workflow</h3><ol><li><strong>Edit:</strong> Modify <code>source/schemas/shopping/types/buyer.json</code></li><li><strong>Generate:</strong> Run <code>python generate_schemas.py</code></li><li><strong>Validate:</strong> Run <code>python validate_specs.py</code></li><li><strong>Docs:</strong> Run <code>mkdocs serve --watch spec</code></li><li><strong>SDK:</strong> Run <code>bash scripts/ci_check_models.sh</code></li></ol>"
        },
        {
          "id": "adding-new-types",
          "label": "Adding New Schema Types",
          "description": "Step-by-step guide",
          "content": "<h3>New Type Workflow</h3><ol><li>Create <code>source/schemas/shopping/types/my_type.json</code></li><li>Add UCP annotations (<code>ucp_request</code>, <code>ucp_response</code>)</li><li>Run <code>python generate_schemas.py</code></li><li>Verify generated files in <code>spec/schemas/shopping/types/</code></li><li>Update documentation if needed</li><li>Check TypeScript generation works</li><li>May need to extend <code>generate_schemas.py</code> for new patterns</li></ol>"
        },
        {
          "id": "documentation-system",
          "label": "Documentation System",
          "description": "MkDocs with custom macros",
          "content": "<h3>Doc Generation</h3><p>UCP docs use custom MkDocs macros in <code>main.py</code>:</p><ul><li><strong>schema_fields</strong> - Generates tables from JSON schemas</li><li><strong>method_fields</strong> - Generates tables from OpenAPI/OpenRPC</li></ul><p>These macros read directly from <code>spec/</code>, so schema changes automatically propagate to docs.</p><p><strong>Commands:</strong></p><ul><li><code>mkdocs serve --watch spec</code> - Local preview</li><li><code>mkdocs build --strict</code> - Production build (fails on warnings)</li></ul>"
        }
      ]
    },
    {
      "id": "study-strategy",
      "label": "10. Study Strategy by Goal",
      "description": "Learning paths for different roles",
      "content": "<h3>Role-Based Learning Paths</h3><p>Different developers need different perspectives on UCP.</p>",
      "children": [
        {
          "id": "platform-developer",
          "label": "Platform Developers",
          "description": "Building shopping agents/apps",
          "content": "<h3>For Platform Developers</h3><p>Implementing a shopping agent or app that uses UCP:</p><ol><li><strong>core-concepts.md</strong> → Understand the four actors</li><li><strong>discovery/profile_schema.json</strong> → Parse business profiles</li><li><strong>checkout-mcp.md</strong> → MCP implementation for AI agents</li><li><strong>checkout.json + types/*</strong> → Data models</li><li><strong>buyer-consent.md</strong> → User permission framework</li></ol><p><strong>Key Focus:</strong> Calling UCP APIs, handling responses, UI/UX for checkout</p>"
        },
        {
          "id": "business-integrator",
          "label": "Business Integrators",
          "description": "Exposing inventory via UCP",
          "content": "<h3>For Business Integrators</h3><p>Exposing your inventory and implementing UCP endpoints:</p><ol><li><strong>core-concepts.md</strong> → Understand Merchant of Record role</li><li><strong>checkout-rest.md</strong> → REST endpoint implementation</li><li><strong>embedded-checkout.md</strong> → iframe integration patterns</li><li><strong>fulfillment.json</strong> → Shipping logic</li><li><strong>discount.json</strong> → Promotions system</li></ol><p><strong>Key Focus:</strong> Implementing endpoints, calculating tax/shipping, inventory management</p>"
        },
        {
          "id": "psp-cp-developer",
          "label": "PSP/CP Developers",
          "description": "Payment infrastructure",
          "content": "<h3>For PSP/CP Developers</h3><p>Building payment service providers or credential providers:</p><ol><li><strong>tokenization-guide.md</strong> → Token exchange flows</li><li><strong>payment-handler-guide.md</strong> → Handler integration</li><li><strong>handlers/tokenization/google_pay/</strong> → Reference implementation</li><li><strong>ap2-mandates.md</strong> → Security requirements (3DS, SCA)</li></ol><p><strong>Key Focus:</strong> Secure token exchange, PCI compliance, authentication mandates</p>"
        },
        {
          "id": "protocol-contributor",
          "label": "Protocol Contributors",
          "description": "Contributing to UCP itself",
          "content": "<h3>For Protocol Contributors</h3><p>Contributing schemas, documentation, or SDKs to UCP:</p><ol><li><strong>schema-authoring.md</strong> → Annotation system</li><li><strong>generate_schemas.py</strong> → Generation logic</li><li><strong>CONTRIBUTING.md</strong> → Process and conventions</li><li>All of the above 😄</li></ol><p><strong>Key Focus:</strong> Schema design, backward compatibility, documentation quality</p>"
        }
      ]
    },
    {
      "id": "key-insights",
      "label": "11. Key Insights",
      "description": "Critical understanding for mastery",
      "content": "<h3>Core Principles to Internalize</h3><p>These insights represent deep understanding of UCP's design philosophy.</p>",
      "children": [
        {
          "id": "composability",
          "label": "Composable Architecture",
          "description": "Capabilities + Extensions",
          "content": "<h3>Composability Principle</h3><p>UCP breaks commerce into:</p><ul><li><strong>Capabilities</strong> - Complete flows (checkout, order)</li><li><strong>Extensions</strong> - Optional enhancements (discounts, loyalty)</li></ul><p>This allows businesses to implement only what they need while maintaining interoperability.</p><p>New capabilities and extensions can be added without breaking existing implementations.</p>"
        },
        {
          "id": "data-flow",
          "label": "Typical Data Flow",
          "description": "End-to-end transaction",
          "content": "<h3>Standard Checkout Flow</h3><ol><li><strong>Discovery:</strong> Platform discovers Business via /.well-known/ucp</li><li><strong>Capabilities:</strong> Platform reads capabilities[] and payment.handlers[]</li><li><strong>Create:</strong> Platform calls checkout_create with initial state</li><li><strong>Options:</strong> Business responds with fulfillment options, payment methods</li><li><strong>Update:</strong> Platform calls checkout_update iteratively (add payment, select shipping)</li><li><strong>Validate:</strong> Business validates, applies logic (tax calculation, discount)</li><li><strong>Complete:</strong> Platform calls checkout_complete</li><li><strong>Order:</strong> Business places order, returns order_confirmation</li><li><strong>Webhooks:</strong> Business sends order updates (shipped, delivered)</li></ol>"
        },
        {
          "id": "security-layers",
          "label": "Multi-Layer Security",
          "description": "Defense in depth",
          "content": "<h3>Security Architecture</h3><p>UCP implements multiple security layers:</p><ul><li><strong>JWK Signing Keys</strong> - Message verification</li><li><strong>OAuth 2.0</strong> - Identity linking</li><li><strong>PCI-DSS Compliance</strong> - Via tokenization</li><li><strong>AP2 Mandates</strong> - 3DS and risk checks</li><li><strong>Buyer Consent</strong> - Explicit permissions for agents</li></ul><p>Each layer addresses a specific security concern without adding unnecessary complexity.</p>"
        },
        {
          "id": "schema-philosophy",
          "label": "Schema Design Philosophy",
          "description": "Minimal requests, rich responses",
          "content": "<h3>Design Principles</h3><ul><li><strong>Minimal Requests:</strong> Omit fields with sensible defaults</li><li><strong>Rich Responses:</strong> Provide full context to platforms</li><li><strong>Idempotent Operations:</strong> Safe to retry failed requests</li><li><strong>Extensible:</strong> additionalProperties: true allows custom fields</li></ul><p>This reduces bandwidth while giving platforms everything they need.</p>"
        },
        {
          "id": "transport-agnostic",
          "label": "Transport Agnostic Design",
          "description": "One protocol, many transports",
          "content": "<h3>Transport Independence</h3><p>UCP capabilities are defined independently of transport:</p><ul><li>Same checkout capability works over REST, MCP, A2A, or Embedded</li><li>Businesses choose which transports to support</li><li>New transports can be added without changing core protocol</li></ul><p>This future-proofs UCP as new communication protocols emerge.</p>"
        }
      ]
    }
  ]
}
