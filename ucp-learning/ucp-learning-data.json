{
  "id": "root",
  "label": "UCP Learning Path",
  "children": [
    {
      "id": "foundations",
      "label": "1. Foundations & Philosophy",
      "description": "Understand the 'why' before the 'how'",
      "content": "<h3>Start Here: Core Concepts</h3><p>The Universal Commerce Protocol (UCP) addresses the fragmented commerce landscape by providing a standardized common language and functional primitives.</p><p><strong>Key Problem:</strong> Different systems (platforms, businesses, payment providers) can't communicate efficiently, leading to custom, one-off integrations.</p><p><strong>Solution:</strong> UCP provides a uniform protocol that works across all parties.</p>",
      "resources": [
        {
          "type": "doc",
          "url": "https://ucp.dev/documentation/core-concepts",
          "label": "Core Concepts Documentation"
        },
        {
          "type": "doc",
          "url": "https://github.com/Universal-Commerce-Protocol/ucp",
          "label": "GitHub Repository"
        }
      ],
      "children": [
        {
          "id": "four-actors",
          "label": "Four Actors Model",
          "description": "Platform, Business, CP, PSP",
          "content": "<h3>The Four Primary Actors</h3><p>UCP defines four distinct actors in the commerce lifecycle, each with specific responsibilities and clear boundaries. This separation enables secure, scalable, and compliant commerce without tight coupling.</p><h4>1. Platform (Consumer Surface)</h4><p>The consumer-facing surface acting on behalf of users - AI agents, mobile apps, social media, search engines.</p><p><strong>Responsibilities:</strong></p><ul><li>Discovers business capabilities via <code>/.well-known/ucp</code></li><li>Orchestrates checkout flow on behalf of user</li><li>Presents UI/conversational interface</li><li>Manages user consent for agentic transactions</li></ul><p><strong>Examples:</strong> AI Shopping Assistants, Super Apps (WeChat, Grab), Voice Assistants</p><h4>2. Business (Merchant of Record)</h4><p>The entity selling goods/services, retaining financial liability and order ownership.</p><p><strong>Responsibilities:</strong></p><ul><li>Exposes inventory and pricing via UCP</li><li>Calculates tax and shipping</li><li>Fulfills orders</li><li>Processes payments via chosen PSP</li></ul><p><strong>Examples:</strong> Retailers (Shopify merchants), Airlines, Hotels, SaaS providers</p><h4>3. Credential Provider (CP)</h4><p>Trusted entity managing sensitive user data, especially payment instruments and shipping addresses.</p><p><strong>Responsibilities:</strong></p><ul><li>Authenticates users (OAuth 2.0)</li><li>Issues payment tokens (keeps raw card data secure)</li><li>Holds PII to minimize compliance scope for others</li><li>Exchanges tokens with PSPs for transaction processing</li></ul><p><strong>Examples:</strong> Google Wallet, Apple Pay, Digital Wallet Providers</p><h4>4. Payment Service Provider (PSP)</h4><p>Financial infrastructure provider processing payments on behalf of businesses.</p><p><strong>Responsibilities:</strong></p><ul><li>Authorizes and captures transactions</li><li>Handles settlements with card networks</li><li>Exchanges tokens with CPs for payment data</li><li>Issues AP2 mandates for additional authentication (3DS)</li></ul><p><strong>Examples:</strong> Stripe, Adyen, PayPal, Braintree, Chase Paymentech</p><h4>Example: Complete Transaction Flow</h4><pre><code class=\"language-javascript\">// Platform discovers and initiates checkout\nasync function platformCheckout() {\n  // 1. Platform discovers business capabilities\n  const profile = await fetch('https://shop.example.com/.well-known/ucp');\n  const { capabilities } = await profile.json();\n  \n  // 2. Platform creates checkout session\n  const checkout = await fetch('https://shop.example.com/api/ucp/checkout/create', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      items: [{ sku: 'ABC123', quantity: 1 }],\n      buyer: { email: 'user@example.com' }\n    })\n  });\n  \n  // 3. User selects payment via Credential Provider\n  const paymentToken = await getPaymentFromCP(); // CP tokenizes card\n  \n  // 4. Platform updates checkout with payment\n  const updated = await fetch('https://shop.example.com/api/ucp/checkout/update', {\n    method: 'POST',\n    body: JSON.stringify({\n      checkout_id: checkout.id,\n      payment: { token: paymentToken, provider: 'google_pay' }\n    })\n  });\n  \n  // 5. Business forwards to PSP, PSP exchanges token with CP\n  // (happens server-side at Business)\n  \n  // 6. Platform completes checkout\n  const order = await fetch('https://shop.example.com/api/ucp/checkout/complete', {\n    method: 'POST',\n    body: JSON.stringify({ checkout_id: checkout.id })\n  });\n  \n  return order.order_id; // Transaction complete!\n}\n\n// Credential Provider tokenizes payment\nasync function getPaymentFromCP() {\n  // User provides payment method to CP (outside UCP scope)\n  // CP returns token that Platform sends to Business\n  return 'tok_secure_google_pay_token_12345';\n}\n</code></pre><h4>Key Insights</h4><ul><li><strong>Separation of Concerns:</strong> Each actor focuses on its expertise (Platform=UX, Business=Commerce, CP=Security, PSP=Payments)</li><li><strong>Trust Boundaries:</strong> Raw payment data never touches Platform or Business - only CP and PSP handle it</li><li><strong>Flexibility:</strong> Platform can work with any Business, Business can use any PSP, etc.</li></ul><h4>Common Pitfalls</h4><ul><li><strong>Confusing CP and PSP:</strong> CP holds user credentials and issues tokens; PSP processes the actual transaction with card networks. They exchange tokens securely.</li><li><strong>Assuming Platform is merchant:</strong> Business is always the Merchant of Record (MoR), not the Platform. Platform facilitates but doesn't own the transaction.</li><li><strong>Tight coupling:</strong> Avoid hard-coding business URLs - use discovery (<code>/.well-known/ucp</code>) to find endpoints dynamically.</li></ul>",
          "resources": [
            {
              "type": "doc",
              "url": "https://ucp.dev/documentation/core-concepts/#roles-participants",
              "label": "Roles & Participants"
            },
            {
              "type": "spec",
              "url": "https://ucp.dev/specification/overview/",
              "label": "UCP Specification Overview"
            }
          ]
        },
        {
          "id": "governance-model",
          "label": "Governance Model",
          "description": "Reverse-domain namespacing",
          "content": "<h3>Decentralized Governance</h3><p>UCP uses reverse-domain naming to encode governance authority directly into capability identifiers. This eliminates the need for a central registry while ensuring clear ownership and preventing namespace collisions.</p><h4>Namespace Format</h4><p><strong>Required Format:</strong> <code>{reverse-domain}.{service}.{capability}</code></p><p><strong>Components:</strong></p><ul><li><strong>{reverse-domain}</strong> - Authority identifier from domain ownership (e.g., <code>dev.ucp</code>, <code>com.shopify</code>)</li><li><strong>{service}</strong> - Service/vertical category (e.g., <code>shopping</code>, <code>common</code>, <code>payments</code>)</li><li><strong>{capability}</strong> - Specific capability name (e.g., <code>checkout</code>, <code>identity_linking</code>)</li></ul><h4>Official UCP Capabilities</h4><table><tr><th>Name</th><th>Authority</th><th>Service</th><th>Capability</th></tr><tr><td><code>dev.ucp.shopping.checkout</code></td><td>ucp.dev</td><td>shopping</td><td>checkout</td></tr><tr><td><code>dev.ucp.shopping.order</code></td><td>ucp.dev</td><td>shopping</td><td>order</td></tr><tr><td><code>dev.ucp.shopping.discount</code></td><td>ucp.dev</td><td>shopping</td><td>discount</td></tr><tr><td><code>dev.ucp.shopping.fulfillment</code></td><td>ucp.dev</td><td>shopping</td><td>fulfillment</td></tr><tr><td><code>dev.ucp.common.identity_linking</code></td><td>ucp.dev</td><td>common</td><td>identity_linking</td></tr></table><h4>Custom Vendor Capabilities</h4><p>Vendors can create custom capabilities using their own reverse-domain:</p><pre><code>com.shopify.payments.installments  // Shopify's installment payments\ncom.example.loyalty.rewards        // Example.com's loyalty program\norg.acme.shipping.same_day         // Acme.org's same-day delivery\n</code></pre><h4>Spec URL Binding (Security)</h4><p>The <code>spec</code> and <code>schema</code> URLs <strong>MUST</strong> have origins matching the namespace authority. This prevents capability hijacking.</p><table><tr><th>Namespace</th><th>Required Origin</th><th>Valid?</th></tr><tr><td><code>dev.ucp.*</code></td><td><code>https://ucp.dev/...</code></td><td>✅ Yes</td></tr><tr><td><code>dev.ucp.*</code></td><td><code>https://evil.com/...</code></td><td>❌ No (origin mismatch)</td></tr><tr><td><code>com.shopify.*</code></td><td><code>https://shopify.com/...</code></td><td>✅ Yes</td></tr></table><h4>Namespace Validation Code</h4><pre><code class=\"language-javascript\">/**\n * Validates a UCP capability namespace and spec URL binding\n * @param {object} capability - Capability object from profile\n * @returns {boolean} True if valid\n */\nfunction validateCapabilityNamespace(capability) {\n  const { name, spec, schema } = capability;\n  \n  // Parse namespace\n  const parts = name.split('.');\n  if (parts.length < 3) {\n    console.error(`Invalid namespace format: ${name}`);\n    return false;\n  }\n  \n  // Extract authority (reverse-domain)\n  const authority = parts.slice(0, -2).reverse().join('.');\n  console.log(`Authority: ${authority}`);\n  \n  // Validate spec URL origin matches authority\n  try {\n    const specUrl = new URL(spec);\n    const expectedOrigin = `https://${authority}`;\n    \n    if (!specUrl.origin.startsWith(expectedOrigin)) {\n      console.error(\n        `Spec URL origin mismatch: ` +\n        `expected ${expectedOrigin}, got ${specUrl.origin}`\n      );\n      return false;\n    }\n    \n    // Also validate schema URL if present\n    if (schema) {\n      const schemaUrl = new URL(schema);\n      if (!schemaUrl.origin.startsWith(expectedOrigin)) {\n        console.error(\n          `Schema URL origin mismatch: ` +\n          `expected ${expectedOrigin}, got ${schemaUrl.origin}`\n        );\n        return false;\n      }\n    }\n    \n    return true;\n    \n  } catch (error) {\n    console.error(`Invalid URL in capability:`, error);\n    return false;\n  }\n}\n\n// Example usage\nconst capability = {\n  name: 'dev.ucp.shopping.checkout',\n  spec: 'https://ucp.dev/specification/checkout',\n  schema: 'https://ucp.dev/schemas/shopping/checkout.json'\n};\n\nif (validateCapabilityNamespace(capability)) {\n  console.log('✅ Capability is valid');\n} else {\n  console.log('❌ Capability validation failed');\n}\n\n// This would fail (origin mismatch)\nconst malicious = {\n  name: 'dev.ucp.shopping.checkout',\n  spec: 'https://evil.com/fake-spec',  // Wrong origin!\n  schema: 'https://evil.com/fake-schema'\n};\nvalidateCapabilityNamespace(malicious); // => false\n</code></pre><h4>Governance Implications</h4><ul><li><strong>No Central Authority:</strong> Anyone can create capabilities under their domain</li><li><strong>Clear Ownership:</strong> Domain ownership proves authority</li><li><strong>No Collisions:</strong> Each domain controls its own namespace</li><li><strong>Verifiable:</strong> Spec URLs must match namespace origin (security)</li></ul><h4>Common Pitfalls</h4><ul><li><strong>Wrong component order:</strong> Must be reverse-domain first (e.g., <code>dev.ucp</code> not <code>ucp.dev</code>)</li><li><strong>Missing validation:</strong> Always validate spec URL origin matches namespace authority</li><li><strong>Using underscores:</strong> Use dots as separators, not underscores (except in final capability name)</li><li><strong>Assuming centralization:</strong> UCP has no central registry - governance is distributed via DNS</li></ul>",
          "resources": [
            {
              "type": "spec",
              "url": "https://ucp.dev/specification/overview/#namespace-governance",
              "label": "Namespace Governance"
            },
            {
              "type": "doc",
              "url": "https://ucp.dev/documentation/core-concepts/",
              "label": "Core Concepts"
            }
          ]
        },
        {
          "id": "server-selects",
          "label": "Server-Selects Architecture",
          "description": "Business chooses protocol version",
          "content": "<h3>Server-Selects Version Negotiation</h3><p>In UCP's server-selects architecture, the <strong>business (server)</strong> chooses the protocol version and capabilities from the intersection of what both parties support. This is the opposite of client-driven negotiation (like HTTP content negotiation).</p><h4>Why Server-Selects?</h4><ul><li><strong>Business Control:</strong> Business knows its implementation best and chooses compatible versions</li><li><strong>Gradual Evolution:</strong> New protocol versions can be deployed without breaking existing clients</li><li><strong>Simplified Clients:</strong> Platforms don't need complex fallback logic</li><li><strong>Testing:</strong> Business can test new versions with specific clients before wide rollout</li></ul><h4>Negotiation Flow</h4><ol><li><strong>Platform</strong> fetches business profile from <code>/.well-known/ucp</code></li><li><strong>Platform</strong> sends request with its supported capabilities in headers or params</li><li><strong>Business</strong> computes intersection of capabilities</li><li><strong>Business</strong> selects version from intersection (usually latest both support)</li><li><strong>Business</strong> responds using selected version</li></ol><h4>Capability Intersection Example</h4><pre><code class=\"language-javascript\">/**\n * Compute capability intersection between platform and business\n * @param {string[]} platformCaps - Platform's supported capabilities\n * @param {string[]} businessCaps - Business's supported capabilities  \n * @returns {string[]} Intersection of capabilities\n */\nfunction computeCapabilityIntersection(platformCaps, businessCaps) {\n  return platformCaps.filter(cap => businessCaps.includes(cap));\n}\n\n// Example: Platform supports checkout v1 and v2\nconst platformCapabilities = [\n  'dev.ucp.shopping.checkout@2026-01-11',\n  'dev.ucp.shopping.checkout@2025-06-01',\n  'dev.ucp.shopping.discount@2026-01-11'\n];\n\n// Business only supports checkout v1 (older)\nconst businessCapabilities = [\n  'dev.ucp.shopping.checkout@2025-06-01',\n  'dev.ucp.shopping.fulfillment@2025-06-01'\n];\n\nconst intersection = computeCapabilityIntersection(\n  platformCapabilities,\n  businessCapabilities\n);\n\nconsole.log('Intersection:', intersection);\n// => ['dev.ucp.shopping.checkout@2025-06-01']\n\n// Business selects from intersection (usually latest)\nconst selectedVersion = intersection[0];\nconsole.log('Business selects:', selectedVersion);\n</code></pre><h4>Implementation Pattern (Business)</h4><pre><code class=\"language-javascript\">// Express.js middleware for version negotiation\napp.use('/api/ucp/*', (req, res, next) => {\n  // Platform sends supported versions in header\n  const platformVersions = req.headers['x-ucp-versions']?.split(',') || [];\n  \n  // Business's supported versions\n  const businessVersions = [\n    'dev.ucp.shopping.checkout@2026-01-11',\n    'dev.ucp.shopping.checkout@2025-06-01'\n  ];\n  \n  // Compute intersection\n  const compatible = platformVersions.filter(v => \n    businessVersions.includes(v)\n  );\n  \n  if (compatible.length === 0) {\n    return res.status(400).json({\n      error: 'no_compatible_version',\n      message: 'No mutually supported protocol version',\n      business_versions: businessVersions\n    });\n  }\n  \n  // Business selects latest compatible version\n  const selected = compatible[0]; // Assume sorted newest first\n  \n  // Store selected version in request for handler use\n  req.ucpVersion = selected;\n  \n  // Return selected version in response header\n  res.setHeader('X-UCP-Version', selected);\n  \n  next();\n});\n\n// Checkout endpoint uses negotiated version\napp.post('/api/ucp/checkout/create', (req, res) => {\n  const version = req.ucpVersion;\n  \n  // Use version-specific logic\n  if (version === 'dev.ucp.shopping.checkout@2026-01-11') {\n    // Handle v2 with new features\n    return handleCheckoutV2(req, res);\n  } else {\n    // Handle v1 (backward compatibility)\n    return handleCheckoutV1(req, res);\n  }\n});\n</code></pre><h4>Caching Considerations</h4><p>Since profiles change infrequently:</p><ul><li>Platform caches business profile (1 hour recommended)</li><li>Business caches platform capabilities (per-session)</li><li>Negotiation happens once per session, not per request</li></ul><h4>Version Format</h4><p>Versions follow ISO date format: <code>YYYY-MM-DD</code></p><ul><li><code>dev.ucp.shopping.checkout@2026-01-11</code> - Explicit version</li><li><code>dev.ucp.shopping.checkout</code> - No version (assumes latest)</li></ul><h4>Common Pitfalls</h4><ul><li><strong>Client selecting version:</strong> Don't implement client-selects - business always chooses</li><li><strong>No intersection:</strong> Handle case where no common version exists gracefully</li><li><strong>Assuming latest:</strong> Business should select from intersection, not assume platform supports latest</li><li><strong>Per-request negotiation:</strong> Cache negotiation result, don't renegotiate every API call</li></ul><h4>Benefits Over Client-Selects</h4><ul><li>Business controls rollout of new versions</li><li>Easier A/B testing (business picks version per client)</li><li>Simpler platform code (no complex fallback chains)</li><li>Business can require minimum version for sensitive operations</li></ul>",
          "resources": [
            {
              "type": "spec",
              "url": "https://ucp.dev/specification/overview/#discovery-governance-and-negotiation",
              "label": "Discovery & Negotiation"
            },
            {
              "type": "doc",
              "url": "https://ucp.dev/documentation/core-concepts/",
              "label": "Core Concepts"
            }
          ]
        }
      ]
    },
    {
      "id": "discovery",
      "label": "2. Discovery & Capability System",
      "description": "How parties find and understand each other",
      "content": "<h3>Dynamic Discovery</h3><p>UCP enables platforms to autonomously discover what businesses support without manual configuration.</p>",
      "resources": [
        {
          "type": "spec",
          "url": "https://ucp.dev/specification/overview#discovery",
          "label": "Discovery Specification"
        }
      ],
      "children": [
        {
          "id": "well-known-ucp",
          "label": "/.well-known/ucp Endpoint",
          "description": "Standard discovery endpoint",
          "content": "<h3>Profile Discovery</h3><p>Every UCP-compliant business <strong>MUST</strong> expose a machine-readable profile at the standard <code>/.well-known/ucp</code> endpoint. This enables platforms to autonomously discover capabilities without manual configuration or API keys.</p><h4>Profile Structure</h4><p>The profile declares:</p><ul><li><strong>capabilities[]</strong> - Supported capabilities and extensions with versions</li><li><strong>services</strong> - Transport bindings (REST, MCP, A2A, Embedded)</li><li><strong>payment.handlers[]</strong> - Instructions for collecting payment instruments</li><li><strong>signing_keys[]</strong> - JWKs (JSON Web Keys) for signature verification</li><li><strong>webhooks</strong> - Callback endpoints for events (optional)</li></ul><h4>Example Profile</h4><pre><code class=\"language-json\">{\n  \"version\": \"2026-01-11\",\n  \"capabilities\": [\n    {\n      \"name\": \"dev.ucp.shopping.checkout\",\n      \"version\": \"2026-01-11\",\n      \"spec\": \"https://ucp.dev/specification/checkout\",\n      \"schema\": \"https://ucp.dev/schemas/shopping/checkout.json\",\n      \"extensions\": [\n        \"dev.ucp.shopping.discount\",\n        \"dev.ucp.shopping.fulfillment\"\n      ]\n    },\n    {\n      \"name\": \"dev.ucp.shopping.order\",\n      \"version\": \"2026-01-11\",\n      \"spec\": \"https://ucp.dev/specification/order\",\n      \"schema\": \"https://ucp.dev/schemas/shopping/order.json\"\n    }\n  ],\n  \"services\": {\n    \"shopping\": {\n      \"version\": \"2026-01-11\",\n      \"spec\": \"https://ucp.dev/services/shopping/\",\n      \"rest\": {\n        \"schema\": \"https://ucp.dev/services/shopping/rest.openapi.json\",\n        \"endpoint\": \"https://shop.example.com/api/ucp\"\n      },\n      \"mcp\": {\n        \"schema\": \"https://ucp.dev/services/shopping/mcp.openrpc.json\",\n        \"endpoint\": \"https://shop.example.com/mcp\"\n      }\n    }\n  },\n  \"payment\": {\n    \"handlers\": [\n      {\n        \"type\": \"google_pay\",\n        \"url\": \"https://shop.example.com/payment/google-pay\"\n      }\n    ]\n  },\n  \"signing_keys\": [\n    {\n      \"kty\": \"RSA\",\n      \"kid\": \"shop-2026-01\",\n      \"use\": \"sig\",\n      \"n\": \"0vx7agoebG...\",\n      \"e\": \"AQAB\"\n    }\n  ]\n}\n</code></pre><h4>Profile Fetching Code</h4><pre><code class=\"language-javascript\">/**\n * Fetch and parse UCP profile from a business\n * @param {string} businessUrl - Base URL of the business\n * @returns {Promise<UCPProfile>} Parsed profile\n */\nasync function fetchUCPProfile(businessUrl) {\n  try {\n    // Construct well-known URL\n    const url = new URL('/.well-known/ucp', businessUrl);\n    \n    const response = await fetch(url.toString(), {\n      headers: {\n        'Accept': 'application/json',\n        'User-Agent': 'MyPlatform/1.0 (UCP Client)'\n      },\n      // Cache profile for performance\n      cache: 'force-cache',\n      // Timeout after 5 seconds\n      signal: AbortSignal.timeout(5000)\n    });\n    \n    if (!response.ok) {\n      throw new Error(`Profile fetch failed: ${response.status}`);\n    }\n    \n    const profile = await response.json();\n    \n    // Validate required fields\n    if (!profile.capabilities || !Array.isArray(profile.capabilities)) {\n      throw new Error('Invalid profile: missing capabilities[]');\n    }\n    \n    if (!profile.services) {\n      throw new Error('Invalid profile: missing services');\n    }\n    \n    console.log(`Discovered ${profile.capabilities.length} capabilities`);\n    return profile;\n    \n  } catch (error) {\n    console.error('Failed to fetch UCP profile:', error);\n    throw error;\n  }\n}\n\n// Check if business supports specific capability\nfunction supportsCapability(profile, capabilityName) {\n  return profile.capabilities.some(cap => cap.name === capabilityName);\n}\n\n// Get REST endpoint for a service\nfunction getRESTEndpoint(profile, serviceName) {\n  const service = profile.services[serviceName];\n  return service?.rest?.endpoint || null;\n}\n\n// Example usage\nconst profile = await fetchUCPProfile('https://shop.example.com');\n\nif (supportsCapability(profile, 'dev.ucp.shopping.checkout')) {\n  const endpoint = getRESTEndpoint(profile, 'shopping');\n  console.log('Checkout endpoint:', endpoint);\n  // => https://shop.example.com/api/ucp\n}\n</code></pre><h4>Caching Strategy</h4><p>Profiles change infrequently, so aggressive caching is recommended:</p><ul><li><strong>HTTP Cache-Control:</strong> Businesses SHOULD set <code>max-age=3600</code> (1 hour)</li><li><strong>Client-Side:</strong> Platforms SHOULD cache profiles for at least 1 hour</li><li><strong>Invalidation:</strong> Refresh on 404/5xx errors or version mismatch</li></ul><h4>Common Pitfalls</h4><ul><li><strong>Forgetting HTTPS:</strong> Profile <strong>MUST</strong> be served over HTTPS in production</li><li><strong>Not caching:</strong> Fetching profile on every request wastes bandwidth - cache aggressively</li><li><strong>Ignoring extensions:</strong> Check <code>capability.extensions[]</code> to see optional features like discounts</li><li><strong>Hard-coding endpoints:</strong> Always read endpoints from profile, never hard-code</li></ul>",
          "resources": [
            {
              "type": "spec",
              "url": "https://ucp.dev/specification/overview/#discovery-governance-and-negotiation",
              "label": "Discovery Specification"
            },
            {
              "type": "schema",
              "url": "https://ucp.dev/schemas/discovery/profile.json",
              "label": "Profile Schema"
            }
          ]
        },
        {
          "id": "capabilities-vs-extensions",
          "label": "Capabilities vs Extensions",
          "description": "Core vs optional features",
          "content": "<h3>Composable Architecture</h3><p>UCP separates core functionality (capabilities) from optional enhancements (extensions) to keep the protocol lean while enabling rich feature sets.</p><h4>Capabilities (Core Features)</h4><p><strong>Capabilities</strong> are standalone, complete features that define an entire flow. They are the \"verbs\" of UCP.</p><p><strong>Characteristics:</strong></p><ul><li>Self-contained and independently useful</li><li>Define complete request/response lifecycle</li><li>Can work without any extensions</li><li>Examples: <code>checkout</code>, <code>order</code>, <code>identity_linking</code></li></ul><p><strong>Official UCP Capabilities:</strong></p><table><tr><th>Capability</th><th>Purpose</th><th>Complete Flow?</th></tr><tr><td><code>dev.ucp.shopping.checkout</code></td><td>End-to-end purchase flow</td><td>✅ Yes</td></tr><tr><td><code>dev.ucp.shopping.order</code></td><td>Post-purchase tracking</td><td>✅ Yes</td></tr><tr><td><code>dev.ucp.common.identity_linking</code></td><td>OAuth authorization</td><td>✅ Yes</td></tr></table><h4>Extensions (Optional Features)</h4><p><strong>Extensions</strong> augment a parent capability with additional functionality. They use the <code>extends</code> field to declare their parent.</p><p><strong>Characteristics:</strong></p><ul><li>Cannot work standalone (require parent capability)</li><li>Add optional fields to parent schemas</li><li>Business declares support via <code>capability.extensions[]</code></li><li>Examples: <code>discount</code>, <code>fulfillment</code>, <code>ap2_mandates</code></li></ul><p><strong>Official UCP Extensions:</strong></p><table><tr><th>Extension</th><th>Extends</th><th>Purpose</th></tr><tr><td><code>dev.ucp.shopping.discount</code></td><td>checkout</td><td>Promotional discounts</td></tr><tr><td><code>dev.ucp.shopping.fulfillment</code></td><td>checkout</td><td>Shipping options</td></tr><tr><td><code>dev.ucp.shopping.ap2_mandates</code></td><td>checkout</td><td>Payment authentication</td></tr></table><h4>Declaration Example</h4><pre><code class=\"language-json\">// Business profile declares capability with extensions\n{\n  \"capabilities\": [\n    {\n      \"name\": \"dev.ucp.shopping.checkout\",\n      \"version\": \"2026-01-11\",\n      \"spec\": \"https://ucp.dev/specification/checkout\",\n      \"schema\": \"https://ucp.dev/schemas/shopping/checkout.json\",\n      \n      // Extensions this business supports\n      \"extensions\": [\n        \"dev.ucp.shopping.discount\",\n        \"dev.ucp.shopping.fulfillment\"\n      ]\n    }\n  ]\n}\n</code></pre><h4>Checking for Extension Support</h4><pre><code class=\"language-javascript\">/**\n * Check if business supports a specific extension\n * @param {object} profile - UCP profile from /.well-known/ucp\n * @param {string} capabilityName - Parent capability name\n * @param {string} extensionName - Extension to check\n * @returns {boolean} True if supported\n */\nfunction supportsExtension(profile, capabilityName, extensionName) {\n  const capability = profile.capabilities.find(c => c.name === capabilityName);\n  \n  if (!capability) {\n    return false; // Capability not supported at all\n  }\n  \n  return capability.extensions?.includes(extensionName) || false;\n}\n\n// Example usage\nconst profile = await fetchUCPProfile('https://shop.example.com');\n\n// Check if discounts are supported\nif (supportsExtension(profile, 'dev.ucp.shopping.checkout', 'dev.ucp.shopping.discount')) {\n  console.log('✅ This business supports discount codes!');\n  // Show coupon code input in UI\n} else {\n  console.log('❌ No discount support');\n  // Hide coupon code input\n}\n\n// Check if advanced fulfillment is supported\nif (supportsExtension(profile, 'dev.ucp.shopping.checkout', 'dev.ucp.shopping.fulfillment')) {\n  console.log('✅ Advanced shipping options available');\n} else {\n  console.log('Basic shipping only');\n}\n</code></pre><h4>Schema Composition</h4><p>Extensions modify the parent capability's schema using JSON Schema <code>allOf</code> composition:</p><pre><code class=\"language-json\">// Discount extension adds fields to checkout\n{\n  \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n  \"$id\": \"https://ucp.dev/schemas/shopping/discount.json\",\n  \"title\": \"Discount Extension\",\n  \"extends\": \"dev.ucp.shopping.checkout\",\n  \n  \"allOf\": [\n    {\n      \"$ref\": \"./checkout.json\"  // Base checkout schema\n    },\n    {\n      // Additional fields added by discount extension\n      \"properties\": {\n        \"discount\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"code\": { \"type\": \"string\" },\n            \"amount\": { \"type\": \"integer\" },\n            \"type\": { \"enum\": [\"percentage\", \"fixed\"] }\n          }\n        }\n      }\n    }\n  ]\n}\n</code></pre><h4>Extension Lifecycle</h4><ol><li><strong>Discovery:</strong> Platform reads business profile, sees supported extensions</li><li><strong>Schema Resolution:</strong> Platform fetches extension schemas and composes with base</li><li><strong>Request:</strong> Platform sends request with extension-specific fields (if applicable)</li><li><strong>Response:</strong> Business includes extension fields in response</li></ol><h4>Design Principles</h4><ul><li><strong>Lean Core:</strong> Base capabilities work without extensions (graceful degradation)</li><li><strong>Optional:</strong> Platforms can ignore unsupported extensions</li><li><strong>Composable:</strong> Multiple extensions can augment the same capability</li><li><strong>Self-Describing:</strong> Extension schemas declare what they add</li></ul><h4>Common Pitfalls</h4><ul><li><strong>Assuming extension support:</strong> Always check <code>capability.extensions[]</code> before using extension fields</li><li><strong>Making extensions required:</strong> Extensions should be truly optional - core flow works without them</li><li><strong>Not fetching extension schemas:</strong> Must compose base + extension schemas for validation</li><li><strong>Wrong extends reference:</strong> Extension must reference an actual capability, not another extension</li></ul>",
          "resources": [
            {
              "type": "spec",
              "url": "https://ucp.dev/specification/overview/#extensions",
              "label": "Extensions Specification"
            },
            {
              "type": "schema",
              "url": "https://ucp.dev/schemas/shopping/discount.json",
              "label": "Discount Extension Schema"
            }
          ]
        },
        {
          "id": "namespace-format",
          "label": "Namespace Format",
          "description": "Reverse-domain naming convention",
          "content": "<h3>Capability Naming Convention</h3><p>All UCP capabilities and services <strong>MUST</strong> follow the reverse-domain naming format. This ensures global uniqueness and encodes governance authority directly in the name.</p><h4>Required Format</h4><pre><code>{reverse-domain}.{service}.{capability}\n\nExamples:\ndev.ucp.shopping.checkout      // Official UCP capability\ncom.shopify.loyalty.points     // Shopify's custom capability\norg.example.shipping.expedited // Example.org's expedited shipping\n</code></pre><h4>Component Breakdown</h4><table><tr><th>Component</th><th>Purpose</th><th>Rules</th><th>Example</th></tr><tr><td><strong>reverse-domain</strong></td><td>Authority identifier</td><td>Lowercase, dots as separators</td><td><code>dev.ucp</code>, <code>com.shopify</code></td></tr><tr><td><strong>service</strong></td><td>Vertical/category</td><td>Lowercase, single word</td><td><code>shopping</code>, <code>common</code>, <code>payments</code></td></tr><tr><td><strong>capability</strong></td><td>Specific feature name</td><td>Lowercase, underscores OK</td><td><code>checkout</code>, <code>identity_linking</code></td></tr></table><h4>Official UCP Namespaces</h4><p><strong>dev.ucp.shopping.*</strong> - Shopping/Commerce capabilities</p><ul><li><code>dev.ucp.shopping.checkout</code> - Complete checkout flow</li><li><code>dev.ucp.shopping.order</code> - Order tracking and webhooks</li><li><code>dev.ucp.shopping.discount</code> - Promotional discounts (extension)</li><li><code>dev.ucp.shopping.fulfillment</code> - Shipping options (extension)</li><li><code>dev.ucp.shopping.ap2_mandates</code> - Payment auth (extension)</li></ul><p><strong>dev.ucp.common.*</strong> - Cross-domain capabilities</p><ul><li><code>dev.ucp.common.identity_linking</code> - OAuth 2.0 authorization</li></ul><h4>Custom Vendor Namespaces</h4><p>Vendors create capabilities under their reverse-domain:</p><pre><code>// Shopify capabilities\ncom.shopify.payments.installments\ncom.shopify.loyalty.rewards\ncom.shopify.shipping.local_pickup\n\n// PayPal capabilities\ncom.paypal.express.checkout\ncom.paypal.subscription.billing\n\n// Example.com capabilities  \ncom.example.analytics.tracking\ncom.example.returns.rma\n</code></pre><h4>Parsing Utilities</h4><pre><code class=\"language-javascript\">/**\n * Parse a UCP capability namespace\n * @param {string} namespace - Full namespace string\n * @returns {object} Parsed components\n */\nfunction parseNamespace(namespace) {\n  const parts = namespace.split('.');\n  \n  if (parts.length < 3) {\n    throw new Error(`Invalid namespace: ${namespace} (need at least 3 parts)`);\n  }\n  \n  // Last part is capability\n  const capability = parts[parts.length - 1];\n  \n  // Second to last is service\n  const service = parts[parts.length - 2];\n  \n  // Everything before is reverse-domain\n  const reverseDomain = parts.slice(0, -2).join('.');\n  \n  // Convert reverse-domain to normal domain\n  const authority = parts.slice(0, -2).reverse().join('.');\n  \n  return {\n    namespace,\n    reverseDomain,\n    authority,\n    service,\n    capability,\n    // Helper: expected spec origin\n    expectedOrigin: `https://${authority}`\n  };\n}\n\n// Example usage\nconst parsed = parseNamespace('dev.ucp.shopping.checkout');\nconsole.log(parsed);\n/*\n{\n  namespace: 'dev.ucp.shopping.checkout',\n  reverseDomain: 'dev.ucp',\n  authority: 'ucp.dev',\n  service: 'shopping',\n  capability: 'checkout',\n  expectedOrigin: 'https://ucp.dev'\n}\n*/\n\n// Validate a capability's spec URL matches its namespace\nfunction validateSpecURL(capability) {\n  const parsed = parseNamespace(capability.name);\n  const specUrl = new URL(capability.spec);\n  \n  if (!specUrl.origin.startsWith(parsed.expectedOrigin)) {\n    throw new Error(\n      `Spec URL origin mismatch: expected ${parsed.expectedOrigin}, ` +\n      `got ${specUrl.origin}`\n    );\n  }\n  \n  return true;\n}\n\n// Example: validate official UCP capability\nconst ucpCap = {\n  name: 'dev.ucp.shopping.checkout',\n  spec: 'https://ucp.dev/specification/checkout'\n};\nvalidateSpecURL(ucpCap); // ✅ Valid\n\n// Example: detect malicious capability\nconst maliciousCap = {\n  name: 'dev.ucp.shopping.checkout',\n  spec: 'https://evil.com/fake-spec'\n};\ntry {\n  validateSpecURL(maliciousCap); // ❌ Throws error\n} catch (e) {\n  console.error(e.message);\n  // => \"Spec URL origin mismatch: expected https://ucp.dev, got https://evil.com\"\n}\n</code></pre><h4>Version Suffixes (Optional)</h4><p>Capabilities can include version suffixes using <code>@</code>:</p><pre><code>dev.ucp.shopping.checkout@2026-01-11  // Explicit version\ndev.ucp.shopping.checkout             // No version (implies latest)\n</code></pre><p>Version format is ISO date: <code>YYYY-MM-DD</code></p><h4>Naming Rules (RFC)</h4><ul><li><strong>Lowercase only:</strong> <code>dev.ucp</code> not <code>Dev.UCP</code></li><li><strong>Dots as separators:</strong> Between domain parts and components</li><li><strong>Underscores in capability:</strong> OK in final capability name (<code>identity_linking</code>)</li><li><strong>No hyphens:</strong> Use underscores instead</li><li><strong>ASCII only:</strong> No unicode, emojis, or special characters</li></ul><h4>Pattern Matching</h4><pre><code class=\"language-javascript\">// Match all capabilities from a specific authority\nfunction isUCPOfficial(namespace) {\n  return namespace.startsWith('dev.ucp.');\n}\n\n// Match all capabilities in a service\nfunction isShoppingCapability(namespace) {\n  return /^[a-z]+\\.[a-z]+\\.shopping\\./i.test(namespace);\n}\n\n// Extract service name\nfunction getService(namespace) {\n  const parts = namespace.split('.');\n  return parts[parts.length - 2];\n}\n\nconsole.log(getService('dev.ucp.shopping.checkout'));  // => 'shopping'\nconsole.log(getService('com.shopify.loyalty.points')); // => 'loyalty'\n</code></pre><h4>Common Pitfalls</h4><ul><li><strong>Wrong order:</strong> Must be reverse-domain first (<code>dev.ucp</code> not <code>ucp.dev</code>)</li><li><strong>Too few parts:</strong> Need at least 3 parts (reverse-domain.service.capability)</li><li><strong>Using hyphens:</strong> Use underscores in capability names, not hyphens</li><li><strong>Uppercase letters:</strong> All lowercase required</li><li><strong>Not validating origin:</strong> Always check spec URL matches namespace authority</li></ul>",
          "resources": [
            {
              "type": "spec",
              "url": "https://ucp.dev/specification/overview/#namespace-governance",
              "label": "Namespace Governance Spec"
            },
            {
              "type": "doc",
              "url": "https://ucp.dev/documentation/core-concepts/",
              "label": "Core Concepts"
            }
          ]
        }
      ]
    },
    {
      "id": "shopping-domain",
      "label": "3. Core Shopping Domain",
      "description": "Main commerce primitives and schemas",
      "content": "<h3>Shopping Domain Overview</h3><p>The shopping domain contains the core schemas for commerce transactions.</p>",
      "children": [
        {
          "id": "checkout-schema",
          "label": "Checkout Schema",
          "description": "Central state object for transactions",
          "content": "<h3>The Checkout Object</h3><p>The checkout schema (<code>dev.ucp.shopping.checkout</code>) is the central state object in UCP, flowing through the entire purchase lifecycle. It represents a shopping cart progressing toward an order.</p><h4>Core Fields (Required)</h4><table><tr><th>Field</th><th>Type</th><th>Description</th></tr><tr><td><code>id</code></td><td>string</td><td>Unique checkout session identifier</td></tr><tr><td><code>line_items[]</code></td><td>array</td><td>Cart items with SKU, quantity, price</td></tr><tr><td><code>status</code></td><td>enum</td><td>Checkout state (incomplete, ready_for_complete, completed, etc.)</td></tr><tr><td><code>currency</code></td><td>string</td><td>ISO 4217 code (USD, EUR, GBP)</td></tr><tr><td><code>totals[]</code></td><td>array</td><td>Price breakdown (subtotal, tax, shipping, total)</td></tr><tr><td><code>payment</code></td><td>object</td><td>Payment handlers and selected instruments</td></tr><tr><td><code>links[]</code></td><td>array</td><td>HATEOAS links (continue_url, cancel_url)</td></tr></table><h4>Optional Fields</h4><ul><li><code>buyer</code> - Customer email, name, phone</li><li><code>messages[]</code> - Errors, warnings, info messages</li><li><code>metadata</code> - Business-specific data</li><li><code>fulfillment</code> - Shipping options/addresses (if extension supported)</li><li><code>discount</code> - Applied promotions (if extension supported)</li></ul><h4>Checkout Status Lifecycle</h4><pre><code>incomplete → (gather info via updates) → ready_for_complete → complete_in_progress → completed\n      ↓                                                                    ↓\nrequires_escalation (buyer handoff)                                  canceled\n</code></pre><p><strong>Status Values:</strong></p><ul><li><code>incomplete</code> - Missing required data, check <code>messages[]</code> for what's needed</li><li><code>requires_escalation</code> - Needs buyer handoff via <code>continue_url</code> link</li><li><code>ready_for_complete</code> - All data collected, platform can call complete</li><li><code>complete_in_progress</code> - Business processing order</li><li><code>completed</code> - Order placed successfully</li><li><code>canceled</code> - Session expired or invalidated</li></ul><h4>Complete Checkout Lifecycle Example</h4><pre><code class=\"language-javascript\">// Step 1: CREATE checkout with initial items\nconst createReq = {\n  line_items: [\n    {\n      sku: 'WIDGET-123',\n      quantity: 2,\n      title: 'Blue Widget',\n      price: 2999  // $29.99 in cents (minor units)\n    }\n  ],\n  currency: 'USD',\n  buyer: {\n    email: 'user@example.com',\n    first_name: 'Jane',\n    last_name: 'Doe'\n  }\n};\n\nconst createResp = await fetch('https://shop.example.com/api/ucp/checkout/create', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify(createReq)\n});\n\nconst checkout = await createResp.json();\nconsole.log('Checkout created:', checkout.id);\nconsole.log('Status:', checkout.status);  // => 'incomplete'\n\n/*\nResponse structure:\n{\n  \"id\": \"chk_abc123\",\n  \"status\": \"incomplete\",\n  \"line_items\": [...],\n  \"currency\": \"USD\",\n  \"totals\": [\n    { \"type\": \"subtotal\", \"amount\": 5998 },\n    { \"type\": \"tax\", \"amount\": 0 },\n    { \"type\": \"total\", \"amount\": 5998 }\n  ],\n  \"payment\": {\n    \"handlers\": [  // How to collect payment\n      {\n        \"type\": \"google_pay\",\n        \"url\": \"https://shop.example.com/payment/google-pay\"\n      }\n    ],\n    \"instruments\": []  // Empty - no payment collected yet\n  },\n  \"messages\": [\n    {\n      \"type\": \"info\",\n      \"message\": \"Payment method required\"\n    }\n  ],\n  \"links\": [\n    {\n      \"rel\": \"continue\",\n      \"href\": \"https://shop.example.com/checkout/chk_abc123\"\n    }\n  ]\n}\n*/\n\n// Step 2: UPDATE with payment instrument\nconst updateReq = {\n  id: checkout.id,\n  payment: {\n    instruments: [\n      {\n        type: 'card_payment_instrument',\n        token: 'tok_google_pay_xyz789',  // From Credential Provider\n        provider: 'google_pay',\n        last4: '4242',\n        brand: 'visa'\n      }\n    ]\n  }\n};\n\nconst updateResp = await fetch('https://shop.example.com/api/ucp/checkout/update', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify(updateReq)\n});\n\nconst updated = await updateResp.json();\nconsole.log('Status:', updated.status);  // => 'ready_for_complete'\n\n// Step 3: COMPLETE checkout\nif (updated.status === 'ready_for_complete') {\n  const completeReq = {\n    id: checkout.id\n  };\n  \n  const completeResp = await fetch('https://shop.example.com/api/ucp/checkout/complete', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(completeReq)\n  });\n  \n  const final = await completeResp.json();\n  console.log('Status:', final.status);  // => 'completed'\n  console.log('Order ID:', final.order_id);  // Business's order ID\n  \n  /*\n  Completed response:\n  {\n    \"id\": \"chk_abc123\",\n    \"status\": \"completed\",\n    \"order_id\": \"ORDER-2026-001\",\n    \"line_items\": [...],\n    \"totals\": [\n      { \"type\": \"subtotal\", \"amount\": 5998 },\n      { \"type\": \"tax\", \"amount\": 479 },\n      { \"type\": \"shipping\", \"amount\": 500 },\n      { \"type\": \"total\", \"amount\": 6977 }\n    ],\n    \"payment\": {\n      \"status\": \"authorized\",\n      \"instruments\": [...]\n    },\n    \"links\": [\n      {\n        \"rel\": \"order\",\n        \"href\": \"https://shop.example.com/orders/ORDER-2026-001\"\n      }\n    ]\n  }\n  */\n}\n</code></pre><h4>Handling Checkout Messages</h4><pre><code class=\"language-javascript\">// Check messages for errors/warnings\nfunction handleCheckoutMessages(checkout) {\n  if (!checkout.messages || checkout.messages.length === 0) {\n    return;\n  }\n  \n  checkout.messages.forEach(msg => {\n    switch (msg.type) {\n      case 'error':\n        console.error('❌ Error:', msg.message);\n        // Show error to user\n        break;\n      case 'warning':\n        console.warn('⚠️  Warning:', msg.message);\n        break;\n      case 'info':\n        console.log('ℹ️  Info:', msg.message);\n        break;\n    }\n  });\n}\n\n// Example messages\nconst messages = [\n  {\n    type: 'error',\n    code: 'invalid_payment',\n    message: 'Payment instrument declined'\n  },\n  {\n    type: 'warning',\n    code: 'low_inventory',\n    message: 'Only 2 items remaining in stock'\n  },\n  {\n    type: 'info',\n    message: 'Free shipping on orders over $50'\n  }\n];\n</code></pre><h4>Totals Array Structure</h4><pre><code class=\"language-javascript\">// Totals show price breakdown\nconst totals = [\n  { type: 'subtotal', amount: 5998, label: 'Subtotal' },\n  { type: 'tax', amount: 479, label: 'Sales Tax (8%)' },\n  { type: 'shipping', amount: 500, label: 'Standard Shipping' },\n  { type: 'discount', amount: -1000, label: 'Coupon: SAVE10' },  // If discount extension\n  { type: 'total', amount: 5977, label: 'Total' }\n];\n\n// Amounts are always in minor units (cents for USD)\n// To display: amount / 100\nconsole.log('Total: $' + (5977 / 100).toFixed(2));  // => \"Total: $59.77\"\n</code></pre><h4>Common Pitfalls</h4><ul><li><strong>Forgetting minor units:</strong> Amounts are in cents (5998 = $59.98), not dollars</li><li><strong>Ignoring status:</strong> Always check <code>status</code> before calling complete</li><li><strong>Not reading messages:</strong> <code>messages[]</code> explains errors - don't ignore them</li><li><strong>Modifying read-only fields:</strong> <code>status</code>, <code>totals</code>, <code>ucp</code> are set by business, not platform</li><li><strong>Missing required fields:</strong> <code>line_items</code>, <code>currency</code>, <code>payment</code> are required</li></ul>",
          "resources": [
            {
              "type": "spec",
              "url": "https://ucp.dev/specification/checkout/",
              "label": "Checkout Capability Specification"
            },
            {
              "type": "schema",
              "url": "https://ucp.dev/schemas/shopping/checkout.json",
              "label": "Checkout Schema (JSON)"
            }
          ]
        },
        {
          "id": "payment-schema",
          "label": "Payment Schema",
          "description": "Payment instruments and methods",
          "content": "<h3>Payment Structure</h3><p>UCP uses payment handlers to define how platforms collect payment instruments. The checkout object contains <code>payment.handlers[]</code> (instructions from business) and <code>payment.instruments[]</code> (collected by platform).</p><h4>Core Payment Concepts</h4><ul><li><strong>Payment Handler</strong> - Instructions for how to collect payment (e.g., Google Pay configuration)</li><li><strong>Payment Instrument</strong> - Collected payment method with display info (last4, brand, expiry)</li><li><strong>Payment Credential</strong> - Actual payment data (token, encrypted card) inside instrument</li></ul><h4>Payment Handler Structure</h4><p>Businesses declare supported payment handlers in checkout responses:</p><pre><code class=\"language-json\">{\n  \"payment\": {\n    \"handlers\": [\n      {\n        \"id\": \"gpay_handler_1\",\n        \"name\": \"com.google.pay\",\n        \"version\": \"2026-01-11\",\n        \"spec\": \"https://ucp.dev/handlers/google-pay\",\n        \"config_schema\": \"https://ucp.dev/handlers/google-pay/config.json\",\n        \"instrument_schemas\": [\n          \"https://ucp.dev/handlers/google-pay/instrument.json\"\n        ],\n        \"config\": {\n          \"merchant_id\": \"BCR2DN6TW3QFC4ZU\",\n          \"merchant_name\": \"Example Store\",\n          \"gateway\": \"stripe\",\n          \"gateway_merchant_id\": \"acct_1234567890\",\n          \"allowed_card_networks\": [\"VISA\", \"MASTERCARD\", \"AMEX\"],\n          \"environment\": \"PRODUCTION\"\n        }\n      }\n    ],\n    \"instruments\": []  // Populated by platform after collection\n  }\n}\n</code></pre><h4>Payment Instrument with Tokenization</h4><p>After the platform collects payment via handler, it sends the instrument back in checkout update:</p><pre><code class=\"language-javascript\">// Platform collects Google Pay token from buyer\nconst googlePayToken = await collectGooglePay(handler.config);\n\n// Platform creates payment instrument\nconst instrument = {\n  id: 'inst_gpay_123',\n  handler_id: 'gpay_handler_1',  // References handler from business\n  type: 'card',\n  brand: 'visa',\n  last_digits: '4242',\n  expiry_month: 12,\n  expiry_year: 2026,\n  \n  // Credential contains tokenized payment data\n  credential: {\n    type: 'token',\n    token: googlePayToken  // Encrypted token from Google\n  },\n  \n  billing_address: {\n    street_address: '123 Main St',\n    address_locality: 'Austin',\n    address_region: 'TX',\n    postal_code: '78701',\n    address_country: 'US'\n  }\n};\n\n// Update checkout with collected instrument\nconst updateReq = {\n  id: checkout.id,\n  payment: {\n    instruments: [instrument]\n  }\n};\n\nawait fetch('https://shop.example.com/api/ucp/checkout/update', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify(updateReq)\n});\n</code></pre><h4>Complete Google Pay Example</h4><pre><code class=\"language-javascript\">// Step 1: Platform receives handler config from business\nconst checkout = await createCheckout();\nconst googlePayHandler = checkout.payment.handlers.find(\n  h => h.name === 'com.google.pay'\n);\n\nif (!googlePayHandler) {\n  console.error('Google Pay not supported');\n  return;\n}\n\n// Step 2: Platform initializes Google Pay with business config\nconst paymentsClient = new google.payments.api.PaymentsClient({\n  environment: googlePayHandler.config.environment  // 'TEST' or 'PRODUCTION'\n});\n\nconst paymentDataRequest = {\n  apiVersion: 2,\n  apiVersionMinor: 0,\n  allowedPaymentMethods: [{\n    type: 'CARD',\n    parameters: {\n      allowedAuthMethods: ['PAN_ONLY', 'CRYPTOGRAM_3DS'],\n      allowedCardNetworks: googlePayHandler.config.allowed_card_networks\n    },\n    tokenizationSpecification: {\n      type: 'PAYMENT_GATEWAY',\n      parameters: {\n        gateway: googlePayHandler.config.gateway,\n        gatewayMerchantId: googlePayHandler.config.gateway_merchant_id\n      }\n    }\n  }],\n  merchantInfo: {\n    merchantId: googlePayHandler.config.merchant_id,\n    merchantName: googlePayHandler.config.merchant_name\n  },\n  transactionInfo: {\n    totalPriceStatus: 'FINAL',\n    totalPrice: (checkout.totals.find(t => t.type === 'total').amount / 100).toFixed(2),\n    currencyCode: checkout.currency\n  }\n};\n\n// Step 3: Collect payment from buyer\nconst paymentData = await paymentsClient.loadPaymentData(paymentDataRequest);\nconst token = paymentData.paymentMethodData.tokenizationData.token;\n\n// Step 4: Create instrument with token credential\nconst instrument = {\n  id: 'inst_gpay_' + Date.now(),\n  handler_id: googlePayHandler.id,\n  type: 'card',\n  brand: paymentData.paymentMethodData.info.cardNetwork.toLowerCase(),\n  last_digits: paymentData.paymentMethodData.info.cardDetails.slice(-4),\n  credential: {\n    type: 'token',\n    token: token  // Google Pay token - business forwards to PSP\n  },\n  billing_address: {\n    street_address: paymentData.paymentMethodData.info.billingAddress.address1,\n    address_locality: paymentData.paymentMethodData.info.billingAddress.locality,\n    address_region: paymentData.paymentMethodData.info.billingAddress.administrativeArea,\n    postal_code: paymentData.paymentMethodData.info.billingAddress.postalCode,\n    address_country: paymentData.paymentMethodData.info.billingAddress.countryCode\n  }\n};\n\n// Step 5: Update checkout with instrument\nawait updateCheckoutWithPayment(checkout.id, instrument);\n</code></pre><h4>Token Credential Flow</h4><p>The token credential moves through the system without exposing raw card data:</p><pre><code>1. Buyer provides card to Google Pay (outside UCP)\n2. Google Pay generates encrypted token\n3. Platform receives token, creates instrument with token credential\n4. Platform sends instrument to Business in checkout update\n5. Business forwards token to PSP (Stripe, Adyen, etc.)\n6. PSP exchanges token with Google for actual card data\n7. PSP processes payment with card networks\n</code></pre><p>This flow keeps raw card data out of Platform and Business systems, minimizing PCI-DSS compliance scope.</p><h4>Credential Types</h4><table><tr><th>Type</th><th>Use Case</th><th>Example</th></tr><tr><td><code>token</code></td><td>Tokenized payment (Google Pay, Apple Pay)</td><td><code>{\"type\": \"token\", \"token\": \"tok_gpay_xyz\"}</code></td></tr><tr><td><code>card</code></td><td>Raw card data (rarely used - PCI scope)</td><td><code>{\"type\": \"card\", \"number\": \"4111...\", \"cvc\": \"123\"}</code></td></tr></table><h4>Common Pitfalls</h4><ul><li><strong>Missing handler_id:</strong> Instrument must reference which handler produced it via <code>handler_id</code></li><li><strong>Exposing token in response:</strong> Token credential has <code>\"ucp_response\": \"omit\"</code> - business never sends token back to platform</li><li><strong>Wrong handler config:</strong> Must use exact config from business handler declaration, don't modify values</li><li><strong>Forgetting binding:</strong> When using tokenization handlers, include <code>checkout_id</code> in binding to prevent token reuse</li><li><strong>Not validating handler:</strong> Always check <code>handler.name</code> and <code>handler.version</code> match what platform supports</li></ul>",
          "resources": [
            {
              "type": "spec",
              "url": "https://ucp.dev/specification/checkout/#payment-handler-response",
              "label": "Payment Handler Specification"
            },
            {
              "type": "spec",
              "url": "https://ucp.dev/specification/tokenization-guide/",
              "label": "Tokenization Guide"
            },
            {
              "type": "schema",
              "url": "https://ucp.dev/schemas/shopping/types/payment_handler.json",
              "label": "Payment Handler Schema"
            },
            {
              "type": "schema",
              "url": "https://ucp.dev/schemas/shopping/types/payment_instrument.json",
              "label": "Payment Instrument Schema"
            },
            {
              "type": "schema",
              "url": "https://ucp.dev/schemas/shopping/types/token_credential.json",
              "label": "Token Credential Schema"
            }
          ]
        },
        {
          "id": "fulfillment-schema",
          "label": "Fulfillment Schema",
          "description": "Shipping and delivery",
          "content": "<h3>Fulfillment System</h3><p>The fulfillment extension (<code>dev.ucp.shopping.fulfillment</code>) enables shipping, pickup, and delivery options. It structures fulfillment as:</p><ul><li><strong>Methods</strong> - Fulfillment types (shipping, pickup) with destinations</li><li><strong>Groups</strong> - Packages within a method (items grouped for fulfillment)</li><li><strong>Options</strong> - Selectable choices per group (Standard vs Express shipping)</li></ul><h4>Core Structure</h4><pre><code class=\"language-json\">{\n  \"fulfillment\": {\n    \"methods\": [\n      {\n        \"id\": \"method_1\",\n        \"type\": \"shipping\",\n        \"line_item_ids\": [\"shirt\", \"pants\"],\n        \"selected_destination_id\": \"dest_1\",\n        \"destinations\": [{\n          \"id\": \"dest_1\",\n          \"street_address\": \"123 Main St\",\n          \"address_locality\": \"Austin\",\n          \"address_region\": \"TX\",\n          \"postal_code\": \"78701\",\n          \"address_country\": \"US\"\n        }],\n        \"groups\": [\n          {\n            \"id\": \"package_1\",\n            \"line_item_ids\": [\"shirt\", \"pants\"],\n            \"selected_option_id\": \"standard\",\n            \"options\": [\n              {\n                \"id\": \"standard\",\n                \"title\": \"Standard Shipping\",\n                \"description\": \"Arrives Dec 12-15 via USPS\",\n                \"totals\": [{\"type\": \"total\", \"amount\": 500}]\n              },\n              {\n                \"id\": \"express\",\n                \"title\": \"Express Shipping\",\n                \"description\": \"Arrives Dec 10-11 via FedEx\",\n                \"totals\": [{\"type\": \"total\", \"amount\": 1000}]\n              }\n            ]\n          }\n        ]\n      }\n    ]\n  }\n}\n</code></pre><h4>Selecting Shipping Options</h4><pre><code class=\"language-javascript\">// Step 1: Platform receives fulfillment options from business\nconst checkout = await createCheckout({\n  line_items: [\n    { sku: 'SHIRT-001', quantity: 1 },\n    { sku: 'PANTS-001', quantity: 1 }\n  ],\n  currency: 'USD'\n});\n\n// Business returns fulfillment structure\nconst method = checkout.fulfillment.methods[0];\nconst group = method.groups[0];\n\nconsole.log('Available shipping options:');\ngroup.options.forEach(opt => {\n  console.log(`${opt.id}: ${opt.title} - $${opt.totals[0].amount / 100}`);\n  console.log(`  ${opt.description}`);\n});\n\n// Output:\n// standard: Standard Shipping - $5.00\n//   Arrives Dec 12-15 via USPS\n// express: Express Shipping - $10.00\n//   Arrives Dec 10-11 via FedEx\n\n// Step 2: Buyer selects express shipping\nconst updatedGroup = {\n  ...group,\n  selected_option_id: 'express'\n};\n\nconst updatedMethod = {\n  ...method,\n  groups: [updatedGroup]\n};\n\n// Step 3: Update checkout with selection\nconst updateReq = {\n  id: checkout.id,\n  fulfillment: {\n    methods: [updatedMethod]\n  }\n};\n\nconst updated = await fetch('https://shop.example.com/api/ucp/checkout/update', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify(updateReq)\n});\n\nconst result = await updated.json();\n\n// Business recalculates totals with new shipping cost\nconsole.log('Updated total:', result.totals.find(t => t.type === 'total').amount);\n</code></pre><h4>Multi-Group Fulfillment (Split Shipments)</h4><p>When platform supports <code>supports_multi_group: true</code>, business can split items into multiple packages:</p><pre><code class=\"language-javascript\">// Platform declares multi-group support in profile\nconst platformProfile = {\n  capabilities: [{\n    name: 'dev.ucp.shopping.fulfillment',\n    version: '2026-01-11',\n    config: {\n      supports_multi_group: true\n    }\n  }]\n};\n\n// Business returns split packages from different warehouses\nconst checkout = {\n  fulfillment: {\n    methods: [{\n      id: 'method_1',\n      type: 'shipping',\n      line_item_ids: ['shirt', 'pants'],\n      selected_destination_id: 'dest_1',\n      destinations: [{...}],\n      \n      // Two separate packages\n      groups: [\n        {\n          id: 'package_1',\n          line_item_ids: ['shirt'],  // Ships from Warehouse A\n          selected_option_id: 'standard',\n          options: [\n            {\n              id: 'standard',\n              title: 'Standard',\n              description: 'Ships from TX, arrives Dec 12-15',\n              totals: [{type: 'total', amount: 500}]\n            },\n            {\n              id: 'express',\n              title: 'Express',\n              description: 'Ships from TX, arrives Dec 10-11',\n              totals: [{type: 'total', amount: 1000}]\n            }\n          ]\n        },\n        {\n          id: 'package_2',\n          line_item_ids: ['pants'],  // Ships from Warehouse B\n          selected_option_id: 'express',\n          options: [\n            {\n              id: 'standard',\n              title: 'Standard',\n              description: 'Ships from CA, arrives Dec 14-17',\n              totals: [{type: 'total', amount: 600}]\n            },\n            {\n              id: 'express',\n              title: 'Express',\n              description: 'Ships from CA, arrives Dec 11-12',\n              totals: [{type: 'total', amount: 1200}]\n            }\n          ]\n        }\n      ]\n    }]\n  }\n};\n\n// Buyer can select different shipping speed per package\nfunction selectShippingPerPackage(method) {\n  return {\n    ...method,\n    groups: method.groups.map(group => ({\n      ...group,\n      // User selects standard for package 1, express for package 2\n      selected_option_id: group.id === 'package_1' ? 'standard' : 'express'\n    }))\n  };\n}\n\nconst updated = selectShippingPerPackage(checkout.fulfillment.methods[0]);\n\n// Total shipping: $5 (package 1 standard) + $12 (package 2 express) = $17\n</code></pre><h4>Multi-Destination Example (Split Shipping)</h4><p>When business supports <code>allows_multi_destination.shipping: true</code>, items can ship to different addresses:</p><pre><code class=\"language-javascript\">// Business declares multi-destination support in profile\nconst businessProfile = {\n  capabilities: [{\n    name: 'dev.ucp.shopping.fulfillment',\n    version: '2026-01-11',\n    config: {\n      allows_multi_destination: {\n        shipping: true\n      }\n    }\n  }]\n};\n\n// Platform creates checkout with items for two recipients\nconst checkout = {\n  line_items: [\n    { id: 'shirt', sku: 'SHIRT-001', quantity: 1 },  // Gift for Mom\n    { id: 'pants', sku: 'PANTS-001', quantity: 1 }   // Gift for Grandma\n  ],\n  fulfillment: {\n    methods: [\n      {\n        id: 'method_1',\n        type: 'shipping',\n        line_item_ids: ['shirt'],\n        selected_destination_id: 'dest_mom',\n        destinations: [\n          {\n            id: 'dest_mom',\n            street_address: '123 Mom St',\n            address_locality: 'Austin',\n            address_region: 'TX',\n            postal_code: '78701',\n            address_country: 'US'\n          }\n        ],\n        groups: [{\n          id: 'package_1',\n          line_item_ids: ['shirt'],\n          selected_option_id: 'standard',\n          options: [\n            {id: 'standard', title: 'Standard', totals: [{type: 'total', amount: 500}]},\n            {id: 'express', title: 'Express', totals: [{type: 'total', amount: 1000}]}\n          ]\n        }]\n      },\n      {\n        id: 'method_2',\n        type: 'shipping',\n        line_item_ids: ['pants'],\n        selected_destination_id: 'dest_grandma',\n        destinations: [\n          {\n            id: 'dest_grandma',\n            street_address: '88 Queensway',\n            address_locality: 'Hong Kong',\n            address_country: 'HK'\n          }\n        ],\n        groups: [{\n          id: 'package_2',\n          line_item_ids: ['pants'],\n          selected_option_id: 'standard',\n          options: [\n            {id: 'standard', title: 'International Standard', totals: [{type: 'total', amount: 2500}]},\n            {id: 'express', title: 'International Express', totals: [{type: 'total', amount: 4500}]}\n          ]\n        }]\n      }\n    ]\n  }\n};\n\n// Two separate shipments, each with own destination\nconsole.log('Shirt ships to:', checkout.fulfillment.methods[0].destinations[0].address_locality);\n// => \"Austin\"\nconsole.log('Pants ship to:', checkout.fulfillment.methods[1].destinations[0].address_locality);\n// => \"Hong Kong\"\n</code></pre><h4>Rendering Fulfillment Options</h4><p>Platforms render options using provided human-readable fields:</p><pre><code class=\"language-javascript\">function renderFulfillmentOptions(group) {\n  return group.options.map(option => {\n    const price = option.totals.find(t => t.type === 'total').amount;\n    \n    return {\n      id: option.id,\n      selected: option.id === group.selected_option_id,\n      // Use business-provided strings directly\n      title: option.title,\n      description: option.description,\n      price: `$${(price / 100).toFixed(2)}`,\n      // Platform displays verbatim - no interpretation needed\n      displayText: `${option.title} - $${(price / 100).toFixed(2)}`,\n      displaySubtext: option.description\n    };\n  });\n}\n\n// Example output for UI:\n// ○ Standard Shipping - $5.00\n//   Arrives Dec 12-15 via USPS\n// ● Express Shipping - $10.00  ← selected\n//   Arrives Dec 10-11 via FedEx\n</code></pre><h4>Common Pitfalls</h4><ul><li><strong>Mixing up groups and options:</strong> Groups are packages, options are choices per package (Standard vs Express)</li><li><strong>Not checking supports_multi_group:</strong> If platform doesn't support it, business consolidates into single group per method</li><li><strong>Assuming method types:</strong> Use <code>title</code> and <code>description</code> for rendering, not hardcoded type-specific UI</li><li><strong>Forgetting selected_option_id:</strong> Must specify which option is selected when updating</li><li><strong>Not preserving full structure:</strong> Update operations require full replacement - send entire fulfillment object back</li><li><strong>Ignoring available_methods:</strong> Check this array for alternative fulfillment options (e.g., pickup alternatives)</li></ul>",
          "resources": [
            {
              "type": "spec",
              "url": "https://ucp.dev/specification/fulfillment/",
              "label": "Fulfillment Extension Specification"
            },
            {
              "type": "schema",
              "url": "https://ucp.dev/schemas/shopping/fulfillment.json",
              "label": "Fulfillment Schema"
            }
          ]
        },
        {
          "id": "order-schema",
          "label": "Order Schema",
          "description": "Post-purchase order tracking",
          "content": "<h3>Order Lifecycle</h3><p>After checkout completes, the order object tracks post-purchase events. Orders are immutable records with append-only event logs for fulfillment and adjustments.</p><h4>Order Structure</h4><pre><code class=\"language-json\">{\n  \"ucp\": {\n    \"version\": \"2026-01-11\",\n    \"capabilities\": [{\"name\": \"dev.ucp.shopping.order\", \"version\": \"2026-01-11\"}]\n  },\n  \"id\": \"order_abc123\",\n  \"checkout_id\": \"checkout_xyz789\",\n  \"permalink_url\": \"https://business.com/orders/abc123\",\n  \"line_items\": [\n    {\n      \"id\": \"li_shoes\",\n      \"item\": {\"id\": \"prod_shoes\", \"title\": \"Running Shoes\", \"price\": 3000},\n      \"quantity\": {\"total\": 3, \"fulfilled\": 2},\n      \"status\": \"partial\"\n    }\n  ],\n  \"fulfillment\": {\n    \"expectations\": [{...}],  // Current buyer-facing promises\n    \"events\": [{...}]         // Append-only log of what happened\n  },\n  \"adjustments\": [{...}],     // Refunds, returns, etc.\n  \"totals\": [{\"type\": \"total\", \"amount\": 15342}]\n}\n</code></pre><h4>Webhook Configuration</h4><p>Platform provides webhook URL in capability config during negotiation:</p><pre><code class=\"language-javascript\">// Platform's UCP profile declares order capability with webhook endpoint\nconst platformProfile = {\n  capabilities: [\n    {\n      name: 'dev.ucp.shopping.order',\n      version: '2026-01-11',\n      config: {\n        webhook_url: 'https://platform.example.com/webhooks/ucp/orders'\n      }\n    }\n  ],\n  signing_keys: [\n    {\n      kty: 'RSA',\n      kid: 'platform-2026-01',\n      use: 'sig',\n      n: '0vx7agoebG...',\n      e: 'AQAB'\n    }\n  ]\n};\n\n// Business discovers webhook URL from platform profile\nconst orderConfig = platformProfile.capabilities.find(\n  c => c.name === 'dev.ucp.shopping.order'\n).config;\n\nconst webhookUrl = orderConfig.webhook_url;\nconsole.log('Send order events to:', webhookUrl);\n// => https://platform.example.com/webhooks/ucp/orders\n</code></pre><h4>Sending Order Event Webhooks</h4><p>Business sends order lifecycle events to platform's webhook URL with signature:</p><pre><code class=\"language-javascript\">const jose = require('jose');  // JWT library\n\n/**\n * Send order event webhook with JWT signature\n */\nasync function sendOrderEventWebhook(platformWebhookUrl, orderEvent, signingKey) {\n  // Step 1: Prepare order event payload\n  const payload = JSON.stringify({\n    ucp: {\n      version: '2026-01-11',\n      capabilities: [\n        {name: 'dev.ucp.shopping.order', version: '2026-01-11'}\n      ]\n    },\n    event_type: 'order.updated',\n    occurred_at: new Date().toISOString(),\n    order: orderEvent  // Full order object\n  });\n\n  // Step 2: Create detached JWT signature (RFC 7797)\n  // The signature covers the entire request body\n  const privateKey = await jose.importJWK(signingKey, 'RS256');\n  \n  const jwt = await new jose.CompactSign(\n    new TextEncoder().encode(payload)\n  )\n    .setProtectedHeader({\n      alg: 'RS256',\n      kid: signingKey.kid,  // Key ID for verification\n      b64: false,           // Detached payload (RFC 7797)\n      crit: ['b64']\n    })\n    .sign(privateKey);\n\n  // Step 3: POST to platform webhook with signature header\n  const response = await fetch(platformWebhookUrl, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'Request-Signature': jwt,  // Detached JWT signature\n      'X-Business-Id': 'business_12345'  // Business identifier\n    },\n    body: payload\n  });\n\n  if (!response.ok) {\n    throw new Error(`Webhook delivery failed: ${response.status}`);\n  }\n\n  return response;\n}\n\n// Example: Send order shipped event\nconst orderEvent = {\n  id: 'order_abc123',\n  checkout_id: 'checkout_xyz789',\n  permalink_url: 'https://business.com/orders/abc123',\n  line_items: [...],\n  fulfillment: {\n    expectations: [...],\n    events: [\n      {\n        id: 'evt_1',\n        occurred_at: '2025-01-08T10:30:00Z',\n        type: 'shipped',\n        line_items: [{id: 'li_shoes', quantity: 3}],\n        tracking_number: '123456789',\n        tracking_url: 'https://fedex.com/track/123456789',\n        description: 'Shipped via FedEx'\n      }\n    ]\n  },\n  totals: [...]\n};\n\nconst businessSigningKey = {\n  kty: 'RSA',\n  kid: 'business-2026-01',\n  use: 'sig',\n  d: 'private_key_data...',  // Private key\n  n: '0vx7agoebG...',\n  e: 'AQAB'\n};\n\nawait sendOrderEventWebhook(\n  'https://platform.example.com/webhooks/ucp/orders',\n  orderEvent,\n  businessSigningKey\n);\n</code></pre><h4>Verifying Webhook Signatures (Platform)</h4><p>Platform verifies webhook authenticity using business's public key:</p><pre><code class=\"language-javascript\">const jose = require('jose');\n\n/**\n * Verify webhook signature and extract order event\n */\nasync function verifyOrderWebhook(request) {\n  // Step 1: Extract signature header\n  const signature = request.headers['request-signature'];\n  if (!signature) {\n    throw new Error('Missing Request-Signature header');\n  }\n\n  // Step 2: Parse JWT header to get key ID\n  const jwtParts = signature.split('.');\n  const header = JSON.parse(\n    Buffer.from(jwtParts[0], 'base64').toString('utf8')\n  );\n  const kid = header.kid;\n\n  if (!kid) {\n    throw new Error('Missing kid in JWT header');\n  }\n\n  // Step 3: Fetch business's UCP profile (cache this!)\n  const businessId = request.headers['x-business-id'];\n  const profile = await fetchBusinessProfile(businessId);\n  \n  // Step 4: Find matching signing key\n  const publicKey = profile.signing_keys.find(k => k.kid === kid);\n  if (!publicKey) {\n    throw new Error(`Unknown signing key: ${kid}`);\n  }\n\n  // Step 5: Verify JWT signature against request body\n  const requestBody = await request.text();\n  \n  try {\n    const jwk = await jose.importJWK(publicKey, 'RS256');\n    \n    // Verify detached signature (RFC 7797)\n    const verified = await jose.compactVerify(\n      signature,\n      jwk,\n      {\n        detached: Buffer.from(requestBody)\n      }\n    );\n    \n    console.log('✅ Signature verified');\n    \n    // Step 6: Parse and return order event\n    return JSON.parse(requestBody);\n    \n  } catch (error) {\n    console.error('❌ Signature verification failed:', error);\n    throw new Error('Invalid webhook signature');\n  }\n}\n\n// Express.js webhook endpoint\napp.post('/webhooks/ucp/orders', async (req, res) => {\n  try {\n    // Verify signature and extract order\n    const orderEvent = await verifyOrderWebhook(req);\n    \n    // Respond quickly (2xx) - process asynchronously\n    res.status(200).json({received: true});\n    \n    // Process order event asynchronously\n    processOrderEventAsync(orderEvent).catch(err => {\n      console.error('Error processing order event:', err);\n    });\n    \n  } catch (error) {\n    console.error('Webhook verification failed:', error);\n    res.status(401).json({error: 'Signature verification failed'});\n  }\n});\n\n// Async processing after webhook response\nasync function processOrderEventAsync(orderEvent) {\n  const order = orderEvent.order;\n  \n  // Update local database\n  await db.orders.update(order.id, {\n    status: order.line_items[0].status,\n    fulfillment_events: order.fulfillment.events,\n    updated_at: orderEvent.occurred_at\n  });\n  \n  // Notify buyer\n  if (orderEvent.event_type === 'order.updated') {\n    const latestEvent = order.fulfillment.events[order.fulfillment.events.length - 1];\n    \n    if (latestEvent.type === 'shipped') {\n      await sendEmail(order.buyer.email, {\n        subject: 'Your order has shipped!',\n        body: `Tracking: ${latestEvent.tracking_url}`\n      });\n    }\n  }\n  \n  console.log(`Processed order event: ${order.id}`);\n}\n</code></pre><h4>Common Order Event Types</h4><pre><code class=\"language-javascript\">// Fulfillment events (append-only log)\nconst fulfillmentEvents = [\n  {\n    type: 'processing',\n    description: 'Order received, preparing for shipment'\n  },\n  {\n    type: 'shipped',\n    tracking_number: '123456789',\n    tracking_url: 'https://fedex.com/track/123456789',\n    description: 'Shipped via FedEx'\n  },\n  {\n    type: 'in_transit',\n    description: 'Package in transit to destination'\n  },\n  {\n    type: 'delivered',\n    description: 'Delivered to front door'\n  },\n  {\n    type: 'failed_attempt',\n    description: 'Delivery attempted, recipient not available'\n  }\n];\n\n// Adjustment events (refunds, returns, etc.)\nconst adjustments = [\n  {\n    type: 'refund',\n    status: 'completed',\n    amount: 3000,\n    line_items: [{id: 'li_shoes', quantity: 1}],\n    description: 'Defective item refund'\n  },\n  {\n    type: 'return',\n    status: 'pending',\n    line_items: [{id: 'li_shoes', quantity: 1}],\n    description: 'Return initiated by buyer'\n  },\n  {\n    type: 'cancellation',\n    status: 'completed',\n    amount: 15342,\n    description: 'Order cancelled before shipment'\n  }\n];\n</code></pre><h4>Key Rotation Example</h4><pre><code class=\"language-javascript\">// Business publishes multiple keys in profile for zero-downtime rotation\nconst businessProfile = {\n  signing_keys: [\n    {\n      kty: 'RSA',\n      kid: 'business-2026-01',  // Current key\n      use: 'sig',\n      n: 'current_key_n...',\n      e: 'AQAB'\n    },\n    {\n      kty: 'RSA',\n      kid: 'business-2025-12',  // Old key (still valid for in-flight webhooks)\n      use: 'sig',\n      n: 'old_key_n...',\n      e: 'AQAB'\n    }\n  ]\n};\n\n// Rotation process:\n// 1. Add new key to signing_keys array\n// 2. Start signing new webhooks with new key (kid: 'business-2026-01')\n// 3. Wait for all in-flight webhooks with old key to be delivered (~24 hours)\n// 4. Remove old key from signing_keys array\n</code></pre><h4>Common Pitfalls</h4><ul><li><strong>Not verifying signatures:</strong> MUST verify Request-Signature header to prevent spoofed webhooks</li><li><strong>Slow webhook response:</strong> Respond with 2xx immediately, process asynchronously after</li><li><strong>Missing kid in JWT:</strong> Always include kid (key ID) in JWT header for key lookup</li><li><strong>Not caching business profiles:</strong> Cache profile and signing keys to avoid fetching on every webhook</li><li><strong>Forgetting detached signature:</strong> Use RFC 7797 detached JWT (b64: false, crit: ['b64'])</li><li><strong>Hardcoding webhook URLs:</strong> Always read webhook_url from platform's capability config</li><li><strong>Not handling retries:</strong> Business should retry failed webhooks with exponential backoff</li></ul>",
          "resources": [
            {
              "type": "spec",
              "url": "https://ucp.dev/specification/order/",
              "label": "Order Specification"
            },
            {
              "type": "spec",
              "url": "https://ucp.dev/specification/order/#webhook-signature-verification",
              "label": "Webhook Signature Verification"
            },
            {
              "type": "schema",
              "url": "https://ucp.dev/schemas/shopping/order.json",
              "label": "Order Schema"
            }
          ]
        }
      ]
    },
    {
      "id": "transports",
      "label": "4. Transport Protocols",
      "description": "REST, MCP, A2A, Embedded",
      "content": "<h3>Multiple Transport Options</h3><p>UCP is transport-agnostic. The same capabilities can be exposed via different protocols.</p>",
      "children": [
        {
          "id": "rest-api",
          "label": "REST API",
          "description": "HTTP/JSON endpoints",
          "content": "<h3>What is the REST Binding?</h3>\n\n<p>The REST binding provides traditional HTTP/JSON endpoints for UCP capabilities. It's the most familiar transport for web developers and works with any HTTP client.</p>\n\n<h4>Architecture</h4>\n\n<pre><code>┌──────────────┐                    ┌──────────────┐\n│   Platform   │  HTTP POST/PATCH   │   Business   │\n│  (Shopify)   │ ─────────────────> │  (Merchant)  │\n│              │ <───────────────── │              │\n│              │   JSON Response    │              │\n└──────────────┘                    └──────────────┘\n\nRequest: POST /ucp/v1/checkouts\nResponse: { checkout: {...}, continue_url: \"...\" }\n</code></pre>\n\n<h4>Checkout Flow Example</h4>\n\n<p><strong>1. Create Checkout</strong></p>\n\n<pre><code class=\"language-http\">POST https://merchant.com/ucp/v1/checkouts\nContent-Type: application/json\n\n{\n  \"line_items\": [\n    {\n      \"id\": \"item_1\",\n      \"quantity\": 2,\n      \"item_name\": \"Widget\",\n      \"price\": {\"amount\": \"1999\", \"currency\": \"USD\"}\n    }\n  ],\n  \"buyer\": {\n    \"email\": \"customer@example.com\"\n  }\n}</code></pre>\n\n<p><strong>Response:</strong></p>\n\n<pre><code class=\"language-json\">{\n  \"checkout\": {\n    \"id\": \"checkout_abc123\",\n    \"status\": \"incomplete\",\n    \"continue_url\": \"https://merchant.com/checkout/abc123\",\n    \"totals\": [\n      {\"type\": \"subtotal\", \"amount\": \"3998\", \"currency\": \"USD\"},\n      {\"type\": \"total\", \"amount\": \"3998\", \"currency\": \"USD\"}\n    ],\n    \"line_items\": [...]\n  }\n}</code></pre>\n\n<p><strong>2. Update Checkout (add shipping address)</strong></p>\n\n<pre><code class=\"language-http\">PATCH https://merchant.com/ucp/v1/checkouts/checkout_abc123\nContent-Type: application/json\n\n{\n  \"buyer\": {\n    \"shipping_address\": {\n      \"first_name\": \"Jane\",\n      \"last_name\": \"Doe\",\n      \"street_address\": \"123 Main St\",\n      \"city\": \"San Francisco\",\n      \"province\": \"CA\",\n      \"postal_code\": \"94103\",\n      \"country\": \"US\"\n    }\n  }\n}</code></pre>\n\n<p><strong>3. Complete Checkout</strong></p>\n\n<pre><code class=\"language-http\">POST https://merchant.com/ucp/v1/checkouts/checkout_abc123/complete\nContent-Type: application/json\n\n{\n  \"payment\": {\n    \"selected_instrument_id\": \"instr_123\",\n    \"instruments\": [\n      {\n        \"id\": \"instr_123\",\n        \"type\": \"card\",\n        \"credential\": {\"token\": \"tok_xyz...\"}\n      }\n    ]\n  }\n}</code></pre>\n\n<p><strong>Response with Order:</strong></p>\n\n<pre><code class=\"language-json\">{\n  \"checkout\": {\n    \"id\": \"checkout_abc123\",\n    \"status\": \"complete\",\n    \"order\": {\n      \"id\": \"order_789\",\n      \"permalink_url\": \"https://merchant.com/orders/order_789\"\n    }\n  }\n}</code></pre>\n\n<h4>Key Features</h4>\n\n<ul>\n<li><strong>RESTful Endpoints:</strong> Standard POST/PATCH/GET operations</li>\n<li><strong>Idempotency:</strong> Use <code>Idempotency-Key</code> header for safe retries</li>\n<li><strong>Partial Updates:</strong> PATCH for incremental changes to checkout state</li>\n<li><strong>Standard HTTP Status Codes:</strong> 200 OK, 201 Created, 400 Bad Request, etc.</li>\n</ul>\n\n<h4>Discovery</h4>\n\n<p>Businesses advertise REST endpoint in their UCP profile:</p>\n\n<pre><code class=\"language-json\">{\n  \"services\": {\n    \"dev.ucp.shopping\": {\n      \"version\": \"2026-01-11\",\n      \"rest\": {\n        \"endpoint\": \"https://merchant.com/ucp/v1\",\n        \"schema\": \"https://ucp.dev/services/shopping/rest.openapi.json\"\n      }\n    }\n  }\n}</code></pre>\n\n<h4>Authentication</h4>\n\n<pre><code class=\"language-http\">POST /ucp/v1/checkouts\nAuthorization: Bearer eyJhbGciOiJIUzI1NiIs...\nContent-Type: application/json\nIdempotency-Key: unique-request-id-123\n\n{...}</code></pre>\n\n<div class=\"concept-box\">\n<h4>💡 When to Use REST</h4>\n<ul>\n<li><strong>Web applications:</strong> Standard fetch/axios integration</li>\n<li><strong>Mobile apps:</strong> Universal HTTP support</li>\n<li><strong>Server-to-server:</strong> Backend checkout orchestration</li>\n<li><strong>Testing:</strong> Easy to test with curl/Postman</li>\n</ul>\n</div>",
          "resources": [
            {
              "type": "spec",
              "url": "https://ucp.dev/specification/checkout-rest/",
              "label": "REST Specification"
            }
          ]
        },
        {
          "id": "mcp-protocol",
          "label": "MCP (Model Context Protocol)",
          "description": "AI agent tool protocol",
          "content": "<h3>What is the MCP Binding?</h3>\n\n<p>The Model Context Protocol (MCP) binding exposes UCP capabilities as tools that AI agents and LLMs can discover and invoke. It enables autonomous commerce through natural language interactions.</p>\n\n<h4>Architecture</h4>\n\n<pre><code>┌──────────────┐                    ┌──────────────┐\n│  AI Agent /  │   MCP Protocol     │   Business   │\n│     LLM      │ ────────────────>  │   (Server)   │\n│              │ <──────────────────│              │\n│              │  JSON-RPC Response │              │\n└──────────────┘                    └──────────────┘\n\nAgent: \"tools/call\" → checkout.create\nServer: JSON-RPC result with checkout object\n</code></pre>\n\n<h4>How It Works</h4>\n\n<p><strong>1. Tool Discovery</strong></p>\n\n<p>AI agent asks: \"What tools are available?\"</p>\n\n<pre><code class=\"language-json\">{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"method\": \"tools/list\"\n}</code></pre>\n\n<p><strong>Server responds:</strong></p>\n\n<pre><code class=\"language-json\">{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": {\n    \"tools\": [\n      {\n        \"name\": \"checkout_create\",\n        \"description\": \"Create a new checkout session\",\n        \"inputSchema\": {\n          \"type\": \"object\",\n          \"properties\": {\n            \"line_items\": {...},\n            \"buyer\": {...}\n          }\n        }\n      },\n      {\n        \"name\": \"checkout_update\",\n        \"description\": \"Update checkout with shipping/payment info\"\n      },\n      {\n        \"name\": \"checkout_complete\",\n        \"description\": \"Complete checkout and create order\"\n      }\n    ]\n  }\n}</code></pre>\n\n<p><strong>2. Tool Invocation</strong></p>\n\n<p>Agent decides to create a checkout:</p>\n\n<pre><code class=\"language-json\">{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 2,\n  \"method\": \"tools/call\",\n  \"params\": {\n    \"name\": \"checkout_create\",\n    \"arguments\": {\n      \"line_items\": [\n        {\n          \"item_name\": \"Laptop\",\n          \"quantity\": 1,\n          \"price\": {\"amount\": \"99900\", \"currency\": \"USD\"}\n        }\n      ],\n      \"buyer\": {\n        \"email\": \"customer@example.com\"\n      }\n    }\n  }\n}</code></pre>\n\n<p><strong>Server responds with checkout:</strong></p>\n\n<pre><code class=\"language-json\">{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 2,\n  \"result\": {\n    \"content\": [\n      {\n        \"type\": \"text\",\n        \"text\": \"Created checkout_abc123 for $999.00\"\n      }\n    ],\n    \"isError\": false\n  }\n}</code></pre>\n\n<h4>Natural Language Example</h4>\n\n<pre><code>User: \"I want to buy a blue t-shirt size M\"\n\nAgent: (Thinks) I need to create a checkout\n       (Calls) checkout_create with:\n         - item_name: \"Blue T-Shirt\"\n         - variant: \"M\"\n         - quantity: 1\n\nAgent: \"I've started a checkout for a Blue T-Shirt (M) \n        for $24.99. What's your shipping address?\"\n\nUser: \"123 Main St, San Francisco CA 94103\"\n\nAgent: (Calls) checkout_update with shipping address\n\nAgent: \"Got it. Your total is $32.49 with standard shipping.\n        Ready to complete the order?\"\n\nUser: \"Yes, use my saved card ending in 1234\"\n\nAgent: (Calls) checkout_complete with payment instrument\n\nAgent: \"Order #789 confirmed! Arriving Thursday.\"\n</code></pre>\n\n<h4>Key Features</h4>\n\n<ul>\n<li><strong>Tool Discovery:</strong> AI agents discover capabilities dynamically</li>\n<li><strong>JSON-RPC 2.0:</strong> Standard protocol for remote procedure calls</li>\n<li><strong>Structured Inputs:</strong> JSON Schema defines tool parameters</li>\n<li><strong>Rich Responses:</strong> Text, images, and structured data</li>\n<li><strong>Stateless:</strong> Each tool call includes complete context</li>\n</ul>\n\n<h4>Discovery</h4>\n\n<pre><code class=\"language-json\">{\n  \"services\": {\n    \"dev.ucp.shopping\": {\n      \"version\": \"2026-01-11\",\n      \"mcp\": {\n        \"endpoint\": \"https://merchant.com/ucp/mcp\",\n        \"schema\": \"https://ucp.dev/services/shopping/mcp.openrpc.json\"\n      }\n    }\n  }\n}</code></pre>\n\n<h4>Connection Types</h4>\n\n<p><strong>STDIO</strong> - For local/desktop agents:</p>\n\n<pre><code class=\"language-javascript\">// Launch MCP server as subprocess\nconst server = spawn('ucp-mcp-server', [], {\n  stdio: ['pipe', 'pipe', 'pipe']\n});\n\n// Communicate via stdin/stdout\nserver.stdin.write(JSON.stringify({\n  jsonrpc: \"2.0\",\n  method: \"tools/list\"\n}));</code></pre>\n\n<p><strong>HTTP/SSE</strong> - For web-based agents:</p>\n\n<pre><code class=\"language-javascript\">// Connect to MCP endpoint\nconst response = await fetch('https://merchant.com/ucp/mcp', {\n  method: 'POST',\n  headers: {'Content-Type': 'application/json'},\n  body: JSON.stringify({\n    jsonrpc: \"2.0\",\n    method: \"tools/list\"\n  })\n});</code></pre>\n\n<div class=\"concept-box\">\n<h4>💡 When to Use MCP</h4>\n<ul>\n<li><strong>AI Agents:</strong> Claude Desktop, ChatGPT, custom agents</li>\n<li><strong>Autonomous Commerce:</strong> AI-driven shopping assistants</li>\n<li><strong>Conversational Commerce:</strong> Natural language checkout flows</li>\n<li><strong>Agent Orchestration:</strong> Multi-agent systems coordinating checkout</li>\n</ul>\n</div>",
          "resources": [
            {
              "type": "spec",
              "url": "https://ucp.dev/specification/checkout-mcp/",
              "label": "MCP Specification"
            }
          ]
        },
        {
          "id": "a2a-protocol",
          "label": "A2A (Agent-to-Agent)",
          "description": "Direct agent communication",
          "content": "<h3>A2A Transport Overview</h3><p>Agent-to-Agent (A2A) protocol enables autonomous agents to discover services, negotiate capabilities, and execute transactions without human intervention. Built on MCP foundation but adds agent identity, trust negotiation, and autonomous decision-making.</p><p><strong>When to use:</strong> Fully autonomous commerce, supply chain automation, B2B agent integrations, smart contracts requiring atomic transactions.</p><h4>A2A Discovery and Negotiation</h4><pre><code class=\"language-javascript\">/**\n * A2A agent discovers and validates business capabilities\n * before initiating transaction\n */\nclass A2AAgent {\n  constructor(agentProfile) {\n    this.profile = agentProfile;  // Agent's identity and capabilities\n    this.trustStore = new Map();  // Cached trust relationships\n  }\n\n  // Discover and validate business UCP capabilities\n  async discoverBusiness(businessUrl) {\n    // 1. Fetch UCP profile\n    const profileRes = await fetch(`${businessUrl}/.well-known/ucp`);\n    const profile = await profileRes.json();\n\n    // 2. Verify supported capabilities\n    const capabilities = profile.capabilities.map(c => c.name);\n    console.log('Business capabilities:', capabilities);\n\n    // 3. Check for A2A support (via MCP endpoint + agent auth)\n    if (!profile.services['dev.ucp.shopping']?.mcp) {\n      throw new Error('Business does not support agent protocols');\n    }\n\n    // 4. Validate version compatibility\n    const ucpVersion = profile.ucp.version;\n    if (!this.isVersionCompatible(ucpVersion)) {\n      throw new Error(`Incompatible UCP version: ${ucpVersion}`);\n    }\n\n    return {\n      endpoint: profile.services['dev.ucp.shopping'].mcp.endpoint,\n      capabilities,\n      version: ucpVersion\n    };\n  }\n\n  isVersionCompatible(version) {\n    // Agent's version compatibility logic\n    return version >= '2026-01-11';\n  }\n\n  // Establish trust with business agent\n  async negotiateTrust(businessEndpoint) {\n    // A2A uses mutual authentication\n    const trustReq = {\n      jsonrpc: '2.0',\n      id: 'trust_1',\n      method: 'a2a.handshake',\n      params: {\n        agent: {\n          id: this.profile.id,\n          name: this.profile.name,\n          profile: this.profile.url,\n          public_key: this.profile.publicKey\n        },\n        requested_capabilities: ['checkout', 'fulfillment']\n      }\n    };\n\n    const response = await fetch(businessEndpoint, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(trustReq)\n    });\n\n    const trustResult = await response.json();\n    if (trustResult.error) {\n      throw new Error(`Trust negotiation failed: ${trustResult.error.message}`);\n    }\n\n    // Cache trust token for subsequent calls\n    this.trustStore.set(businessEndpoint, trustResult.result.token);\n    return trustResult.result;\n  }\n}\n</code></pre><h4>Complete A2A Autonomous Transaction</h4><pre><code class=\"language-javascript\">/**\n * Fully autonomous agent-to-agent checkout\n * No human intervention from discovery to order placement\n */\nclass AutonomousPurchasingAgent extends A2AAgent {\n  async executePurchase(businessUrl, purchaseIntent) {\n    try {\n      // PHASE 1: DISCOVERY\n      console.log('[Agent] Discovering business capabilities...');\n      const business = await this.discoverBusiness(businessUrl);\n\n      // PHASE 2: TRUST NEGOTIATION\n      console.log('[Agent] Negotiating trust...');\n      const trust = await this.negotiateTrust(business.endpoint);\n      console.log('[Agent] Trust established');\n\n      // PHASE 3: AUTONOMOUS CHECKOUT\n      console.log('[Agent] Initiating autonomous checkout...');\n\n      // CREATE with agent context\n      const createResult = await this.agentCall(business.endpoint, 'create_checkout', {\n        _meta: {\n          ucp: { profile: this.profile.url },\n          a2a: {\n            agent_id: this.profile.id,\n            trust_token: this.trustStore.get(business.endpoint),\n            intent: 'autonomous_purchase'  // Signals no human in the loop\n          }\n        },\n        idempotency_key: `${this.profile.id}_${Date.now()}`,\n        buyer: {\n          // Agent provides buyer details from purchaseIntent\n          email: purchaseIntent.buyer.email,\n          first_name: purchaseIntent.buyer.firstName,\n          last_name: purchaseIntent.buyer.lastName\n        },\n        line_items: purchaseIntent.items.map(item => ({\n          item: { id: item.productId },\n          quantity: item.quantity\n        })),\n        currency: purchaseIntent.currency || 'USD'\n      });\n\n      const checkoutId = createResult.id;\n\n      // Agent autonomous decision: evaluate and select fulfillment\n      const updateResult = await this.agentCall(business.endpoint, 'update_checkout', {\n        _meta: {\n          ucp: { profile: this.profile.url },\n          a2a: {\n            agent_id: this.profile.id,\n            trust_token: this.trustStore.get(business.endpoint)\n          }\n        },\n        id: checkoutId,\n        buyer: createResult.buyer,\n        line_items: createResult.line_items,\n        fulfillment: {\n          methods: [\n            {\n              type: 'shipping',\n              destinations: [purchaseIntent.shippingAddress]\n            }\n          ]\n        }\n      });\n\n      // Agent decision logic: select optimal shipping\n      const shippingOptions = updateResult.fulfillment.methods[0].groups[0].options;\n      const optimalShipping = this.selectOptimalShipping(\n        shippingOptions,\n        purchaseIntent.preferences\n      );\n\n      console.log(`[Agent] Selected shipping: ${optimalShipping.title}`);\n\n      await this.agentCall(business.endpoint, 'update_checkout', {\n        _meta: {\n          ucp: { profile: this.profile.url },\n          a2a: {\n            agent_id: this.profile.id,\n            trust_token: this.trustStore.get(business.endpoint)\n          }\n        },\n        id: checkoutId,\n        buyer: updateResult.buyer,\n        line_items: updateResult.line_items,\n        fulfillment: {\n          methods: [\n            {\n              id: updateResult.fulfillment.methods[0].id,\n              groups: [\n                {\n                  id: updateResult.fulfillment.methods[0].groups[0].id,\n                  selected_option_id: optimalShipping.id\n                }\n              ]\n            }\n          ]\n        }\n      });\n\n      // COMPLETE with agent-managed payment\n      console.log('[Agent] Completing autonomous purchase...');\n      const completeResult = await this.agentCall(business.endpoint, 'complete_checkout', {\n        _meta: {\n          ucp: { profile: this.profile.url },\n          a2a: {\n            agent_id: this.profile.id,\n            trust_token: this.trustStore.get(business.endpoint),\n            autonomous_completion: true\n          }\n        },\n        id: checkoutId,\n        idempotency_key: `${this.profile.id}_complete_${Date.now()}`,\n        payment_data: await this.getAgentPaymentCredential(purchaseIntent)\n      });\n\n      console.log('[Agent] Purchase completed autonomously');\n      console.log(`Order ID: ${completeResult.order.id}`);\n\n      // PHASE 4: POST-TRANSACTION\n      await this.recordTransaction({\n        business: businessUrl,\n        order: completeResult.order,\n        timestamp: new Date().toISOString(),\n        autonomous: true\n      });\n\n      return completeResult;\n\n    } catch (error) {\n      console.error('[Agent] Autonomous purchase failed:', error);\n      await this.recordFailure(businessUrl, error);\n      throw error;\n    }\n  }\n\n  async agentCall(endpoint, method, params) {\n    const response = await fetch(endpoint, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        jsonrpc: '2.0',\n        id: crypto.randomUUID(),\n        method,\n        params\n      })\n    });\n\n    const result = await response.json();\n    if (result.error) {\n      throw new Error(`Agent call failed: ${result.error.message}`);\n    }\n    return result.result;\n  }\n\n  selectOptimalShipping(options, preferences) {\n    // Agent decision logic based on cost vs speed\n    if (preferences.priority === 'cost') {\n      return options.reduce((min, opt) =>\n        opt.totals[0].amount < min.totals[0].amount ? opt : min\n      );\n    } else if (preferences.priority === 'speed') {\n      return options.find(o => o.id.includes('express')) || options[0];\n    }\n    return options[0];  // Default to first option\n  }\n\n  async getAgentPaymentCredential(intent) {\n    // Agent retrieves payment credential from secure vault\n    // Implementation depends on agent's payment provider integration\n    return intent.paymentCredential;\n  }\n\n  async recordTransaction(record) {\n    // Agent logs transaction to its internal ledger\n    console.log('[Agent] Transaction recorded:', record.order.id);\n  }\n\n  async recordFailure(business, error) {\n    // Agent logs failure for learning and retry logic\n    console.log('[Agent] Failure recorded:', error.message);\n  }\n}\n\n// Usage: Autonomous agent executing purchase\nconst agent = new AutonomousPurchasingAgent({\n  id: 'agent_supply_chain_bot_001',\n  name: 'Supply Chain Purchasing Agent',\n  url: 'https://company.example/agents/purchasing-bot',\n  publicKey: '-----BEGIN PUBLIC KEY-----\\n...'\n});\n\nawait agent.executePurchase('https://supplier.example.com', {\n  buyer: {\n    email: 'procurement@company.example',\n    firstName: 'Procurement',\n    lastName: 'Department'\n  },\n  items: [\n    { productId: 'raw_material_steel_001', quantity: 100 }\n  ],\n  shippingAddress: {\n    street_address: '500 Industrial Blvd',\n    address_locality: 'Detroit',\n    address_region: 'MI',\n    postal_code: '48201',\n    address_country: 'US'\n  },\n  preferences: {\n    priority: 'cost'  // Agent optimizes for cost over speed\n  },\n  paymentCredential: {\n    type: 'PAYMENT_GATEWAY',\n    token: 'corp_payment_token_...'\n  }\n});\n</code></pre><h4>Common Pitfalls</h4><ul><li><strong>Missing agent identity:</strong> A2A requires agent profile URL and identity in _meta.a2a for trust establishment.</li><li><strong>Trust token expiration:</strong> Agents must handle trust token refresh when tokens expire during long-running transactions.</li><li><strong>Autonomous vs delegated:</strong> Signal autonomous_completion: true in _meta.a2a to inform business no human confirmation is required.</li><li><strong>Version compatibility:</strong> Always check UCP version compatibility before initiating transactions to avoid runtime failures.</li><li><strong>Error recovery:</strong> Agents must implement retry logic with exponential backoff for transient failures, and record failures for learning.</li></ul>",
          "resources": [
            {
              "type": "spec",
              "url": "https://ucp.dev/specification/agent-protocols/",
              "label": "Agent Protocols Documentation"
            }
          ]
        },
        {
          "id": "embedded-protocol",
          "label": "Embedded Protocol (ECP)",
          "description": "iframe embedding with JSON-RPC",
          "content": "<h3>What is Embedded Checkout Protocol (ECP)?</h3>\n\n<p>ECP allows a <strong>host application</strong> (like an AI assistant, super app, or browser) to embed a business's checkout inside an iframe or webview, while optionally taking control of certain user interactions like payment and address selection.</p>\n\n<div class=\"concept-box\">\n<h4>🎯 Key Concept: Business-Controlled with Optional Delegation</h4>\n<p>Unlike browser-controlled flows (W3C Payment Request), the <strong>business</strong> orchestrates the checkout. The host can <em>optionally</em> delegate specific UI interactions for a native experience.</p>\n</div>\n\n<h4>The Three Actors</h4>\n\n<pre><code>┌─────────────────────────────────────────────────────┐\n│                    Host Application                  │\n│  (AI Assistant, Super App, Browser Extension)        │\n│                                                      │\n│  ┌────────────────────────────────────────────┐    │\n│  │  Embedded Iframe (credentialless sandbox)   │    │\n│  │                                             │    │\n│  │    ┌─────────────────────────────────┐     │    │\n│  │    │   Business's Checkout UI        │     │    │\n│  │    │   (merchant-controlled)          │     │    │\n│  │    └─────────────────────────────────┘     │    │\n│  │                                             │    │\n│  │   Communicates via JSON-RPC 2.0/postMessage │    │\n│  └────────────────────────────────────────────┘    │\n│                                                      │\n│  ┌────────────────────────────────────────────┐    │\n│  │      Payment Handler (secure vault)         │    │\n│  │   • User authentication (biometric/PIN)     │    │\n│  │   • Credential issuance                     │    │\n│  └────────────────────────────────────────────┘    │\n└─────────────────────────────────────────────────────┘\n</code></pre>\n\n<h4>How It Works</h4>\n\n<p><strong>Step 1: Discovery</strong> - Business advertises ECP support in <code>/.well-known/ucp</code>:</p>\n\n<pre><code class=\"language-json\">{\n  \"services\": {\n    \"dev.ucp.shopping\": {\n      \"version\": \"2026-01-11\",\n      \"embedded\": {\n        \"schema\": \"https://ucp.dev/services/shopping/embedded.openrpc.json\"\n      }\n    }\n  }\n}</code></pre>\n\n<p><strong>Step 2: Load with Parameters</strong> - Host loads checkout URL with ECP parameters:</p>\n\n<pre><code>https://merchant.com/checkout/abc123\n  ?ec_version=2026-01-11\n  &ec_delegate=payment.instruments_change,payment.credential\n  &ec_auth=eyJ...</code></pre>\n\n<p><strong>Step 3: Handshake</strong> - Embedded checkout sends <code>ec.ready</code> message:</p>\n\n<pre><code class=\"language-json\">{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"ready_1\",\n  \"method\": \"ec.ready\",\n  \"params\": {\n    \"delegate\": [\"payment.credential\"]  // Accepted delegations\n  }\n}</code></pre>\n\n<p><strong>Step 4: Bidirectional Communication</strong> - Messages flow as checkout progresses:</p>\n\n<pre><code>Embedded Checkout → Host:\n  • ec.start (checkout visible)\n  • ec.line_items.change (cart updated)\n  • ec.payment.credential_request (need payment token)\n  • ec.complete (order placed)\n\nHost → Embedded Checkout:\n  • Response to ec.ready with optional MessagePort upgrade\n  • Response to credential_request with payment token\n</code></pre>\n\n<h4>Core Message Types</h4>\n\n<table>\n<tr><th>Category</th><th>Messages</th><th>Type</th></tr>\n<tr><td><strong>Handshake</strong></td><td>ec.ready</td><td>Request (requires response)</td></tr>\n<tr><td><strong>Lifecycle</strong></td><td>ec.start, ec.complete</td><td>Notification (no response)</td></tr>\n<tr><td><strong>State Changes</strong></td><td>ec.line_items.change<br>ec.buyer.change<br>ec.payment.change<br>ec.messages.change</td><td>Notification</td></tr>\n<tr><td><strong>Delegation</strong></td><td>ec.payment.credential_request<br>ec.payment.instruments_change_request<br>ec.fulfillment.address_change_request</td><td>Request</td></tr>\n</table>\n\n<h4>Delegation Contract</h4>\n\n<p>When host and business agree on delegations:</p>\n\n<ul>\n<li><strong>Embedded Checkout MUST:</strong>\n  <ul>\n    <li>Fire the appropriate <code>_request</code> message when action is triggered</li>\n    <li>Wait for host's response before proceeding</li>\n    <li>NOT show its own UI for delegated actions</li>\n  </ul>\n</li>\n<li><strong>Host MUST:</strong>\n  <ul>\n    <li>Respond to every <code>_request</code> message</li>\n    <li>Show native UI for delegated actions</li>\n    <li>Perform user authentication for payment credentials</li>\n  </ul>\n</li>\n</ul>\n\n<h4>Security Features</h4>\n\n<pre><code class=\"language-html\">&lt;!-- Host creates sandboxed, credentialless iframe --&gt;\n&lt;iframe \n  src=\"https://merchant.com/checkout?ec_version=...\"\n  sandbox=\"allow-scripts allow-forms allow-same-origin\"\n  credentialless\n&gt;&lt;/iframe&gt;</code></pre>\n\n<ul>\n<li><strong>CSP frame-ancestors:</strong> Business restricts embedding to trusted hosts</li>\n<li><strong>Origin validation:</strong> All postMessage calls validate origin</li>\n<li><strong>User activation required:</strong> Payment requests require user interaction</li>\n<li><strong>Credentialless iframes:</strong> Prevents session correlation</li>\n</ul>\n\n<h4>Key Differences from W3C Payment Request</h4>\n\n<table>\n<tr><th>Aspect</th><th>W3C Payment Request</th><th>Embedded Checkout</th></tr>\n<tr><td><strong>Control</strong></td><td>Browser-controlled</td><td>Business-controlled</td></tr>\n<tr><td><strong>UI</strong></td><td>Native payment sheet</td><td>Business's checkout UI</td></tr>\n<tr><td><strong>Initialization</strong></td><td><code>new PaymentRequest()</code></td><td>Load iframe with <code>continue_url</code></td></tr>\n<tr><td><strong>Payment Method Change</strong></td><td><code>paymentmethodchange</code> event</td><td><code>ec.payment.change</code> notification</td></tr>\n<tr><td><strong>Completion</strong></td><td><code>response.complete()</code></td><td><code>ec.complete</code> notification</td></tr>\n</table>\n\n<div class=\"concept-box\">\n<h4>💡 When to Use ECP</h4>\n<ul>\n<li><strong>Super Apps:</strong> Embed merchant checkouts with native payment UI</li>\n<li><strong>AI Assistants:</strong> Show checkout in conversation with delegated payment</li>\n<li><strong>Browser Extensions:</strong> Enhanced checkout with saved payment methods</li>\n<li><strong>White-label platforms:</strong> Embed third-party checkouts seamlessly</li>\n</ul>\n</div>",
          "resources": [
            {
              "type": "spec",
              "url": "https://ucp.dev/specification/embedded-checkout/",
              "label": "Embedded Protocol Specification"
            }
          ]
        }
      ]
    },
    {
      "id": "security",
      "label": "5. Advanced Security Patterns",
      "description": "AP2, consent, tokenization",
      "content": "<h3>Security-First Design</h3><p>UCP implements multiple layers of security for payment and identity protection.</p>",
      "children": [
        {
          "id": "ap2-mandates",
          "label": "AP2 Mandates",
          "description": "Authentication Protocol 2",
          "content": "<h3>AP2 Mandates - Cryptographic Proof of Payment Authorization</h3><p>Authentication Protocol 2 (AP2) mandates transform standard checkout flows into cryptographically verifiable agreements using Verifiable Digital Credentials (VDCs). This prevents unauthorized transactions, replay attacks, and provides Strong Customer Authentication (SCA) compliance.</p><h4>Threat Model</h4><ul><li><strong>Unauthorized Transactions</strong> - Prevent payment completion without explicit user consent</li><li><strong>Replay Attacks</strong> - Ensure checkout terms cannot be modified after user authorization</li><li><strong>Man-in-Middle</strong> - Detect tampering of checkout data in transit</li><li><strong>Regulatory Compliance</strong> - Enforce PSD2 SCA and similar requirements</li></ul><h4>Security Architecture</h4><p>AP2 creates a <strong>nested cryptographic chain</strong>:</p><ol><li><strong>Business Authorization</strong> - Business signs checkout response with JWS detached signature</li><li><strong>User Mandate</strong> - Platform (or user wallet) signs the entire checkout including business signature as SD-JWT+kb</li><li><strong>Verification Chain</strong> - Business verifies both signatures during complete_checkout</li></ol><h4>Complete AP2 Flow Implementation</h4><pre><code class=\"language-javascript\">// Import cryptographic libraries\nimport * as jose from 'jose';\nimport canonicalize from 'canonicalize';\n\n/**\n * STEP 1: Business signs checkout response\n * Implements JWS Detached Content per RFC 7515 Appendix F\n */\nasync function signCheckoutResponse(checkoutData, businessPrivateKey, kid) {\n  try {\n    // Remove ap2 field for canonical payload\n    const { ap2, ...payloadForSigning } = checkoutData;\n    \n    // Canonicalize using JCS (RFC 8785)\n    const canonicalPayload = canonicalize(payloadForSigning);\n    const payloadBytes = new TextEncoder().encode(canonicalPayload);\n    \n    // Create JWS with detached payload\n    const jws = await new jose.CompactSign(payloadBytes)\n      .setProtectedHeader({ \n        alg: 'ES256',  // ECDSA P-256 SHA-256 (REQUIRED)\n        kid: kid        // Key ID from business signing_keys\n      })\n      .sign(businessPrivateKey);\n    \n    // Format: header..signature (double dot = detached payload)\n    const [header, , signature] = jws.split('.');\n    const detachedJWS = `${header}..${signature}`;\n    \n    // Add signature to response\n    return {\n      ...checkoutData,\n      ap2: {\n        merchant_authorization: detachedJWS\n      }\n    };\n  } catch (error) {\n    throw new Error(`Checkout signing failed: ${error.message}`);\n  }\n}\n\n/**\n * STEP 2: Platform verifies business signature\n * Critical security check before showing checkout to user\n */\nasync function verifyBusinessSignature(checkoutResponse, businessPublicKey) {\n  try {\n    const { ap2, ...payloadForVerification } = checkoutResponse;\n    \n    if (!ap2?.merchant_authorization) {\n      throw new Error('AP2 negotiated but merchant_authorization missing');\n    }\n    \n    // Parse detached JWS\n    const [encodedHeader, , encodedSignature] = \n      ap2.merchant_authorization.split('.');\n    \n    // Decode and validate header\n    const header = JSON.parse(\n      Buffer.from(encodedHeader, 'base64url').toString()\n    );\n    \n    if (!['ES256', 'ES384', 'ES512'].includes(header.alg)) {\n      throw new Error(`Unsupported algorithm: ${header.alg}`);\n    }\n    \n    // Reconstruct signed payload\n    const canonicalPayload = canonicalize(payloadForVerification);\n    const payloadBytes = new TextEncoder().encode(canonicalPayload);\n    \n    // Reconstruct full JWS for verification\n    const reconstructedJWS = `${encodedHeader}.${Buffer.from(payloadBytes).toString('base64url')}.${encodedSignature}`;\n    \n    // Verify signature\n    const { payload } = await jose.compactVerify(\n      reconstructedJWS,\n      businessPublicKey\n    );\n    \n    console.log('✓ Business signature verified');\n    return true;\n  } catch (error) {\n    throw new Error(`Signature verification failed: ${error.message}`);\n  }\n}\n\n/**\n * STEP 3: Generate user mandate (Platform Provider model)\n * Platform signs on user's behalf after explicit consent\n */\nasync function generateCheckoutMandate(\n  checkoutResponse, \n  platformPrivateKey,\n  checkoutId,\n  userId\n) {\n  try {\n    // Mandate payload embeds ENTIRE checkout (including business signature)\n    const mandatePayload = {\n      iat: Math.floor(Date.now() / 1000),\n      exp: Math.floor(Date.now() / 1000) + 900, // 15 min expiry\n      iss: 'https://platform.example.com',\n      sub: userId,\n      checkout_id: checkoutId,\n      checkout_data: checkoutResponse, // Nested signature\n      scope: 'checkout_authorization'\n    };\n    \n    // Sign as SD-JWT (simplified - production would use proper SD-JWT library)\n    const jwt = await new jose.SignJWT(mandatePayload)\n      .setProtectedHeader({ alg: 'ES256', typ: 'vc+sd-jwt' })\n      .setIssuedAt()\n      .setExpirationTime('15m')\n      .sign(platformPrivateKey);\n    \n    return jwt;\n  } catch (error) {\n    throw new Error(`Mandate generation failed: ${error.message}`);\n  }\n}\n\n/**\n * STEP 4: Business verifies mandate during complete_checkout\n * Critical security verification - NEVER skip this\n */\nasync function verifyCheckoutMandate(\n  mandateJWT,\n  platformPublicKey,\n  expectedCheckoutId,\n  businessPublicKey\n) {\n  try {\n    // Verify mandate signature and expiry\n    const { payload } = await jose.jwtVerify(mandateJWT, platformPublicKey, {\n      maxTokenAge: '15m'\n    });\n    \n    // Verify binding: mandate MUST match current checkout\n    if (payload.checkout_id !== expectedCheckoutId) {\n      throw new Error('Mandate scope mismatch - replay attack detected');\n    }\n    \n    // Extract embedded checkout from mandate\n    const embeddedCheckout = payload.checkout_data;\n    \n    // Verify business's own signature in embedded checkout\n    await verifyBusinessSignature(embeddedCheckout, businessPublicKey);\n    \n    // Verify checkout terms match current session\n    const currentCheckout = await getCheckoutById(expectedCheckoutId);\n    if (embeddedCheckout.totals[0].amount !== currentCheckout.totals[0].amount) {\n      throw new Error('Checkout terms mismatch - tampering detected');\n    }\n    \n    console.log('✓ Complete AP2 verification passed');\n    return { verified: true, checkout: embeddedCheckout };\n  } catch (error) {\n    throw new Error(`Mandate verification failed: ${error.message}`);\n  }\n}\n\n/**\n * Example: Full AP2 checkout flow\n */\nasync function exampleAP2Checkout() {\n  // Generate keys (in production, load from secure storage)\n  const businessKeyPair = await jose.generateKeyPair('ES256');\n  const platformKeyPair = await jose.generateKeyPair('ES256');\n  \n  // Checkout data\n  const checkout = {\n    id: 'chk_abc123',\n    status: 'ready_for_complete',\n    currency: 'USD',\n    line_items: [{ id: 'li_1', quantity: 2 }],\n    totals: [{ type: 'total', amount: 5400 }]\n  };\n  \n  // BUSINESS: Sign checkout response\n  const signedCheckout = await signCheckoutResponse(\n    checkout,\n    businessKeyPair.privateKey,\n    'merchant_2025'\n  );\n  \n  // PLATFORM: Verify before showing to user\n  await verifyBusinessSignature(\n    signedCheckout,\n    businessKeyPair.publicKey\n  );\n  \n  // USER: Confirms purchase (not shown - UI interaction)\n  \n  // PLATFORM: Generate mandate after user consent\n  const mandate = await generateCheckoutMandate(\n    signedCheckout,\n    platformKeyPair.privateKey,\n    'chk_abc123',\n    'user_789'\n  );\n  \n  // BUSINESS: Verify mandate during complete_checkout\n  await verifyCheckoutMandate(\n    mandate,\n    platformKeyPair.publicKey,\n    'chk_abc123',\n    businessKeyPair.publicKey\n  );\n  \n  console.log('✓ AP2 checkout completed securely');\n}\n</code></pre><h4>Security Best Practices</h4><ul><li><strong>Never bypass verification</strong> - Always verify both signatures even in trusted environments</li><li><strong>Validate expiry</strong> - Mandates MUST have short TTL (typically 15 minutes)</li><li><strong>Check binding</strong> - Verify checkout_id matches to prevent replay attacks</li><li><strong>Use canonical JSON</strong> - JCS (RFC 8785) ensures byte-identical payloads</li><li><strong>Secure key storage</strong> - Private keys must never be exposed to client-side code</li><li><strong>Algorithm allowlist</strong> - Only accept ES256/ES384/ES512, reject 'none' algorithm</li></ul><h4>Common Attack Scenarios</h4><table><thead><tr><th>Attack</th><th>AP2 Defense</th></tr></thead><tbody><tr><td>Price tampering</td><td>Business signature covers totals, tampering breaks signature</td></tr><tr><td>Replay attack</td><td>Mandate binding to checkout_id prevents reuse</td></tr><tr><td>MITM modification</td><td>Any change invalidates nested signatures</td></tr><tr><td>Algorithm substitution</td><td>Signature covers JWS header including 'alg'</td></tr></tbody></table>",
          "resources": [
            {
              "type": "spec",
              "url": "https://ucp.dev/specification/ap2-mandates",
              "label": "AP2 Specification"
            },
            {
              "type": "doc",
              "url": "https://datatracker.ietf.org/doc/html/rfc7515",
              "label": "RFC 7515: JWS"
            },
            {
              "type": "doc",
              "url": "https://datatracker.ietf.org/doc/html/rfc8785",
              "label": "RFC 8785: JSON Canonicalization"
            }
          ]
        },
        {
          "id": "buyer-consent",
          "label": "Buyer Consent",
          "description": "Explicit user permissions",
          "content": "<h3>Buyer Consent Management - Privacy-First Authorization</h3><p>The Buyer Consent extension enables OAuth-style authorization flows for privacy compliance (GDPR, CCPA) and agentic commerce. It provides granular, revocable consent management with cryptographic audit trails.</p><h4>Threat Model</h4><ul><li><strong>Unauthorized Data Usage</strong> - Prevent businesses from using buyer data without explicit consent</li><li><strong>Privacy Violations</strong> - Ensure compliance with GDPR, CCPA, and regional privacy laws</li><li><strong>Consent Drift</strong> - Detect when consent scope expands without user reauthorization</li><li><strong>Agent Overreach</strong> - Prevent AI agents from exceeding authorized transaction limits</li></ul><h4>Consent Categories</h4><table><thead><tr><th>Category</th><th>Purpose</th><th>Security Implication</th></tr></thead><tbody><tr><td><code>analytics</code></td><td>Usage tracking, performance metrics</td><td>PII exposure, tracking prevention</td></tr><tr><td><code>preferences</code></td><td>Remember settings, personalization</td><td>Behavioral profiling risk</td></tr><tr><td><code>marketing</code></td><td>Promotional communications</td><td>Spam, unsolicited contact</td></tr><tr><td><code>sale_of_data</code></td><td>Data sharing with third parties</td><td>CCPA right to opt-out</td></tr></tbody></table><h4>Complete Consent Management Implementation</h4><pre><code class=\"language-javascript\">import * as jose from 'jose';\n\n/**\n * Consent Management System\n * Implements OAuth 2.0 style consent grants with cryptographic audit trail\n */\nclass ConsentManager {\n  constructor(privateKey, publicKey) {\n    this.privateKey = privateKey;\n    this.publicKey = publicKey;\n    this.consentStore = new Map(); // Production: use encrypted database\n  }\n\n  /**\n   * STEP 1: Request consent from user\n   * Present clear UI showing what data will be used and how\n   */\n  async requestConsent(userId, businessId, requestedScopes) {\n    // Validate requested scopes\n    const validScopes = ['analytics', 'preferences', 'marketing', 'sale_of_data'];\n    const invalidScopes = requestedScopes.filter(s => !validScopes.includes(s));\n    \n    if (invalidScopes.length > 0) {\n      throw new Error(`Invalid consent scopes: ${invalidScopes.join(', ')}`);\n    }\n    \n    // Generate consent request token (short-lived)\n    const consentRequest = await new jose.SignJWT({\n      user_id: userId,\n      business_id: businessId,\n      requested_scopes: requestedScopes,\n      timestamp: Date.now()\n    })\n      .setProtectedHeader({ alg: 'ES256' })\n      .setIssuedAt()\n      .setExpirationTime('5m') // Consent UI must complete within 5 minutes\n      .sign(this.privateKey);\n    \n    return {\n      consent_request_token: consentRequest,\n      scopes: requestedScopes,\n      // In production: return URL to consent UI\n      consent_url: `https://platform.example.com/consent?token=${consentRequest}`\n    };\n  }\n\n  /**\n   * STEP 2: Record user consent decision\n   * Critical: Only accept TRUE consent from verified user interaction\n   */\n  async recordConsent(\n    userId,\n    businessId,\n    consentDecisions,\n    userSignature // Proof of user action (e.g., session token)\n  ) {\n    try {\n      // Verify user signature\n      const { payload } = await jose.jwtVerify(userSignature, this.publicKey);\n      \n      if (payload.user_id !== userId) {\n        throw new Error('User ID mismatch - consent forgery attempt');\n      }\n      \n      // Create consent grant\n      const consentGrant = {\n        grant_id: `consent_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        user_id: userId,\n        business_id: businessId,\n        scopes: consentDecisions,\n        granted_at: new Date().toISOString(),\n        expires_at: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toISOString(), // 1 year\n        version: '1.0',\n        audit_trail: [{\n          action: 'granted',\n          timestamp: Date.now(),\n          user_agent: payload.user_agent,\n          ip_address: payload.ip_address\n        }]\n      };\n      \n      // Sign consent grant for tamper-evidence\n      const signedGrant = await new jose.SignJWT(consentGrant)\n        .setProtectedHeader({ alg: 'ES256', typ: 'consent+jwt' })\n        .sign(this.privateKey);\n      \n      // Store encrypted\n      const storageKey = `${userId}:${businessId}`;\n      this.consentStore.set(storageKey, signedGrant);\n      \n      console.log(`✓ Consent recorded: ${storageKey}`);\n      return consentGrant;\n    } catch (error) {\n      throw new Error(`Consent recording failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * STEP 3: Check consent before checkout\n   * Verify user has granted required consents to business\n   */\n  async checkConsent(userId, businessId, requiredScopes) {\n    const storageKey = `${userId}:${businessId}`;\n    const signedGrant = this.consentStore.get(storageKey);\n    \n    if (!signedGrant) {\n      return {\n        has_consent: false,\n        missing_scopes: requiredScopes,\n        action: 'request_consent'\n      };\n    }\n    \n    try {\n      // Verify consent grant signature\n      const { payload: grant } = await jose.jwtVerify(signedGrant, this.publicKey);\n      \n      // Check expiry\n      if (new Date(grant.expires_at) < new Date()) {\n        return {\n          has_consent: false,\n          reason: 'consent_expired',\n          action: 'request_reauthorization'\n        };\n      }\n      \n      // Check scopes\n      const missingScopes = requiredScopes.filter(\n        scope => !grant.scopes[scope]\n      );\n      \n      if (missingScopes.length > 0) {\n        return {\n          has_consent: false,\n          granted_scopes: grant.scopes,\n          missing_scopes: missingScopes,\n          action: 'request_additional_consent'\n        };\n      }\n      \n      return {\n        has_consent: true,\n        grant: grant,\n        scopes: grant.scopes\n      };\n    } catch (error) {\n      throw new Error(`Consent verification failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * STEP 4: Revoke consent\n   * User can revoke at any time (GDPR/CCPA requirement)\n   */\n  async revokeConsent(userId, businessId, userSignature) {\n    try {\n      // Verify user signature\n      const { payload } = await jose.jwtVerify(userSignature, this.publicKey);\n      \n      if (payload.user_id !== userId) {\n        throw new Error('User ID mismatch - revocation forgery attempt');\n      }\n      \n      const storageKey = `${userId}:${businessId}`;\n      const signedGrant = this.consentStore.get(storageKey);\n      \n      if (!signedGrant) {\n        throw new Error('No consent grant found to revoke');\n      }\n      \n      // Decode existing grant\n      const { payload: grant } = await jose.jwtVerify(signedGrant, this.publicKey);\n      \n      // Update audit trail\n      grant.audit_trail.push({\n        action: 'revoked',\n        timestamp: Date.now(),\n        user_agent: payload.user_agent,\n        ip_address: payload.ip_address\n      });\n      \n      grant.revoked_at = new Date().toISOString();\n      \n      // Re-sign with revocation status\n      const revokedGrant = await new jose.SignJWT(grant)\n        .setProtectedHeader({ alg: 'ES256', typ: 'consent+jwt' })\n        .sign(this.privateKey);\n      \n      this.consentStore.set(storageKey, revokedGrant);\n      \n      console.log(`✓ Consent revoked: ${storageKey}`);\n      return { revoked: true, grant_id: grant.grant_id };\n    } catch (error) {\n      throw new Error(`Consent revocation failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * STEP 5: Build consent object for checkout\n   * Include in checkout create/update requests\n   */\n  async buildCheckoutConsent(userId, businessId) {\n    const consentCheck = await this.checkConsent(userId, businessId, \n      ['analytics', 'preferences', 'marketing', 'sale_of_data']\n    );\n    \n    if (!consentCheck.has_consent) {\n      // Return all false if no consent\n      return {\n        analytics: false,\n        preferences: false,\n        marketing: false,\n        sale_of_data: false,\n        consent_status: 'not_granted'\n      };\n    }\n    \n    // Return actual consent values\n    return {\n      ...consentCheck.scopes,\n      consent_status: 'granted',\n      grant_id: consentCheck.grant.grant_id\n    };\n  }\n}\n\n/**\n * Example: Agentic Commerce Consent Flow\n * AI agent must respect consent limits\n */\nasync function agenticCheckoutWithConsent() {\n  // Generate keys\n  const keyPair = await jose.generateKeyPair('ES256');\n  const consentMgr = new ConsentManager(keyPair.privateKey, keyPair.publicKey);\n  \n  // Agent wants to make purchase\n  const userId = 'user_123';\n  const businessId = 'merchant_456';\n  \n  // Check existing consent\n  const consentCheck = await consentMgr.checkConsent(\n    userId,\n    businessId,\n    ['marketing', 'analytics']\n  );\n  \n  if (!consentCheck.has_consent) {\n    console.log('⚠ Consent not granted - requesting from user');\n    \n    // Request consent\n    const request = await consentMgr.requestConsent(\n      userId,\n      businessId,\n      ['marketing', 'analytics']\n    );\n    \n    // User grants consent (UI interaction not shown)\n    const userSignature = await new jose.SignJWT({\n      user_id: userId,\n      action: 'grant_consent',\n      user_agent: 'Browser/1.0',\n      ip_address: '192.168.1.1'\n    })\n      .setProtectedHeader({ alg: 'ES256' })\n      .setIssuedAt()\n      .sign(keyPair.privateKey);\n    \n    await consentMgr.recordConsent(\n      userId,\n      businessId,\n      {\n        analytics: true,\n        preferences: true,\n        marketing: false, // User declined marketing\n        sale_of_data: false\n      },\n      userSignature\n    );\n  }\n  \n  // Build checkout with consent\n  const checkout = {\n    line_items: [{ id: 'prod_1', quantity: 1 }],\n    buyer: {\n      email: 'user@example.com',\n      consent: await consentMgr.buildCheckoutConsent(userId, businessId)\n    }\n  };\n  \n  console.log('✓ Checkout includes verified consent:', checkout.buyer.consent);\n}\n</code></pre><h4>Security Best Practices</h4><ul><li><strong>Never assume consent</strong> - Default to false, require explicit opt-in</li><li><strong>Short consent UI timeout</strong> - Consent requests expire quickly (5 min)</li><li><strong>Cryptographic audit trail</strong> - Sign all consent changes for compliance evidence</li><li><strong>Granular revocation</strong> - Support per-scope and full revocation</li><li><strong>Consent scope validation</strong> - Reject unknown or malformed scope requests</li><li><strong>Periodic reauthorization</strong> - Expired consents require user reconfirmation</li></ul><h4>Common Vulnerabilities</h4><table><thead><tr><th>Vulnerability</th><th>Mitigation</th></tr></thead><tbody><tr><td>Consent forgery</td><td>Verify user signature on consent grants</td></tr><tr><td>Scope creep</td><td>Check exact scope match, block unauthorized expansions</td></tr><tr><td>Stale consent</td><td>Enforce expiry, require periodic reauthorization</td></tr><tr><td>Missing audit trail</td><td>Log all consent changes with timestamp and user context</td></tr></tbody></table>",
          "resources": [
            {
              "type": "spec",
              "url": "https://ucp.dev/specification/buyer-consent",
              "label": "Consent Documentation"
            },
            {
              "type": "doc",
              "url": "https://gdpr.eu/",
              "label": "GDPR Overview"
            },
            {
              "type": "doc",
              "url": "https://oag.ca.gov/privacy/ccpa",
              "label": "CCPA Overview"
            }
          ]
        },
        {
          "id": "tokenization",
          "label": "Payment Tokenization",
          "description": "Secure credential exchange",
          "content": "<h3>Payment Tokenization - PCI Scope Reduction</h3><p>Tokenization transforms sensitive payment credentials into non-sensitive tokens, dramatically reducing PCI-DSS compliance scope. Tokens are cryptographically bound to specific checkouts and participants, preventing credential reuse and replay attacks.</p><h4>Threat Model</h4><ul><li><strong>Credential Exposure</strong> - Prevent raw card data (PAN) from touching platform or business systems</li><li><strong>Token Replay</strong> - Ensure tokens cannot be reused across different checkouts or businesses</li><li><strong>PCI Scope Expansion</strong> - Minimize systems that must undergo PCI-DSS certification</li><li><strong>Credential Theft</strong> - Limit value of stolen tokens through binding and expiry</li></ul><h4>Token Lifecycle Phases</h4><table><thead><tr><th>Phase</th><th>Actor</th><th>Security Control</th></tr></thead><tbody><tr><td><strong>Generation</strong></td><td>Tokenizer</td><td>Cryptographically random, 128+ bits entropy</td></tr><tr><td><strong>Binding</strong></td><td>Platform</td><td>Tied to checkout_id + business identity</td></tr><tr><td><strong>Storage</strong></td><td>Tokenizer</td><td>Encrypted at rest, credential → token mapping</td></tr><tr><td><strong>Detokenization</strong></td><td>PSP/Business</td><td>Binding verification before credential release</td></tr><tr><td><strong>Invalidation</strong></td><td>Tokenizer</td><td>Single-use or TTL expiry (typically 5-30 min)</td></tr></tbody></table><h4>Complete Tokenization Implementation</h4><pre><code class=\"language-javascript\">import crypto from 'crypto';\nimport * as jose from 'jose';\n\n/**\n * Secure Tokenization Service\n * Implements binding, expiry, and single-use token lifecycle\n */\nclass TokenizationService {\n  constructor() {\n    // Production: use encrypted database with HSM key storage\n    this.tokenStore = new Map();\n    this.usedTokens = new Set(); // Track single-use tokens\n  }\n\n  /**\n   * STEP 1: Tokenize credential\n   * Converts raw payment data to bound token\n   */\n  async tokenize(credential, binding) {\n    try {\n      // Validate binding (CRITICAL security requirement)\n      if (!binding.checkout_id || !binding.identity?.access_token) {\n        throw new Error('Binding required: checkout_id and identity.access_token');\n      }\n      \n      // Generate cryptographically secure token\n      // 128 bits minimum entropy per PCI requirements\n      const tokenBytes = crypto.randomBytes(32); // 256 bits\n      const token = `tok_${tokenBytes.toString('base64url')}`;\n      \n      // Create token metadata\n      const tokenData = {\n        token,\n        credential: credential, // Encrypted in production\n        binding: {\n          checkout_id: binding.checkout_id,\n          business_id: binding.identity.access_token\n        },\n        created_at: Date.now(),\n        expires_at: Date.now() + (15 * 60 * 1000), // 15 min TTL\n        lifecycle_policy: 'single-use',\n        usage_count: 0\n      };\n      \n      // Store encrypted (production: use AES-256-GCM with HSM)\n      this.tokenStore.set(token, tokenData);\n      \n      console.log(`✓ Token generated and bound to checkout: ${binding.checkout_id}`);\n      \n      return {\n        token,\n        expires_at: new Date(tokenData.expires_at).toISOString(),\n        lifecycle_policy: 'single-use'\n      };\n    } catch (error) {\n      throw new Error(`Tokenization failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * STEP 2: Detokenize (retrieve credential)\n   * Critical: Verify binding before releasing credential\n   */\n  async detokenize(token, binding) {\n    try {\n      // Retrieve token data\n      const tokenData = this.tokenStore.get(token);\n      \n      if (!tokenData) {\n        throw new Error('Token not found or already invalidated');\n      }\n      \n      // Check single-use enforcement\n      if (this.usedTokens.has(token)) {\n        throw new Error('Token already used - replay attack detected');\n      }\n      \n      // Verify TTL expiry\n      if (Date.now() > tokenData.expires_at) {\n        this.tokenStore.delete(token);\n        throw new Error('Token expired');\n      }\n      \n      // CRITICAL: Verify binding matches\n      if (tokenData.binding.checkout_id !== binding.checkout_id) {\n        throw new Error(\n          `Binding mismatch: Token bound to ${tokenData.binding.checkout_id}, ` +\n          `requested for ${binding.checkout_id} - replay attack detected`\n        );\n      }\n      \n      if (tokenData.binding.business_id !== binding.identity?.access_token) {\n        throw new Error(\n          `Identity mismatch: Token bound to different business - ` +\n          `cross-merchant attack detected`\n        );\n      }\n      \n      // Mark as used (single-use enforcement)\n      this.usedTokens.add(token);\n      tokenData.usage_count++;\n      \n      // Invalidate token immediately\n      this.tokenStore.delete(token);\n      \n      console.log(`✓ Token detokenized and invalidated: ${token.substring(0, 12)}...`);\n      \n      return tokenData.credential;\n    } catch (error) {\n      throw new Error(`Detokenization failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * STEP 3: Refresh expired token\n   * Generate new token for same credential (different binding)\n   */\n  async refreshToken(oldToken, newBinding) {\n    try {\n      const tokenData = this.tokenStore.get(oldToken);\n      \n      if (!tokenData) {\n        throw new Error('Original token not found');\n      }\n      \n      // Extract credential and create new token\n      const credential = tokenData.credential;\n      \n      // Invalidate old token\n      this.tokenStore.delete(oldToken);\n      \n      // Generate new token with updated binding\n      return await this.tokenize(credential, newBinding);\n    } catch (error) {\n      throw new Error(`Token refresh failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * Security audit: Check token usage\n   */\n  async auditToken(token) {\n    const tokenData = this.tokenStore.get(token);\n    \n    if (!tokenData) {\n      return { status: 'invalid_or_used' };\n    }\n    \n    return {\n      status: 'active',\n      created_at: new Date(tokenData.created_at).toISOString(),\n      expires_at: new Date(tokenData.expires_at).toISOString(),\n      ttl_remaining: Math.max(0, tokenData.expires_at - Date.now()),\n      binding: tokenData.binding,\n      usage_count: tokenData.usage_count,\n      is_expired: Date.now() > tokenData.expires_at\n    };\n  }\n}\n\n/**\n * Example: Full tokenization flow with platform, business, PSP\n */\nasync function exampleTokenizationFlow() {\n  const tokenizer = new TokenizationService();\n  \n  // STEP 1: Platform tokenizes user's card\n  console.log('\\n--- PLATFORM: Tokenizing card ---');\n  const cardCredential = {\n    type: 'card',\n    card_number_type: 'fpan',\n    number: '4111111111111111',\n    expiry_month: 12,\n    expiry_year: 2026,\n    cvc: '123'\n  };\n  \n  const checkoutId = 'chk_abc123';\n  const businessId = 'merchant_token_xyz';\n  \n  const tokenResult = await tokenizer.tokenize(cardCredential, {\n    checkout_id: checkoutId,\n    identity: { access_token: businessId }\n  });\n  \n  console.log('Token:', tokenResult.token.substring(0, 20) + '...');\n  console.log('Expires:', tokenResult.expires_at);\n  \n  // STEP 2: Platform sends token to business (not raw card)\n  console.log('\\n--- PLATFORM → BUSINESS: Sending token in checkout ---');\n  const checkoutData = {\n    id: checkoutId,\n    payment_data: {\n      credential: {\n        type: 'token',\n        token: tokenResult.token\n      }\n    }\n  };\n  \n  // STEP 3: Business forwards token to PSP\n  console.log('\\n--- BUSINESS → PSP: Forwarding token ---');\n  \n  // STEP 4: PSP detokenizes with binding verification\n  console.log('\\n--- PSP: Detokenizing for payment processing ---');\n  const retrievedCredential = await tokenizer.detokenize(\n    tokenResult.token,\n    {\n      checkout_id: checkoutId,\n      identity: { access_token: businessId }\n    }\n  );\n  \n  console.log('✓ Credential retrieved:', retrievedCredential.type);\n  console.log('✓ Card ending:', retrievedCredential.number.slice(-4));\n  \n  // STEP 5: Attempt replay attack (should fail)\n  console.log('\\n--- ATTACK SCENARIO: Token replay ---');\n  try {\n    await tokenizer.detokenize(tokenResult.token, {\n      checkout_id: checkoutId,\n      identity: { access_token: businessId }\n    });\n    console.log('❌ SECURITY FAILURE: Replay succeeded');\n  } catch (error) {\n    console.log('✓ SECURITY SUCCESS: Replay blocked:', error.message);\n  }\n  \n  // STEP 6: Attempt cross-merchant attack (should fail)\n  console.log('\\n--- ATTACK SCENARIO: Cross-merchant token theft ---');\n  const newToken = await tokenizer.tokenize(cardCredential, {\n    checkout_id: 'chk_def456',\n    identity: { access_token: 'merchant_real' }\n  });\n  \n  try {\n    await tokenizer.detokenize(newToken.token, {\n      checkout_id: 'chk_def456',\n      identity: { access_token: 'merchant_attacker' } // Wrong business\n    });\n    console.log('❌ SECURITY FAILURE: Cross-merchant attack succeeded');\n  } catch (error) {\n    console.log('✓ SECURITY SUCCESS: Cross-merchant blocked:', error.message);\n  }\n}\n\n/**\n * Composite Token Pattern\n * Embed payment mandate alongside token for AP2 compliance\n */\nasync function compositeTokenExample() {\n  const tokenizer = new TokenizationService();\n  \n  // Tokenize credential\n  const tokenResult = await tokenizer.tokenize(\n    { type: 'card', number: '4111111111111111' },\n    { checkout_id: 'chk_123', identity: { access_token: 'merchant_1' } }\n  );\n  \n  // Create composite token (token + AP2 payment mandate)\n  const compositeToken = {\n    type: 'token',\n    token: tokenResult.token,\n    payment_mandate: 'eyJhbGciOiJFUzI1NiIsInR5cCI6InZjK3NkLWp3dCJ9...' // SD-JWT\n  };\n  \n  console.log('✓ Composite token created with payment mandate');\n  return compositeToken;\n}\n\n// Run examples\nexampleTokenizationFlow().catch(console.error);\n</code></pre><h4>Security Best Practices</h4><ul><li><strong>Always require binding</strong> - Never generate unbound tokens</li><li><strong>Cryptographic randomness</strong> - Use crypto.randomBytes, not Math.random()</li><li><strong>Minimum 128-bit entropy</strong> - Tokens must be unguessable</li><li><strong>Single-use preferred</strong> - Invalidate after first detokenization when possible</li><li><strong>Short TTL</strong> - 5-30 minutes maximum, 15 minutes typical</li><li><strong>Verify binding on detokenize</strong> - NEVER skip binding verification</li><li><strong>Encrypt at rest</strong> - Store credential-to-token mappings encrypted</li><li><strong>Audit logging</strong> - Log all tokenize/detokenize operations</li></ul><h4>Attack Scenarios</h4><table><thead><tr><th>Attack</th><th>Tokenization Defense</th></tr></thead><tbody><tr><td>Token replay</td><td>Single-use enforcement + binding verification</td></tr><tr><td>Cross-merchant theft</td><td>Binding verifies business_id matches</td></tr><tr><td>Token guessing</td><td>128+ bit entropy makes brute force infeasible</td></tr><tr><td>Expired token reuse</td><td>TTL enforcement deletes expired tokens</td></tr><tr><td>Checkout hijacking</td><td>Binding verifies checkout_id matches</td></tr></tbody></table><h4>PCI-DSS Scope Reduction</h4><p>Tokenization removes systems from PCI scope:</p><ul><li><strong>Platform</strong> - Never stores raw card data, only receives tokens</li><li><strong>Business</strong> - Receives tokens, not card numbers (out of PCI scope)</li><li><strong>Tokenizer</strong> - Only system that must be PCI-DSS certified</li><li><strong>PSP</strong> - Receives detokenized credentials in secure processing environment</li></ul>",
          "resources": [
            {
              "type": "spec",
              "url": "https://ucp.dev/specification/tokenization-guide",
              "label": "Tokenization Guide"
            },
            {
              "type": "spec",
              "url": "https://ucp.dev/specification/payment-handler-guide",
              "label": "Payment Handler Guide"
            },
            {
              "type": "doc",
              "url": "https://www.pcisecuritystandards.org/",
              "label": "PCI-DSS Standards"
            }
          ]
        },
        {
          "id": "signing-keys",
          "label": "JWK Signing Keys",
          "description": "Message signature verification",
          "content": "<h3>JWK Signing Keys - Cryptographic Message Integrity</h3><p>JSON Web Keys (JWK) provide public key infrastructure for message signing and verification in UCP. All parties publish signing keys in their profiles, enabling cryptographic verification of webhooks, checkout responses, and authenticated messages. This prevents message tampering, impersonation, and repudiation attacks.</p><h4>Threat Model</h4><ul><li><strong>Message Tampering</strong> - Detect modifications to checkout data, totals, or terms</li><li><strong>Impersonation</strong> - Prevent attackers from forging messages as legitimate parties</li><li><strong>Repudiation</strong> - Provide non-repudiable proof of message origin</li><li><strong>Algorithm Confusion</strong> - Prevent 'none' algorithm or weak algorithm attacks</li></ul><h4>JWK Key Types</h4><table><thead><tr><th>Algorithm</th><th>Key Type</th><th>Security Level</th><th>Use Case</th></tr></thead><tbody><tr><td><code>ES256</code></td><td>ECDSA P-256</td><td>Recommended for most use cases</td></tr><tr><td><code>ES384</code></td><td>ECDSA P-384</td><td>Higher security, larger signatures</td></tr><tr><td><code>ES512</code></td><td>ECDSA P-521</td><td>Maximum security, larger signatures</td></tr><tr><td><code>RS256</code></td><td>RSA 2048-bit</td><td>Widely supported, larger key size</td></tr></tbody></table><h4>Complete JWK Signing Implementation</h4><pre><code class=\"language-javascript\">import * as jose from 'jose';\nimport canonicalize from 'canonicalize';\n\n/**\n * JWK Signing Service\n * Implements key generation, signature creation, and verification\n */\nclass JWKSigningService {\n  constructor() {\n    this.keyStore = new Map();\n  }\n\n  /**\n   * STEP 1: Generate signing key pair\n   * Use ECDSA P-256 (ES256) for optimal security/performance\n   */\n  async generateKeyPair(keyId) {\n    try {\n      // Generate EC P-256 key pair (RECOMMENDED by UCP)\n      const { publicKey, privateKey } = await jose.generateKeyPair('ES256');\n      \n      // Export as JWK for profile publication\n      const publicJWK = await jose.exportJWK(publicKey);\n      publicJWK.kid = keyId;\n      publicJWK.use = 'sig';\n      publicJWK.alg = 'ES256';\n      \n      console.log('✓ Key pair generated for signing');\n      \n      return {\n        privateKey,\n        publicKey,\n        jwk: publicKeyJWK\n      };\n    } catch (error) {\n      throw new Error(`Key generation failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * STEP 2: Sign message (webhook, checkout response, etc.)\n   * Uses JWS compact serialization\n   */\n  async signMessage(payload, privateKey, kid) {\n    try {\n      // Sign with ES256 (ECDSA P-256 SHA-256)\n      const jwt = await new jose.SignJWT(payload)\n        .setProtectedHeader({ \n          alg: 'ES256',\n          kid: kid,\n          typ: 'JWT'\n        })\n        .setIssuedAt()\n        .setExpirationTime('5m') // Signatures expire after 5 minutes\n        .sign(privateKey);\n      \n      return jwt;\n    } catch (error) {\n      throw new Error(`Signature generation failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * STEP 2: Verify signed message\n   * Recipient validates signature before trusting content\n   */\n  async verifyMessage(jws, expectedIssuer) {\n    try {\n      // Fetch issuer's public keys from UCP profile\n      const profile = await fetch(`${expectedIssuer}/.well-known/ucp`)\n        .then(r => r.json());\n      \n      if (!profile.signing_keys || profile.signing_keys.length === 0) {\n        throw new Error('No signing keys found in profile');\n      }\n      \n      // Parse JWS header to get key ID\n      const header = jose.decodeProtectedHeader(jws);\n      \n      // Find matching public key\n      const jwk = profile.signing_keys.find(k => k.kid === header.kid);\n      if (!jwk) {\n        throw new Error(`Key not found: ${header.kid}`);\n      }\n      \n      // Import public key from JWK\n      const publicKey = await jose.importJWK(jwk, header.alg);\n      \n      // Verify signature\n      const { payload } = await jose.compactVerify(jws, publicKey);\n      \n      console.log('✓ Signature verified');\n      return JSON.parse(new TextDecoder().decode(payload));\n    } catch (error) {\n      throw new Error(`Signature verification failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * STEP 3: Sign webhook payload\n   * Business signs webhook notifications to prove authenticity\n   */\n  async signWebhook(webhookPayload, privateKey, kid) {\n    try {\n      const jwt = await new jose.SignJWT(webhookPayload)\n        .setProtectedHeader({ \n          alg: 'ES256',\n          kid: kid,\n          typ: 'webhook+jwt'\n        })\n        .setIssuedAt()\n        .setExpirationTime('5m') // Webhooks expire quickly\n        .sign(privateKey);\n      \n      return jwt;\n    } catch (error) {\n      throw new Error(`Webhook signing failed: ${error.message}`);\n    }\n  }\n\n  /**\n   * STEP 4: Rotate signing keys\n   * Best practice: rotate keys periodically, maintain overlap period\n   */\n  async rotateKey(oldKid, newKeyPair) {\n    try {\n      // Generate new key\n      const publicJWK = await jose.exportJWK(newKeyPair.publicKey);\n      const newKid = `key_${Date.now()}`;\n      \n      const newKey = {\n        kid: newKid,\n        kty: publicKey.kty,\n        crv: publicKey.crv,\n        x: publicKey.x,\n        y: publicKey.y,\n        use: 'sig',\n        alg: 'ES256'\n      };\n      \n      // Publish both old and new keys during rotation period\n      // Remove old key after rotation window (24-48 hours typical)\n      const rotatedKeys = [\n        newKey,\n        oldKey  // Keep for verification of in-flight messages\n      ];\n      \n      return rotatedKeys;\n    }\n  }\n}\n\n/**\n * Example: Complete signature lifecycle\n */\nasync function exampleSignatureFlow() {\n  const keyManager = new SigningKeyManager();\n  \n  // STEP 1: Business generates and publishes keys\n  console.log('\\n--- BUSINESS: Generate signing keys ---');\n  const businessKeys = await keyManager.generateKeyPair('merchant_2025');\n  \n  // STEP 2: Business signs checkout response\n  console.log('\\n--- BUSINESS: Sign checkout response ---');\n  const checkout = {\n    id: 'chk_abc123',\n    totals: [{ type: 'total', amount: 5400 }]\n  };\n  \n  const signedCheckout = await keyManager.signData(\n    checkout,\n    businessKeys.privateKey,\n    'merchant_2025'\n  );\n  \n  console.log('Signature:', signedCheckout.signature.substring(0, 30) + '...');\n  \n  // STEP 3: Platform verifies signature\n  console.log('\\n--- PLATFORM: Verify signature ---');\n  const isValid = await keyManager.verifySignature(\n    signedCheckout.data,\n    signedCheckout.signature,\n    businessKeys.publicKey\n  );\n  \n  console.log('Verification:', isValid ? '✓ Valid' : '❌ Invalid');\n  \n  // STEP 4: Attack scenario - tampered data\n  console.log('\\n--- ATTACK SCENARIO: Data tampering ---');\n  const tamperedData = { ...checkout, totals: [{ type: 'total', amount: 1 }] };\n  \n  const isTamperedValid = await keyManager.verifySignature(\n    tamperedData,\n    signedCheckout.signature,\n    businessKeys.publicKey\n  );\n  \n  console.log('Tampered verification:', isTamperedValid ? '❌ SECURITY FAILURE' : '✓ Tampering detected');\n  \n  // STEP 5: Key rotation\n  console.log('\\n--- BUSINESS: Rotate signing keys ---');\n  const rotatedKeys = await keyManager.rotateKey(\n    'merchant_2025',\n    'merchant_2026',\n    businessKeys\n  );\n  \n  console.log(`✓ Keys rotated: ${rotatedKeys.length} keys in profile`);\n}\n\nexampleSignatureFlow().catch(console.error);\n</code></pre><h4>Security Best Practices</h4><ul><li><strong>ES256 minimum</strong> - Use ECDSA P-256 or stronger, avoid RSA &lt; 2048 bits</li><li><strong>Unique kid per key</strong> - Key IDs must be unique and descriptive</li><li><strong>Regular rotation</strong> - Rotate keys annually or after suspected compromise</li><li><strong>Dual key publication</strong> - Keep old and new keys during rotation window</li><li><strong>Private key isolation</strong> - Never expose private keys to client-side code</li><li><strong>Algorithm allowlist</strong> - Reject 'none' algorithm and weak signatures</li><li><strong>Signature timing attacks</strong> - Use constant-time comparison for signature verification</li></ul><h4>Attack Scenarios</h4><table><thead><tr><th>Attack</th><th>JWK Defense</th></tr></thead><tbody><tr><td>Message tampering</td><td>Signature verification fails on any data modification</td></tr><tr><td>Algorithm substitution</td><td>Algorithm allowlist rejects 'none' or downgrade attempts</td></tr><tr><td>Key confusion</td><td>kid lookup ensures correct key used for verification</td></tr><tr><td>Replay with old key</td><td>Key rotation invalidates signatures from rotated keys</td></tr></tbody></table><h4>Key Rotation Best Practices</h4><ol><li><strong>Generate new key</strong> - Create new key with new kid</li><li><strong>Publish both keys</strong> - Add new key to signing_keys array, keep old key</li><li><strong>Start signing with new key</strong> - Use new key for all new signatures</li><li><strong>Rotation window</strong> - Wait 24-48 hours for in-flight messages to settle</li><li><strong>Remove old key</strong> - Delete old key from signing_keys array after window</li></ol>",
          "resources": [
            {
              "type": "spec",
              "url": "https://ucp.dev/specification/ap2-mandates#signing-key-requirements",
              "label": "Signing Keys in AP2"
            },
            {
              "type": "doc",
              "url": "https://datatracker.ietf.org/doc/html/rfc7517",
              "label": "RFC 7517: JWK"
            },
            {
              "type": "doc",
              "url": "https://datatracker.ietf.org/doc/html/rfc7515",
              "label": "RFC 7515: JWS"
            }
          ]
        }
      ]
    },
    {
      "id": "annotations",
      "label": "6. UCP Annotation System",
      "description": "Source-to-spec generation",
      "content": "<h3>Schema Generation Architecture</h3><p>UCP uses a unique source-to-spec generation model with custom annotations.</p>",
      "resources": [
        {
          "type": "doc",
          "url": "https://ucp.dev/documentation/schema-authoring",
          "label": "Schema Authoring Guide"
        }
      ],
      "children": [
        {
          "id": "ucp-request",
          "label": "ucp_request Annotation",
          "description": "Controls field behavior in requests",
          "content": "<h3>ucp_request Annotation</h3>\n<p>Controls how fields behave in request schemas (create/update operations). This annotation enables minimal request payloads by explicitly declaring which fields the platform should send.</p>\n\n<h4>Annotation Values</h4>\n<table>\n  <tr><th>Value</th><th>Behavior</th><th>Use Case</th></tr>\n  <tr>\n    <td><code>omit</code></td>\n    <td>Field excluded from all request variants</td>\n    <td>Server-generated fields (ID, timestamps, computed totals)</td>\n  </tr>\n  <tr>\n    <td><code>optional</code></td>\n    <td>Field may be provided in requests</td>\n    <td>Optional buyer information, preferences</td>\n  </tr>\n  <tr>\n    <td><code>required</code></td>\n    <td>Field must be provided in requests</td>\n    <td>Essential checkout data (line_items, currency)</td>\n  </tr>\n</table>\n\n<h4>Per-Operation Annotations</h4>\n<p>Fine-grained control using object syntax:</p>\n<pre><code class=\"language-json\">{\n  \"ucp_request\": {\n    \"create\": \"omit\",     // Not in create_req.json\n    \"update\": \"required\"  // Required in update_req.json\n  }\n}</code></pre>\n\n<h4>Real Schema Example: checkout.json</h4>\n<pre><code class=\"language-json\">{\n  \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n  \"$id\": \"https://ucp.dev/schemas/shopping/checkout.json\",\n  \"properties\": {\n    \"ucp\": {\n      \"$ref\": \"../ucp.json#/$defs/response_checkout\",\n      \"ucp_request\": \"omit\"  // Never send metadata in requests\n    },\n    \"id\": {\n      \"type\": \"string\",\n      \"ucp_request\": {\n        \"create\": \"omit\",      // Server generates ID on create\n        \"update\": \"required\"   // Must specify which checkout to update\n      }\n    },\n    \"status\": {\n      \"type\": \"string\",\n      \"enum\": [\"incomplete\", \"ready_for_complete\", \"completed\"],\n      \"ucp_request\": \"omit\"  // Business controls status\n    },\n    \"buyer\": {\n      \"$ref\": \"types/buyer.json\",\n      \"ucp_request\": \"optional\"  // Platform may provide buyer info\n    },\n    \"line_items\": {\n      \"type\": \"array\",\n      \"items\": { \"$ref\": \"types/line_item.json\" },\n      \"ucp_request\": \"required\"  // Must have items to checkout\n    },\n    \"totals\": {\n      \"type\": \"array\",\n      \"ucp_request\": \"omit\"  // Business calculates totals\n    }\n  }\n}</code></pre>\n\n<h4>Generated Request Schemas</h4>\n<p>The <code>generate_schemas.py</code> script processes annotations to create:</p>\n<ul>\n  <li><strong>checkout.create_req.json</strong> - Contains only fields not marked <code>\"create\": \"omit\"</code></li>\n  <li><strong>checkout.update_req.json</strong> - Contains only fields not marked <code>\"update\": \"omit\"</code></li>\n  <li><strong>checkout_resp.json</strong> - Full schema (all fields except those marked <code>ucp_response: \"omit\"</code>)</li>\n</ul>\n\n<h4>Common Patterns</h4>\n<table>\n  <tr><th>Field Type</th><th>Typical Annotation</th></tr>\n  <tr><td>IDs (server-generated)</td><td><code>{\"create\": \"omit\", \"update\": \"required\"}</code></td></tr>\n  <tr><td>Computed fields (totals, status)</td><td><code>\"omit\"</code></td></tr>\n  <tr><td>Immutable fields (type, currency)</td><td><code>{\"create\": \"required\", \"update\": \"omit\"}</code></td></tr>\n  <tr><td>User-provided data (buyer info)</td><td><code>\"optional\"</code></td></tr>\n  <tr><td>Essential inputs (line_items)</td><td><code>\"required\"</code></td></tr>\n</table>",
          "resources": [
            {
              "type": "doc",
              "url": "https://ucp.dev/documentation/schema-authoring/",
              "label": "Schema Authoring Guide"
            },
            {
              "type": "schema",
              "url": "https://ucp.dev/schemas/shopping/checkout.json",
              "label": "Checkout Schema (annotated)"
            },
            {
              "type": "tool",
              "url": "https://github.com/Universal-Commerce-Protocol/ucp/blob/main/generate_schemas.py",
              "label": "Schema Generator Tool"
            }
          ]
        },
        {
          "id": "ucp-response",
          "label": "ucp_response Annotation",
          "description": "Controls field in responses",
          "content": "<h3>ucp_response Annotation</h3>\n<p>Controls whether fields appear in response schemas. Unlike <code>ucp_request</code>, this annotation only has one value: <code>omit</code>. All fields are included in responses by default.</p>\n\n<h4>Annotation Value</h4>\n<table>\n  <tr><th>Value</th><th>Behavior</th><th>Use Case</th></tr>\n  <tr>\n    <td><code>omit</code></td>\n    <td>Field excluded from response schema</td>\n    <td>Internal business logic, private computed fields</td>\n  </tr>\n  <tr>\n    <td>(no annotation)</td>\n    <td>Field included in response (default)</td>\n    <td>All public checkout data</td>\n  </tr>\n</table>\n\n<h4>When to Use ucp_response: \"omit\"</h4>\n<p>Rarely needed. Use only for:</p>\n<ul>\n  <li><strong>Internal-only fields:</strong> Private business logic that shouldn't leak to API</li>\n  <li><strong>Temporary migration fields:</strong> Deprecated fields being phased out</li>\n  <li><strong>Sensitive business data:</strong> Profit margins, internal cost calculations</li>\n</ul>\n\n<h4>Default Behavior: Rich Responses</h4>\n<p>UCP philosophy: <strong>minimal requests, rich responses</strong></p>\n<ul>\n  <li>Platforms send minimal data (only what business needs)</li>\n  <li>Business returns comprehensive state (everything platform might need)</li>\n  <li>Default: all fields appear in responses unless explicitly omitted</li>\n</ul>\n\n<h4>Example: Item Schema</h4>\n<pre><code class=\"language-json\">// From types/item.json\n{\n  \"properties\": {\n    \"fulfillment_availability\": {\n      \"type\": \"string\",\n      \"enum\": [\"available\", \"unavailable\"],\n      \"ucp_request\": \"omit\"\n      // Platform doesn't send this (business calculates based on inventory)\n      // But response includes it (platform needs to know if item is in stock)\n    },\n    \"unit_price\": {\n      \"$ref\": \"price.json\",\n      \"ucp_request\": \"omit\"\n      // Business controls pricing (not sent in requests)\n      // Response includes pricing so platform can display to user\n    },\n    \"quantity\": {\n      \"type\": \"integer\",\n      \"ucp_request\": \"required\"\n      // Platform must specify quantity in requests\n      // Response echoes quantity back (for confirmation)\n    }\n  }\n}</code></pre>",
          "resources": [
            {
              "type": "doc",
              "url": "https://ucp.dev/documentation/schema-authoring/",
              "label": "Schema Authoring Guide"
            },
            {
              "type": "schema",
              "url": "https://ucp.dev/schemas/shopping/types/item.json",
              "label": "Item Schema (with response annotations)"
            }
          ]
        },
        {
          "id": "ucp-shared-request",
          "label": "ucp_shared_request Annotation",
          "description": "Applies to both create and update",
          "content": "<h3>ucp_shared_request Annotation</h3>\n<p>Applied at the schema root level, this boolean annotation indicates the schema should be <strong>identical</strong> for both create and update operations. This is an optimization for schemas where field behavior doesn't change between operations.</p>\n\n<h4>Annotation Value</h4>\n<table>\n  <tr><th>Value</th><th>Behavior</th><th>Generated Files</th></tr>\n  <tr>\n    <td><code>true</code></td>\n    <td>Same schema for create and update</td>\n    <td><code>type.req.json</code> (single file)</td>\n  </tr>\n  <tr>\n    <td>(no annotation or <code>false</code>)</td>\n    <td>Separate schemas for each operation</td>\n    <td><code>type.create_req.json</code>, <code>type.update_req.json</code></td>\n  </tr>\n</table>\n\n<h4>When to Use ucp_shared_request: true</h4>\n<p>Use when:</p>\n<ul>\n  <li>All fields have the same behavior in create and update</li>\n  <li>No fields use per-operation annotations like <code>{\"create\": \"omit\", \"update\": \"required\"}</code></li>\n  <li>The schema is a simple data container (address, contact info)</li>\n</ul>\n\n<h4>Real Schema Example: Fulfillment</h4>\n<pre><code class=\"language-json\">// From types/fulfillment.json\n{\n  \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n  \"$id\": \"https://ucp.dev/schemas/shopping/types/fulfillment.json\",\n  \"title\": \"Fulfillment\",\n  \"ucp_shared_request\": true,  // ← Applied at root level\n\n  \"type\": \"object\",\n  \"properties\": {\n    \"methods\": {\n      \"type\": \"array\",\n      \"items\": { \"$ref\": \"fulfillment_method.json\" },\n      \"description\": \"Fulfillment methods (shipping/pickup)\"\n      // No per-operation annotations - same behavior in create and update\n    },\n    \"instructions\": {\n      \"type\": \"string\",\n      \"description\": \"Delivery instructions\",\n      \"ucp_request\": \"optional\"\n      // Simple annotation applies to both create and update\n    }\n  }\n}</code></pre>\n\n<h4>Decision Tree</h4>\n<pre><code>Does your schema have fields with different create vs update behavior?\n├─ YES → Don't use ucp_shared_request (use per-operation annotations)\n│         Example: checkout.json (id omitted in create, required in update)\n│\n└─ NO → Use ucp_shared_request: true (optimize with single request schema)\n          Example: fulfillment.json (fields same in create/update)\n</code></pre>",
          "resources": [
            {
              "type": "schema",
              "url": "https://ucp.dev/schemas/shopping/types/fulfillment.json",
              "label": "Fulfillment Schema (shared request)"
            },
            {
              "type": "schema",
              "url": "https://ucp.dev/schemas/shopping/types/fulfillment_option.json",
              "label": "Fulfillment Option (shared request)"
            },
            {
              "type": "tool",
              "url": "https://github.com/Universal-Commerce-Protocol/ucp/blob/main/generate_schemas.py",
              "label": "Schema Generator (collect_annotated_schemas)"
            }
          ]
        },
        {
          "id": "generation-passes",
          "label": "3-Pass Generation System",
          "description": "How schemas are generated",
          "content": "<h3>3-Pass Schema Generation System</h3>\n<p>UCP uses a multi-pass generation pipeline that transforms annotated source schemas into specification-ready output schemas. The <code>generate_schemas.py</code> script orchestrates this process.</p>\n\n<h4>Generation Pipeline Overview</h4>\n<pre><code>source/                           spec/\n  schemas/shopping/               schemas/shopping/\n    checkout.json (annotated)  →    checkout.create_req.json\n                                    checkout.update_req.json\n                                    checkout_resp.json\n\n    types/                          types/\n      buyer.json (no annotations) →   buyer.json (copied as-is)\n      item.json (annotated)       →   item.create_req.json\n                                      item.update_req.json\n                                      item_resp.json\n</code></pre>\n\n<h4>Pass 1: Collect Annotated Schemas</h4>\n<p><strong>Purpose:</strong> Identify which schemas have UCP annotations and whether they use shared requests.</p>\n\n<p><strong>Process:</strong></p>\n<ol>\n  <li>Walk <code>source/</code> directory recursively</li>\n  <li>Load each JSON schema file</li>\n  <li>Check for presence of <code>ucp_request</code>, <code>ucp_response</code>, or <code>ucp_shared_request</code></li>\n  <li>Record absolute path and whether schema uses <code>ucp_shared_request: true</code></li>\n  <li>Validate annotation syntax (correct values, recognized operations)</li>\n</ol>\n\n<h4>Pass 2: Transform and Rewrite $refs</h4>\n<p><strong>Purpose:</strong> Generate per-operation schemas and rewrite <code>$ref</code> pointers to target the correct variant.</p>\n\n<p><strong>Process for Each Annotated Schema:</strong></p>\n<ol>\n  <li><strong>Create Request Schemas:</strong>\n    <ul>\n      <li>If <code>ucp_shared_request: true</code>: Generate single <code>*.req.json</code></li>\n      <li>Otherwise: Generate <code>*.create_req.json</code> and <code>*.update_req.json</code></li>\n    </ul>\n  </li>\n  <li><strong>Process Each Field:</strong>\n    <ul>\n      <li>Check <code>ucp_request</code> annotation</li>\n      <li>If value is <code>\"omit\"</code>: exclude field</li>\n      <li>Otherwise: include field, preserving validations</li>\n    </ul>\n  </li>\n  <li><strong>Rewrite $refs:</strong>\n    <ul>\n      <li>If ref targets an annotated schema: rewrite to operation-specific variant</li>\n      <li>Example: <code>\"$ref\": \"types/item.json\"</code> → <code>\"$ref\": \"types/item.create_req.json\"</code></li>\n    </ul>\n  </li>\n  <li><strong>Create Response Schema:</strong>\n    <ul>\n      <li>Include all fields except those marked <code>ucp_response: \"omit\"</code></li>\n    </ul>\n  </li>\n</ol>\n\n<h4>Pass 3: Generate Embedded Protocol Spec</h4>\n<p><strong>Purpose:</strong> Create the Embedded Checkout Protocol (ECP) OpenRPC specification by aggregating methods from base service and extensions.</p>\n\n<h4>Running the Generator</h4>\n<pre><code class=\"language-bash\"># From repo root\npython generate_schemas.py\n\n# Output:\n# Pass 1: Collecting annotated schemas...\n#   Found 23 annotated schemas (4 shared request)\n# Pass 2: Transforming schemas and rewriting $refs...\n#   Generated 46 request schemas, 23 response schemas\n# Pass 3: Generating Embedded Protocol spec...\n#   Added 12 methods from extensions\n# ✅ Spec generation complete: spec/\n</code></pre>",
          "resources": [
            {
              "type": "tool",
              "url": "https://github.com/Universal-Commerce-Protocol/ucp/blob/main/generate_schemas.py",
              "label": "Schema Generator (Full Source)"
            },
            {
              "type": "doc",
              "url": "https://ucp.dev/documentation/schema-authoring/",
              "label": "Schema Authoring Guide"
            },
            {
              "type": "doc",
              "url": "https://ucp.dev/documentation/core-concepts/",
              "label": "Core Concepts"
            }
          ]
        }
      ]
    },
    {
      "id": "extensions",
      "label": "7. Extensions System",
      "description": "Modular feature enhancement",
      "content": "<h3>Extension Architecture</h3><p>Extensions provide optional enhancements to core capabilities without bloating the protocol.</p>",
      "children": [
        {
          "id": "discount-extension",
          "label": "Discount Extension",
          "description": "Promotions and adjustments",
          "content": "<h3>Discount Extension</h3><p><strong>Name:</strong> <code>dev.ucp.shopping.discount</code></p><p><strong>Purpose:</strong> Apply promotional discounts to checkout</p><p><strong>Features:</strong></p><ul><li>Coupon codes</li><li>Automatic discounts (cart total thresholds)</li><li>Line item vs order-level discounts</li><li>Discount stacking rules</li></ul>",
          "resources": [
            {
              "type": "spec",
              "url": "https://ucp.dev/specification/discount/",
              "label": "Discount Extension Specification"
            },
            {
              "type": "schema",
              "url": "https://ucp.dev/schemas/shopping/discount.json",
              "label": "Discount Schema"
            }
          ]
        },
        {
          "id": "fulfillment-extension",
          "label": "Fulfillment Extension",
          "description": "Advanced shipping features",
          "content": "<h3>Fulfillment Extension</h3><p><strong>Name:</strong> <code>dev.ucp.shopping.fulfillment</code></p><p><strong>Purpose:</strong> Enhanced shipping and delivery options</p><p><strong>Features:</strong></p><ul><li>Multiple fulfillment groups (split shipments)</li><li>Real-time shipping rates</li><li>Delivery time estimates</li><li>Pickup options (BOPIS - Buy Online Pickup In Store)</li></ul>",
          "resources": [
            {
              "type": "spec",
              "url": "https://ucp.dev/specification/fulfillment/",
              "label": "Fulfillment Extension Specification"
            },
            {
              "type": "schema",
              "url": "https://ucp.dev/schemas/shopping/fulfillment.json",
              "label": "Fulfillment Schema"
            }
          ]
        },
        {
          "id": "declaring-extensions",
          "label": "Declaring Extensions",
          "description": "How to advertise support",
          "content": "<h3>Extension Declaration</h3><p>Businesses declare extensions in their UCP profile:</p><pre>{\n  \"capabilities\": [\n    {\n      \"name\": \"dev.ucp.shopping.checkout\",\n      \"extensions\": [\"dev.ucp.shopping.discount\", \"dev.ucp.shopping.fulfillment\"]\n    }\n  ]\n}</pre><p>Platforms read this to know which optional features are available.</p>",
          "resources": [
            {
              "type": "spec",
              "url": "https://ucp.dev/specification/overview/#capability-declaration",
              "label": "Capability Declaration"
            },
            {
              "type": "doc",
              "url": "https://ucp.dev/documentation/core-concepts/",
              "label": "Core Concepts - Extensions"
            }
          ]
        }
      ]
    },
    {
      "id": "capabilities",
      "label": "8. Capabilities Deep Dive",
      "description": "Four foundational capabilities",
      "content": "<h3>Official UCP Capabilities</h3><p>UCP v1 defines four core capabilities for commerce transactions.</p>",
      "children": [
        {
          "id": "checkout-capability",
          "label": "dev.ucp.shopping.checkout",
          "description": "End-to-end checkout flow",
          "content": "<h3>Checkout Capability</h3><p>The most complex capability - handles entire checkout lifecycle:</p><p><strong>Flow:</strong></p><ol><li><strong>create</strong> - Initialize with items, buyer info</li><li><strong>update</strong> - Iteratively add payment, shipping, apply discounts</li><li><strong>update</strong> - Business calculates tax, validates availability</li><li><strong>complete</strong> - Finalize order, return confirmation</li></ol><p><strong>Transports:</strong> REST, MCP, A2A, Embedded</p>",
          "resources": [
            {
              "type": "spec",
              "url": "https://ucp.dev/specification/checkout",
              "label": "Checkout Full Specification"
            }
          ]
        },
        {
          "id": "identity-linking",
          "label": "dev.ucp.common.identity_linking",
          "description": "OAuth 2.0 authorization",
          "content": "<h3>Identity Linking Capability</h3><p>OAuth 2.0 flow for platforms to obtain authorization:</p><ul><li>Platform requests authorization to act on user's behalf</li><li>User authenticates with Business</li><li>Business issues access token</li><li>Platform uses token for subsequent API calls</li></ul><p>Enables saved payment methods, order history access, etc.</p>",
          "resources": [
            {
              "type": "spec",
              "url": "https://ucp.dev/specification/identity-linking",
              "label": "Identity Linking Spec"
            }
          ]
        },
        {
          "id": "order-capability",
          "label": "dev.ucp.shopping.order",
          "description": "Post-purchase tracking",
          "content": "<h3>Order Capability</h3><p>Webhook-based updates for order lifecycle:</p><ul><li><strong>order.shipped</strong> - Item shipped with tracking</li><li><strong>order.delivered</strong> - Item delivered</li><li><strong>order.returned</strong> - Return initiated</li><li><strong>order.cancelled</strong> - Order cancelled</li></ul><p>Businesses push these events to platform webhook endpoints.</p>",
          "resources": [
            {
              "type": "spec",
              "url": "https://ucp.dev/specification/order",
              "label": "Order Specification"
            }
          ]
        },
        {
          "id": "payment-token-exchange",
          "label": "Payment Token Exchange",
          "description": "PSP ↔ CP token flow",
          "content": "<h3>Token Exchange Capability</h3><p>Secure protocol for PSPs to exchange tokens with Credential Providers:</p><ol><li>PSP receives tokenized payment from Business</li><li>PSP calls CP's token exchange endpoint</li><li>CP validates PSP's identity (signing keys)</li><li>CP returns decrypted payment data</li><li>PSP processes transaction</li></ol><p>Example: Google Pay → Stripe token exchange</p>",
          "resources": [
            {
              "type": "spec",
              "url": "https://ucp.dev/specification/tokenization-guide",
              "label": "Tokenization Guide"
            }
          ]
        }
      ]
    },
    {
      "id": "workflow",
      "label": "9. Development Workflow",
      "description": "Working with the codebase",
      "content": "<h3>Developer Workflow Mastery</h3><p>How to effectively work with UCP's schema generation system.</p>",
      "children": [
        {
          "id": "never-edit-spec",
          "label": "Never Edit spec/ Directly",
          "description": "Golden rule of UCP development",
          "content": "<h3>Critical Rule</h3><p><strong>NEVER manually edit files in spec/</strong></p><p>The spec/ directory is generated. Always:</p><ol><li>Edit schemas in <code>source/</code></li><li>Run <code>python generate_schemas.py</code></li><li>Verify outputs in <code>spec/</code></li></ol><p>Manual edits to spec/ will be overwritten on next generation.</p>",
          "resources": [
            {
              "type": "doc",
              "url": "https://ucp.dev/documentation/schema-authoring/",
              "label": "Schema Authoring Guide"
            },
            {
              "type": "tool",
              "url": "https://github.com/Universal-Commerce-Protocol/ucp/blob/main/generate_schemas.py",
              "label": "Schema Generator"
            }
          ]
        },
        {
          "id": "schema-workflow",
          "label": "Schema Development Loop",
          "description": "Edit → Generate → Validate",
          "content": "<h3>Complete Workflow</h3><ol><li><strong>Edit:</strong> Modify <code>source/schemas/shopping/types/buyer.json</code></li><li><strong>Generate:</strong> Run <code>python generate_schemas.py</code></li><li><strong>Validate:</strong> Run <code>python validate_specs.py</code></li><li><strong>Docs:</strong> Run <code>mkdocs serve --watch spec</code></li><li><strong>SDK:</strong> Run <code>bash scripts/ci_check_models.sh</code></li></ol>",
          "resources": [
            {
              "type": "doc",
              "url": "https://ucp.dev/documentation/schema-authoring/",
              "label": "Schema Authoring Guide"
            },
            {
              "type": "tool",
              "url": "https://github.com/Universal-Commerce-Protocol/ucp",
              "label": "UCP Repository"
            }
          ]
        },
        {
          "id": "adding-new-types",
          "label": "Adding New Schema Types",
          "description": "Step-by-step guide",
          "content": "<h3>New Type Workflow</h3><ol><li>Create <code>source/schemas/shopping/types/my_type.json</code></li><li>Add UCP annotations (<code>ucp_request</code>, <code>ucp_response</code>)</li><li>Run <code>python generate_schemas.py</code></li><li>Verify generated files in <code>spec/schemas/shopping/types/</code></li><li>Update documentation if needed</li><li>Check TypeScript generation works</li><li>May need to extend <code>generate_schemas.py</code> for new patterns</li></ol>",
          "resources": [
            {
              "type": "doc",
              "url": "https://ucp.dev/documentation/schema-authoring/",
              "label": "Schema Authoring Guide"
            },
            {
              "type": "schema",
              "url": "https://ucp.dev/schemas/shopping/types/",
              "label": "Type Schemas Reference"
            }
          ]
        },
        {
          "id": "documentation-system",
          "label": "Documentation System",
          "description": "MkDocs with custom macros",
          "content": "<h3>Doc Generation</h3><p>UCP docs use custom MkDocs macros in <code>main.py</code>:</p><ul><li><strong>schema_fields</strong> - Generates tables from JSON schemas</li><li><strong>method_fields</strong> - Generates tables from OpenAPI/OpenRPC</li></ul><p>These macros read directly from <code>spec/</code>, so schema changes automatically propagate to docs.</p><p><strong>Commands:</strong></p><ul><li><code>mkdocs serve --watch spec</code> - Local preview</li><li><code>mkdocs build --strict</code> - Production build (fails on warnings)</li></ul>",
          "resources": [
            {
              "type": "doc",
              "url": "https://ucp.dev/documentation/core-concepts/",
              "label": "Documentation Site"
            },
            {
              "type": "tool",
              "url": "https://github.com/Universal-Commerce-Protocol/ucp/blob/main/mkdocs.yml",
              "label": "MkDocs Configuration"
            }
          ]
        }
      ]
    },
    {
      "id": "study-strategy",
      "label": "10. Study Strategy by Goal",
      "description": "Learning paths for different roles",
      "content": "<h3>Role-Based Learning Paths</h3><p>Different developers need different perspectives on UCP.</p>",
      "children": [
        {
          "id": "platform-developer",
          "label": "Platform Developers",
          "description": "Building shopping agents/apps",
          "content": "<h3>For Platform Developers</h3><p>Implementing a shopping agent or app that uses UCP:</p><ol><li><strong>core-concepts.md</strong> → Understand the four actors</li><li><strong>discovery/profile_schema.json</strong> → Parse business profiles</li><li><strong>checkout-mcp.md</strong> → MCP implementation for AI agents</li><li><strong>checkout.json + types/*</strong> → Data models</li><li><strong>buyer-consent.md</strong> → User permission framework</li></ol><p><strong>Key Focus:</strong> Calling UCP APIs, handling responses, UI/UX for checkout</p>",
          "resources": [
            {
              "type": "spec",
              "url": "https://ucp.dev/specification/checkout/",
              "label": "Start: Checkout Specification"
            },
            {
              "type": "spec",
              "url": "https://ucp.dev/specification/overview/#discovery-governance-and-negotiation",
              "label": "Discovery & Profiles"
            },
            {
              "type": "spec",
              "url": "https://ucp.dev/specification/embedded-checkout/",
              "label": "Embedded Protocol (if building widget)"
            },
            {
              "type": "doc",
              "url": "https://ucp.dev/documentation/core-concepts/",
              "label": "Core Concepts"
            }
          ]
        },
        {
          "id": "business-integrator",
          "label": "Business Integrators",
          "description": "Exposing inventory via UCP",
          "content": "<h3>For Business Integrators</h3><p>Exposing your inventory and implementing UCP endpoints:</p><ol><li><strong>core-concepts.md</strong> → Understand Merchant of Record role</li><li><strong>checkout-rest.md</strong> → REST endpoint implementation</li><li><strong>embedded-checkout.md</strong> → iframe integration patterns</li><li><strong>fulfillment.json</strong> → Shipping logic</li><li><strong>discount.json</strong> → Promotions system</li></ol><p><strong>Key Focus:</strong> Implementing endpoints, calculating tax/shipping, inventory management</p>",
          "resources": [
            {
              "type": "spec",
              "url": "https://ucp.dev/specification/checkout/",
              "label": "Start: Checkout Specification"
            },
            {
              "type": "spec",
              "url": "https://ucp.dev/specification/checkout-rest/",
              "label": "REST Transport Binding"
            },
            {
              "type": "guide",
              "url": "https://ucp.dev/specification/payment-handler-guide/",
              "label": "Payment Handler Guide"
            },
            {
              "type": "doc",
              "url": "https://ucp.dev/documentation/schema-authoring/",
              "label": "Schema Authoring (for extensions)"
            }
          ]
        },
        {
          "id": "psp-cp-developer",
          "label": "PSP/CP Developers",
          "description": "Payment infrastructure",
          "content": "<h3>For PSP/CP Developers</h3><p>Building payment service providers or credential providers:</p><ol><li><strong>tokenization-guide.md</strong> → Token exchange flows</li><li><strong>payment-handler-guide.md</strong> → Handler integration</li><li><strong>handlers/tokenization/google_pay/</strong> → Reference implementation</li><li><strong>ap2-mandates.md</strong> → Security requirements (3DS, SCA)</li></ol><p><strong>Key Focus:</strong> Secure token exchange, PCI compliance, authentication mandates</p>",
          "resources": [
            {
              "type": "guide",
              "url": "https://ucp.dev/specification/tokenization-guide/",
              "label": "Start: Tokenization Guide"
            },
            {
              "type": "spec",
              "url": "https://ucp.dev/specification/ap2-mandates/",
              "label": "AP2 Mandates (3DS, SCA)"
            },
            {
              "type": "guide",
              "url": "https://ucp.dev/specification/payment-handler-guide/",
              "label": "Payment Handler Guide"
            }
          ]
        },
        {
          "id": "protocol-contributor",
          "label": "Protocol Contributors",
          "description": "Contributing to UCP itself",
          "content": "<h3>For Protocol Contributors</h3><p>Contributing schemas, documentation, or SDKs to UCP:</p><ol><li><strong>schema-authoring.md</strong> → Annotation system</li><li><strong>generate_schemas.py</strong> → Generation logic</li><li><strong>CONTRIBUTING.md</strong> → Process and conventions</li><li>All of the above 😄</li></ol><p><strong>Key Focus:</strong> Schema design, backward compatibility, documentation quality</p>",
          "resources": [
            {
              "type": "doc",
              "url": "https://ucp.dev/documentation/schema-authoring/",
              "label": "Start: Schema Authoring Guide"
            },
            {
              "type": "doc",
              "url": "https://ucp.dev/documentation/roadmap/",
              "label": "Roadmap"
            },
            {
              "type": "tool",
              "url": "https://github.com/Universal-Commerce-Protocol/ucp/blob/main/CONTRIBUTING.md",
              "label": "Contributing Guide"
            }
          ]
        }
      ]
    },
    {
      "id": "key-insights",
      "label": "11. Key Insights",
      "description": "Critical understanding for mastery",
      "content": "<h3>Core Principles to Internalize</h3><p>These insights represent deep understanding of UCP's design philosophy.</p>",
      "children": [
        {
          "id": "composability",
          "label": "Composable Architecture",
          "description": "Capabilities + Extensions",
          "content": "<h3>Composability Principle</h3><p>UCP breaks commerce into:</p><ul><li><strong>Capabilities</strong> - Complete flows (checkout, order)</li><li><strong>Extensions</strong> - Optional enhancements (discounts, loyalty)</li></ul><p>This allows businesses to implement only what they need while maintaining interoperability.</p><p>New capabilities and extensions can be added without breaking existing implementations.</p>",
          "resources": [
            {
              "type": "doc",
              "url": "https://ucp.dev/documentation/core-concepts/",
              "label": "Core Concepts"
            },
            {
              "type": "spec",
              "url": "https://ucp.dev/specification/overview/",
              "label": "UCP Overview"
            }
          ]
        },
        {
          "id": "data-flow",
          "label": "Typical Data Flow",
          "description": "End-to-end transaction",
          "content": "<h3>Standard Checkout Flow</h3><ol><li><strong>Discovery:</strong> Platform discovers Business via /.well-known/ucp</li><li><strong>Capabilities:</strong> Platform reads capabilities[] and payment.handlers[]</li><li><strong>Create:</strong> Platform calls checkout_create with initial state</li><li><strong>Options:</strong> Business responds with fulfillment options, payment methods</li><li><strong>Update:</strong> Platform calls checkout_update iteratively (add payment, select shipping)</li><li><strong>Validate:</strong> Business validates, applies logic (tax calculation, discount)</li><li><strong>Complete:</strong> Platform calls checkout_complete</li><li><strong>Order:</strong> Business places order, returns order_confirmation</li><li><strong>Webhooks:</strong> Business sends order updates (shipped, delivered)</li></ol>",
          "resources": [
            {
              "type": "spec",
              "url": "https://ucp.dev/specification/checkout/",
              "label": "Checkout Flow"
            },
            {
              "type": "guide",
              "url": "https://ucp.dev/specification/tokenization-guide/",
              "label": "Token Exchange"
            }
          ]
        },
        {
          "id": "security-layers",
          "label": "Multi-Layer Security",
          "description": "Defense in depth",
          "content": "<h3>Security Architecture</h3><p>UCP implements multiple security layers:</p><ul><li><strong>JWK Signing Keys</strong> - Message verification</li><li><strong>OAuth 2.0</strong> - Identity linking</li><li><strong>PCI-DSS Compliance</strong> - Via tokenization</li><li><strong>AP2 Mandates</strong> - 3DS and risk checks</li><li><strong>Buyer Consent</strong> - Explicit permissions for agents</li></ul><p>Each layer addresses a specific security concern without adding unnecessary complexity.</p>",
          "resources": [
            {
              "type": "guide",
              "url": "https://ucp.dev/specification/tokenization-guide/",
              "label": "Tokenization Guide"
            },
            {
              "type": "spec",
              "url": "https://ucp.dev/specification/identity-linking/",
              "label": "Identity Linking (OAuth)"
            }
          ]
        },
        {
          "id": "schema-philosophy",
          "label": "Schema Design Philosophy",
          "description": "Minimal requests, rich responses",
          "content": "<h3>Design Principles</h3><ul><li><strong>Minimal Requests:</strong> Omit fields with sensible defaults</li><li><strong>Rich Responses:</strong> Provide full context to platforms</li><li><strong>Idempotent Operations:</strong> Safe to retry failed requests</li><li><strong>Extensible:</strong> additionalProperties: true allows custom fields</li></ul><p>This reduces bandwidth while giving platforms everything they need.</p>",
          "resources": [
            {
              "type": "doc",
              "url": "https://ucp.dev/documentation/schema-authoring/",
              "label": "Schema Authoring Philosophy"
            },
            {
              "type": "doc",
              "url": "https://ucp.dev/documentation/core-concepts/",
              "label": "Core Concepts"
            }
          ]
        },
        {
          "id": "transport-agnostic",
          "label": "Transport Agnostic Design",
          "description": "One protocol, many transports",
          "content": "<h3>Transport Independence</h3><p>UCP capabilities are defined independently of transport:</p><ul><li>Same checkout capability works over REST, MCP, A2A, or Embedded</li><li>Businesses choose which transports to support</li><li>New transports can be added without changing core protocol</li></ul><p>This future-proofs UCP as new communication protocols emerge.</p>",
          "resources": [
            {
              "type": "spec",
              "url": "https://ucp.dev/specification/checkout-rest/",
              "label": "REST Transport"
            },
            {
              "type": "spec",
              "url": "https://ucp.dev/specification/checkout-mcp/",
              "label": "MCP Transport"
            },
            {
              "type": "spec",
              "url": "https://ucp.dev/specification/checkout-a2a/",
              "label": "A2A Transport"
            }
          ]
        }
      ]
    }
  ]
}