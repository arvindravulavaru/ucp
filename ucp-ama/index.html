<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>UCP Explorer</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Google+Sans:wght@400;450;500;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jsoneditor@9.10.5/dist/jsoneditor.min.css">
  <script src="https://cdn.jsdelivr.net/npm/jsoneditor@9.10.5/dist/jsoneditor.min.js"></script>
  <script type="module">
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
    mermaid.initialize({
      startOnLoad: false,
      theme: 'default',
      flowchart: {
        curve: 'basis',
        padding: 20,
        useMaxWidth: true,
        htmlLabels: true
      }
    });
    window.mermaid = mermaid;
  </script>
  <style>
    /* UCP.dev Base Styles */
    :root {
      --bg-primary: #ffffff;
      --bg-secondary: #f8f9fa;
      --bg-tertiary: #e8eaed;
      --text-primary: #202124;
      --text-secondary: #5f6368;
      --text-tertiary: #3c4043;
      --accent: #8b5cf6;
      --accent-hover: #7c3aed;
      --accent-light: #a78bfa;
      --border: #dadce0;
      --border-light: #e0e0e0;
      --shadow: rgba(0, 0, 0, 0.1);
      --shadow-heavy: rgba(0, 0, 0, 0.3);
    }

    body.dark-mode {
      --bg-primary: #202124;
      --bg-secondary: #292a2d;
      --bg-tertiary: #3c4043;
      --text-primary: #e8eaed;
      --text-secondary: #9aa0a6;
      --text-tertiary: #bdc1c6;
      --accent: #a78bfa;
      --accent-hover: #c4b5fd;
      --accent-light: #c4b5fd;
      --border: #5f6368;
      --border-light: #3c4043;
      --shadow: rgba(0, 0, 0, 0.3);
      --shadow-heavy: rgba(0, 0, 0, 0.5);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Google Sans', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      line-height: 1.6;
      transition: background 0.3s, color 0.3s;
      font-size: 1rem;
    }

    /* Header */
    .app-header {
      background-color: var(--bg-primary);
      border-bottom: 0.05rem solid var(--border);
      padding: 1rem 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: sticky;
      top: 0;
      z-index: 100;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 1rem;
      cursor: pointer;
    }

    .logo img {
      height: 32px;
    }

    body.dark-mode .logo img {
      content: url('inverted_logo.svg');
    }

    .logo h1 {
      font-size: 1.5rem;
      font-weight: 450;
      color: var(--text-primary);
      transition: color 0.2s;
      margin: 0;
    }

    .logo:hover h1 {
      color: var(--accent);
    }

    .header-actions {
      display: flex;
      gap: 0.75rem;
      align-items: center;
    }

    .header-actions button {
      background: transparent;
      border: 1px solid var(--border);
      border-radius: 50px;
      padding: 0.5rem 1rem;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 500;
      transition: all 0.2s;
      color: var(--text-primary);
      font-family: inherit;
    }

    .header-actions button:hover {
      background-color: var(--bg-tertiary);
    }

    #user-avatar {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border: 2px solid var(--border);
      cursor: pointer;
      transition: all 0.2s;
      object-fit: cover;
    }

    #user-avatar:hover {
      border-color: var(--accent);
      transform: scale(1.05);
    }

    /* Search Container */
    .search-container {
      max-width: 800px;
      margin: 2rem auto;
      padding: 0 1rem;
      position: relative;
    }

    .search-box {
      display: flex;
      gap: 0.5rem;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 50px;
      padding: 0.5rem 1rem;
      transition: border-color 0.2s;
    }

    .search-box:focus-within {
      border-color: var(--accent);
    }

    #search-input {
      flex: 1;
      border: none;
      background: transparent;
      font-size: 1rem;
      color: var(--text-primary);
      outline: none;
      font-family: inherit;
    }

    #search-btn {
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 50px;
      padding: 0.5rem 1.5rem;
      font-size: 1rem;
      cursor: pointer;
      font-weight: 500;
      transition: background 0.2s;
    }

    #search-btn:hover {
      background: var(--accent-light);
    }

    #suggestions {
      position: absolute;
      top: 100%;
      left: 1rem;
      right: 1rem;
      margin-top: 0.5rem;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 12px;
      max-height: 400px;
      overflow-y: auto;
      display: none;
      box-shadow: 0 4px 12px var(--shadow);
      z-index: 50;
    }

    #suggestions.active {
      display: block;
    }

    .suggestion-item {
      padding: 1rem;
      cursor: pointer;
      border-bottom: 1px solid var(--border);
      transition: background 0.2s;
    }

    .suggestion-item:last-child {
      border-bottom: none;
    }

    .suggestion-item:hover,
    .suggestion-item.highlighted {
      background: var(--bg-secondary);
    }

    .suggestion-question {
      font-weight: 500;
      color: var(--text-primary);
      margin-bottom: 0.25rem;
    }

    .suggestion-category {
      font-size: 1rem;
      color: var(--text-secondary);
    }

    /* Main Layout */
    .app-layout {
      display: flex;
      gap: 2rem;
      max-width: 1200px;
      margin: 0 auto;
      padding: 2rem 1rem;
    }

    /* Sidebar */
    .sidebar {
      width: 280px;
      position: sticky;
      top: 100px;
      height: fit-content;
    }

    .category-nav h3 {
      font-size: 1rem;
      text-transform: uppercase;
      color: var(--text-secondary);
      margin-bottom: 1rem;
      font-weight: 700;
      letter-spacing: 1.2px;
    }

    .category-nav ul {
      list-style: none;
    }

    .category-item {
      padding: 0.75rem 1rem;
      margin: 0.25rem 0;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 1rem;
      border: 1px solid transparent;
    }

    .category-item:hover {
      background: var(--bg-secondary);
    }

    .category-item.active {
      background: var(--bg-secondary);
      border-color: var(--accent);
      color: var(--text-primary);
    }

    .question-count {
      font-size: 1rem;
      color: var(--text-secondary);
    }

    .category-item.active .question-count {
      color: var(--accent);
      font-weight: 500;
    }

    /* Main Content */
    .main-content {
      flex: 1;
      max-width: 800px;
    }

    /* Breadcrumb Navigation */
    .breadcrumb {
      display: none;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
      font-size: 0.9rem;
      color: var(--text-secondary);
    }

    .breadcrumb.active {
      display: flex;
    }

    .breadcrumb-item {
      cursor: pointer;
      transition: color 0.2s;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .breadcrumb-item:hover {
      color: var(--accent);
    }

    .breadcrumb-separator {
      color: var(--text-tertiary);
    }

    .breadcrumb-current {
      color: var(--text-primary);
      font-weight: 500;
    }

    .welcome-card {
      background: var(--bg-secondary);
      border-radius: 24px;
      padding: 3rem 2rem;
      text-align: center;
    }

    .welcome-card h2 {
      font-size: 2rem;
      font-weight: 450;
      color: var(--text-primary);
      margin-bottom: 1rem;
    }

    .welcome-card p {
      color: var(--text-secondary);
      margin-bottom: 2rem;
      line-height: 1.5;
    }

    .popular-questions {
      text-align: left;
      margin-top: 2rem;
    }

    .popular-questions h3 {
      margin-bottom: 1rem;
      font-size: 1rem;
      font-weight: 450;
    }

    .popular-question {
      padding: 1rem;
      margin: 0.5rem 0;
      background: var(--bg-primary);
      border: 1px solid var(--border-light);
      border-radius: 16px;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 1rem;
    }

    .popular-question:hover {
      transform: translateX(4px);
      border-color: var(--accent);
    }

    /* Unified Content Card */
    .content-card {
      background: var(--bg-secondary);
      border-radius: 20px;
      border: 1px solid var(--border-light);
      overflow: hidden;
      display: none;
    }

    .content-card.active {
      display: block;
    }

    .content-section {
      padding: 2rem 2.5rem;
    }

    .content-divider {
      height: 1px;
      background: var(--border-light);
      margin: 0;
    }

    .question-card {
      background: transparent;
      border-radius: 0;
      padding: 0;
      margin-bottom: 0;
      display: block;
      border: none;
    }

    .question-text {
      font-size: 1.75rem;
      font-weight: 500;
      color: var(--text-primary);
      line-height: 1.3;
    }

    .question-category {
      display: inline-block;
      padding: 0.4rem 0.85rem;
      background: rgba(139, 92, 246, 0.1);
      border: 1px solid var(--accent);
      border-radius: 8px;
      font-size: 0.85rem;
      color: var(--accent);
      font-weight: 500;
      margin-bottom: 1rem;
    }

    body.dark-mode .question-category {
      background: rgba(167, 139, 250, 0.15);
      color: var(--accent-light);
    }

    /* Category Questions List */
    .category-questions-list {
      display: grid;
      gap: 0.75rem;
      margin-top: 1.5rem;
    }

    .category-question-item {
      padding: 1.25rem 1.5rem;
      background: var(--bg-primary);
      border: 1px solid var(--border-light);
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .category-question-item:hover {
      border-color: var(--accent);
      transform: translateX(4px);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    }

    .category-question-number {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--accent);
      background: rgba(139, 92, 246, 0.1);
      border: 1px solid var(--accent);
      padding: 0.35rem 0.65rem;
      border-radius: 6px;
      min-width: 2rem;
      text-align: center;
    }

    body.dark-mode .category-question-number {
      background: rgba(167, 139, 250, 0.15);
      color: var(--accent-light);
      border-color: var(--accent-light);
    }

    .category-question-text {
      font-size: 1rem;
      color: var(--text-primary);
      line-height: 1.4;
      flex: 1;
    }

    .question-meta {
      display: flex;
      gap: 1rem;
      color: var(--text-secondary);
      font-size: 1rem;
    }

    .answer-card {
      background: transparent;
      border: none;
      border-radius: 0;
      padding: 0;
      margin-bottom: 0;
      display: block;
      min-height: auto;
    }

    #answer-text {
      color: var(--text-primary);
      line-height: 1.8;
      font-size: 1rem;
    }

    #answer-text p {
      margin-bottom: 1rem;
    }

    #answer-text h1,
    #answer-text h2,
    #answer-text h3,
    #answer-text h4 {
      color: var(--text-primary);
      margin: 1.5rem 0 1rem 0;
      font-weight: 450;
    }

    #answer-text code {
      background: rgba(139, 92, 246, 0.08);
      color: var(--accent);
      padding: 0.2rem 0.5rem;
      border-radius: 4px;
      font-family: 'Monaco', 'Courier New', monospace;
      font-size: 0.9rem;
      font-weight: 500;
    }

    #answer-text pre {
      background: #282c34;
      padding: 1.25rem;
      border-radius: 12px;
      overflow-x: auto;
      margin: 1.5rem 0;
      border: 1px solid rgba(139, 92, 246, 0.2);
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    #answer-text pre code {
      background: transparent;
      padding: 0;
      font-size: 0.9rem;
      color: #abb2bf;
      font-weight: normal;
    }

    body.dark-mode #answer-text pre {
      background: #1e1e1e;
      border-color: rgba(167, 139, 250, 0.25);
    }

    #answer-text a {
      color: var(--accent);
      text-decoration: underline;
    }

    #answer-text a:hover {
      color: var(--accent-hover);
    }

    #answer-text ul, #answer-text ol {
      margin-left: 1.5rem;
      margin-bottom: 1rem;
    }

    .ask-ai-button {
      display: inline-block;
      margin-top: 2rem;
      padding: 0.75rem 1.5rem;
      background: var(--accent);
      color: white;
      border: 1px solid var(--accent);
      border-radius: 50px;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 500;
      transition: all 0.2s;
      text-decoration: none;
      font-family: inherit;
    }

    .ask-ai-button:hover {
      background: var(--accent-light);
      transform: translateY(-1px);
      box-shadow: 0 2px 8px var(--shadow);
    }

    .sources-section {
      background: transparent;
      border-radius: 0;
      padding: 0;
      margin-bottom: 0;
      display: block;
      border: none;
    }

    .sources-section h4 {
      margin-bottom: 1rem;
      color: var(--text-primary);
      font-weight: 500;
      font-size: 1rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .source-link {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.85rem 1.15rem;
      margin: 0.5rem 0;
      background: var(--bg-primary);
      border: 1px solid var(--border-light);
      border-radius: 10px;
      color: var(--accent);
      text-decoration: none;
      transition: all 0.2s;
      font-size: 0.95rem;
    }

    .source-link:hover {
      transform: translateX(4px);
      border-color: var(--accent);
      background: var(--bg-primary);
    }

    .source-link::before {
      content: '‚Üí';
      font-size: 1.1rem;
      font-weight: bold;
      color: var(--accent);
    }

    .actions {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      padding: 0;
      background: transparent;
      border-radius: 0;
      border: none;
    }

    .action-group {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }

    .actions-divider {
      width: 1px;
      height: 24px;
      background: var(--border);
      margin: 0 0.5rem;
    }

    .actions button {
      width: 36px;
      height: 36px;
      padding: 0;
      border: 1px solid var(--border);
      background: var(--bg-primary);
      color: var(--text-primary);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      display: none;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    .actions button:hover {
      background: var(--bg-tertiary);
      border-color: var(--accent);
      transform: translateY(-1px);
    }

    .actions button svg {
      width: 18px;
      height: 18px;
      fill: currentColor;
    }

    .actions button.bookmarked {
      background: #fff3cd;
      color: #856404;
      border-color: #ffc107;
    }

    .actions button.bookmarked svg {
      fill: #ffc107;
    }

    /* Navigation buttons have text */
    #prev-question-btn,
    #next-question-btn {
      width: auto;
      padding: 0 1rem;
      gap: 0.5rem;
      font-size: 0.9rem;
      font-weight: 500;
      font-family: inherit;
    }

    #prev-question-btn svg,
    #next-question-btn svg {
      width: 14px;
      height: 14px;
    }

    /* Tooltip on hover */
    .actions button::after {
      content: attr(title);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      margin-bottom: 8px;
      padding: 0.4rem 0.75rem;
      background: var(--text-primary);
      color: var(--bg-primary);
      font-size: 0.75rem;
      border-radius: 6px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
      z-index: 10;
    }

    .actions button:hover::after {
      opacity: 1;
    }

    /* Don't show tooltip on nav buttons (they have text) */
    #prev-question-btn::after,
    #next-question-btn::after {
      display: none;
    }

    /* Modal Base */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(4px);
      animation: fadeIn 0.2s ease;
    }

    .modal.active {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }

    .modal-content {
      background: var(--bg-primary);
      border-radius: 16px;
      max-width: 90%;
      max-height: 90vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      box-shadow: 0 10px 40px var(--shadow-heavy);
      animation: slideUp 0.3s ease;
    }

    @keyframes slideUp {
      from {
        transform: translateY(40px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    .modal-header {
      padding: 1.5rem 2rem;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: var(--bg-secondary);
    }

    .modal-header h3 {
      font-size: 1rem;
      font-weight: 450;
      margin: 0;
    }

    .modal-close {
      background: transparent;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      color: var(--text-secondary);
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      transition: background 0.2s;
      line-height: 1;
    }

    .modal-close:hover {
      background: var(--bg-tertiary);
    }

    #clear-history-btn {
      padding: 0.4rem 0.8rem;
      font-size: 0.85rem;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-light);
      border-radius: 6px;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.2s;
    }

    #clear-history-btn:hover {
      background: rgba(239, 68, 68, 0.1);
      border-color: rgba(239, 68, 68, 0.5);
      color: #ef4444;
    }

    .modal-body {
      padding: 2rem;
      overflow-y: auto;
      flex: 1;
    }

    /* Chat Modal */
    #chat-modal .modal-content {
      width: 75%;
      max-width: 1200px;
      height: 80vh;
    }

    .chat-messages-wrapper {
      position: relative;
      flex: 1;
      overflow: hidden;
    }

    .chat-messages {
      height: 100%;
      overflow-y: auto;
      padding: 1rem 0;
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }

    .scroll-to-bottom {
      position: absolute;
      bottom: 1rem;
      right: 1rem;
      width: 40px;
      height: 40px;
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 8px var(--shadow);
      transition: all 0.2s;
      opacity: 0;
      visibility: hidden;
      z-index: 10;
    }

    .scroll-to-bottom.visible {
      opacity: 1;
      visibility: visible;
    }

    .scroll-to-bottom:hover {
      background: var(--accent-light);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px var(--shadow);
    }

    .scroll-to-bottom svg {
      width: 20px;
      height: 20px;
    }

    .chat-message {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .chat-message.user {
      align-items: flex-end;
    }

    .chat-message.assistant {
      align-items: flex-start;
    }

    .chat-bubble {
      max-width: 85%;
      padding: 1rem 1.25rem;
      border-radius: 16px;
      line-height: 1.6;
      font-size: 1rem;
    }

    .chat-message.user .chat-bubble {
      background: var(--accent);
      color: white;
      border-bottom-right-radius: 4px;
    }

    .chat-message.assistant .chat-bubble {
      background: var(--bg-secondary);
      color: var(--text-primary);
      border-bottom-left-radius: 4px;
    }

    .chat-bubble p {
      margin: 0 0 0.5rem 0;
    }

    .chat-bubble p:last-child {
      margin-bottom: 0;
    }

    .chat-bubble code {
      background: rgba(139, 92, 246, 0.08);
      color: var(--accent);
      padding: 0.2rem 0.5rem;
      border-radius: 4px;
      font-family: 'Monaco', 'Courier New', monospace;
      font-size: 0.9rem;
      font-weight: 500;
    }

    .chat-bubble pre {
      background: #282c34;
      padding: 1rem;
      border-radius: 10px;
      overflow-x: auto;
      margin: 0.75rem 0;
      border: 1px solid rgba(139, 92, 246, 0.2);
    }

    .chat-bubble pre code {
      background: transparent;
      padding: 0;
      font-size: 0.9rem;
      color: #abb2bf;
      font-weight: normal;
    }

    body.dark-mode .chat-bubble pre {
      background: #1e1e1e;
      border-color: rgba(167, 139, 250, 0.25);
    }

    .chat-bubble h1,
    .chat-bubble h2,
    .chat-bubble h3,
    .chat-bubble h4 {
      margin: 1rem 0 0.5rem 0;
      font-weight: 450;
    }

    .chat-bubble ul,
    .chat-bubble ol {
      margin-left: 1.5rem;
      margin-bottom: 0.5rem;
    }

    .chat-timestamp {
      font-size: 1rem;
      color: var(--text-secondary);
      padding: 0 0.5rem;
    }

    .chat-slack-btn {
      padding: 0.75rem 1.25rem;
      background: var(--bg-primary);
      color: var(--text-primary);
      border: 1px solid var(--border);
      border-radius: 50px;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 500;
      transition: all 0.2s;
      font-family: inherit;
      white-space: nowrap;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .chat-slack-btn:hover {
      background: var(--bg-tertiary);
      border-color: var(--accent);
    }

    .chat-input-container {
      padding: 1.5rem 2rem;
      border-top: 1px solid var(--border);
      background: var(--bg-secondary);
    }

    .chat-input-box {
      display: flex;
      gap: 0.75rem;
      align-items: flex-end;
    }

    .chat-input {
      flex: 1;
      padding: 0.75rem 1rem;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: var(--bg-primary);
      color: var(--text-primary);
      font-family: inherit;
      font-size: 1rem;
      resize: none;
      outline: none;
      max-height: 120px;
      min-height: 44px;
    }

    .chat-input:focus {
      border-color: var(--accent);
    }

    .chat-send {
      padding: 0.75rem 1.5rem;
      background: var(--text-primary);
      color: white;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      font-weight: 500;
      font-size: 1rem;
      transition: background 0.2s;
      font-family: inherit;
      white-space: nowrap;
    }

    .chat-send:hover {
      background: var(--text-secondary);
    }

    .chat-send:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .chat-empty {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: var(--text-secondary);
      padding: 3rem 2rem;
      text-align: center;
    }

    .chat-empty-icon {
      font-size: 3rem;
      margin-bottom: 1rem;
      opacity: 0.5;
    }

    .streaming-dots {
      display: inline-flex;
      gap: 4px;
      align-items: center;
      padding: 0.5rem;
    }

    .streaming-dot {
      width: 8px;
      height: 8px;
      background: var(--text-secondary);
      border-radius: 50%;
      animation: bounce 1.4s infinite;
    }

    .streaming-dot:nth-child(2) {
      animation-delay: 0.2s;
    }

    .streaming-dot:nth-child(3) {
      animation-delay: 0.4s;
    }

    @keyframes bounce {
      0%, 60%, 100% {
        transform: translateY(0);
      }
      30% {
        transform: translateY(-10px);
      }
    }

    /* History/Bookmarks Modal */
    #history-modal .modal-content,
    #bookmarks-modal .modal-content {
      width: 600px;
      max-height: 70vh;
    }

    /* Spec Viewer Modal */
    .modal-large {
      width: 90%;
      max-width: 1400px;
      max-height: 85vh;
    }

    #spec-viewer-content {
      background: var(--bg-secondary);
      border-radius: 8px;
      padding: 0;
      overflow: hidden;
    }

    #spec-viewer-content pre {
      margin: 0;
      border-radius: 0;
    }

    #spec-viewer-content .json-viewer-container {
      margin: 0;
      border: none;
      border-radius: 0;
    }

    /* Specs Browser */
    .spec-folder {
      margin-bottom: 1rem;
    }

    .spec-folder-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.75rem 1rem;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.2s;
      user-select: none;
    }

    .spec-folder-header:hover {
      background: var(--bg-tertiary);
      border-color: var(--accent);
    }

    .spec-folder-icon {
      font-size: 0.9rem;
      transition: transform 0.2s;
    }

    .spec-folder.expanded .spec-folder-icon {
      transform: rotate(90deg);
    }

    .spec-folder-name {
      flex: 1;
      color: var(--text-primary);
    }

    .spec-folder-count {
      font-size: 0.85rem;
      color: var(--text-secondary);
      background: var(--bg-tertiary);
      padding: 0.25rem 0.5rem;
      border-radius: 12px;
    }

    .spec-folder-content {
      display: none;
      margin-left: 1.5rem;
      margin-top: 0.5rem;
      padding-left: 1rem;
      border-left: 2px solid var(--border-light);
    }

    .spec-folder.expanded .spec-folder-content {
      display: block;
    }

    .spec-file {
      padding: 0.6rem 1rem;
      margin: 0.25rem 0;
      background: var(--bg-secondary);
      border: 1px solid var(--border-light);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 0.9rem;
      color: var(--text-secondary);
      display: flex;
      align-items: flex-start;
      gap: 0.5rem;
      word-break: break-word;
    }

    .spec-file > span:not(.spec-file-icon) {
      flex: 1;
      line-height: 1.4;
    }

    .spec-file:hover {
      background: var(--accent-light);
      border-color: var(--accent);
      color: var(--accent);
      transform: translateX(4px);
    }

    .spec-file-icon {
      font-size: 0.85rem;
      flex-shrink: 0;
      line-height: 1.4;
    }

    .list-item {
      padding: 1rem 1.5rem;
      margin: 0.5rem 0;
      background: var(--bg-secondary);
      border: 1px solid var(--border-light);
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 1rem;
    }

    .list-item:hover {
      transform: translateX(4px);
      border-color: var(--accent);
    }

    .list-empty {
      text-align: center;
      padding: 3rem 2rem;
      color: var(--text-secondary);
      font-size: 1rem;
    }

    /* Notification */
    .notification {
      position: fixed;
      bottom: 2rem;
      right: 2rem;
      background: var(--text-primary);
      color: white;
      padding: 1rem 1.5rem;
      border-radius: 50px;
      box-shadow: 0 4px 12px var(--shadow-heavy);
      opacity: 0;
      transform: translateY(20px);
      transition: all 0.3s;
      z-index: 1000;
      font-size: 1rem;
    }

    .notification.show {
      opacity: 1;
      transform: translateY(0);
    }

    .error-message {
      background: #dc2626;
      color: white;
      padding: 1rem;
      border-radius: 8px;
      margin-bottom: 1rem;
      display: none;
      font-size: 1rem;
    }

    .error-message.show {
      display: block;
    }

    /* Responsive */
    @media (max-width: 960px) {
      .app-layout {
        flex-direction: column;
      }

      .sidebar {
        width: 100%;
        position: static;
      }

      #chat-modal .modal-content,
      #history-modal .modal-content,
      #bookmarks-modal .modal-content {
        width: 95%;
        max-width: 600px;
      }

      /* Mobile actions toolbar */
      .actions {
        padding: 0.5rem;
        gap: 0.25rem;
      }

      .actions-divider {
        margin: 0 0.25rem;
      }

      #prev-question-btn,
      #next-question-btn {
        padding: 0 0.75rem;
        font-size: 0.85rem;
      }

      .actions button svg {
        width: 16px;
        height: 16px;
      }
    }

    /* Source links styling */
    .sources-section {
      margin-top: 24px;
      padding: 16px;
      background: var(--bg-secondary);
      border-radius: 8px;
      display: none;
    }

    .sources-section h4 {
      margin: 0 0 12px 0;
      font-size: 1rem;
      font-weight: 600;
      color: var(--text-primary);
    }

    #source-links {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .source-link {
      display: inline-flex;
      align-items: center;
      padding: 8px 12px;
      background: var(--bg-primary);
      border: 1px solid var(--border);
      border-radius: 6px;
      color: var(--accent);
      text-decoration: none;
      font-size: 1rem;
      transition: all 0.2s ease;
    }

    .source-link:hover {
      background: var(--accent-light);
      border-color: var(--accent);
      transform: translateX(4px);
    }

    .source-link::before {
      content: '‚Üí';
      margin-right: 8px;
      font-weight: bold;
    }

    /* JSON Editor Styling */
    .json-viewer-container {
      margin: 1rem 0;
      border: 1px solid var(--border);
      border-radius: 8px;
      overflow: hidden;
      min-height: 200px;
      max-height: none;
    }

    .json-viewer-container .jsoneditor {
      border: none;
      height: auto !important;
      min-height: 200px;
    }

    .json-viewer-container .jsoneditor-outer {
      min-height: 200px;
      height: auto !important;
    }

    .json-viewer-container .jsoneditor-tree {
      min-height: 200px;
      height: auto !important;
    }

    .json-viewer-container .jsoneditor-menu {
      background-color: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
    }

    body.dark-mode .jsoneditor {
      background-color: var(--bg-secondary);
      color: var(--text-primary);
    }

    body.dark-mode .jsoneditor-menu {
      background-color: var(--bg-tertiary);
      border-bottom-color: var(--border-light);
    }

    body.dark-mode .jsoneditor-tree {
      background-color: var(--bg-secondary);
    }

    body.dark-mode .jsoneditor-field,
    body.dark-mode .jsoneditor-value,
    body.dark-mode .jsoneditor-readonly {
      color: var(--text-primary) !important;
    }

    body.dark-mode .jsoneditor-string {
      color: #98c379 !important;
    }

    body.dark-mode .jsoneditor-number {
      color: #d19a66 !important;
    }

    body.dark-mode .jsoneditor-boolean {
      color: #56b6c2 !important;
    }

    body.dark-mode .jsoneditor-null {
      color: #c678dd !important;
    }

    body.dark-mode .jsoneditor-property {
      color: #e06c75 !important;
    }

    body.dark-mode .jsoneditor td,
    body.dark-mode .jsoneditor th,
    body.dark-mode .jsoneditor textarea {
      background-color: var(--bg-secondary);
      color: var(--text-primary);
      border-color: var(--border-light);
    }

    body.dark-mode .jsoneditor-tree button {
      background-color: transparent;
    }

    body.dark-mode .jsoneditor-contextmenu {
      background-color: var(--bg-secondary);
      border-color: var(--border-light);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    body.dark-mode .jsoneditor-contextmenu li button {
      color: var(--text-primary);
    }

    body.dark-mode .jsoneditor-contextmenu li button:hover {
      background-color: var(--bg-tertiary);
    }

    /* Specs Full Page View */
    #specs-page {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100vh;
      background: var(--bg-primary);
      z-index: 10000;
      flex-direction: column;
    }

    #specs-page.active {
      display: flex;
    }

    #specs-page-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 1rem 2rem;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
    }

    #specs-page-title {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    #specs-page-title h2 {
      margin: 0;
      font-size: 1.5rem;
      color: var(--text-primary);
    }

    #specs-page-actions {
      display: flex;
      gap: 0.75rem;
      align-items: center;
    }

    #specs-page-actions button,
    #specs-page-actions a {
      padding: 0.5rem 1rem;
      border-radius: 6px;
      font-size: 0.9rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      text-decoration: none;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    #specs-close-btn {
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-primary);
    }

    #specs-close-btn:hover {
      background: var(--bg-tertiary);
    }

    #specs-github-btn {
      background: var(--accent);
      border: none;
      color: white;
    }

    #specs-github-btn:hover {
      opacity: 0.9;
    }

    #specs-page-content {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    #specs-sidebar {
      width: 350px;
      background: var(--bg-secondary);
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    #specs-sidebar-search {
      padding: 1rem;
      border-bottom: 1px solid var(--border);
    }

    #specs-sidebar-search input {
      width: 100%;
      padding: 0.75rem;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: var(--bg-primary);
      color: var(--text-primary);
      font-size: 0.9rem;
    }

    #specs-sidebar-tree {
      flex: 1;
      overflow-y: auto;
      padding: 1rem;
    }

    #specs-viewer-pane {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      background: var(--bg-primary);
    }

    #specs-viewer-header {
      padding: 0;
      border-bottom: 1px solid var(--border);
      background: var(--bg-secondary);
      display: flex;
      flex-direction: column;
    }

    #specs-viewer-title-row {
      padding: 1rem 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    #specs-viewer-header h3 {
      margin: 0;
      font-size: 1.2rem;
      color: var(--text-primary);
    }

    #specs-view-tabs {
      display: flex;
      gap: 0;
      padding: 0 2rem;
      background: var(--bg-primary);
      border-top: 1px solid var(--border);
    }

    .spec-view-tab {
      padding: 0.75rem 1.5rem;
      background: transparent;
      border: none;
      color: var(--text-secondary);
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.2s;
      border-bottom: 2px solid transparent;
      font-weight: 500;
    }

    .spec-view-tab:hover {
      color: var(--text-primary);
      background: var(--bg-secondary);
    }

    .spec-view-tab.active {
      color: var(--accent);
      border-bottom-color: var(--accent);
      background: var(--bg-primary);
    }

    #raw-json-view {
      display: none;
      height: 100%;
      overflow: auto;
      padding: 0;
    }

    #raw-json-view pre {
      margin: 0;
      padding: 2rem;
      background: #282c34;
      color: #abb2bf;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', monospace;
      font-size: 0.9rem;
      line-height: 1.6;
      overflow-x: auto;
    }

    #raw-json-view pre code {
      background: transparent;
      padding: 0;
    }

    #specs-viewer-body {
      flex: 1;
      overflow: hidden;
      position: relative;
    }

    #specs-viewer-content-pane {
      height: 100%;
      padding: 1rem;
      overflow-y: auto;
    }

    .spec-file.active {
      background: var(--accent-light);
      border-color: var(--accent);
      color: var(--accent);
      font-weight: 500;
    }

    /* Graph Page View */
    #graph-page {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--bg-primary);
      z-index: 10000;
      flex-direction: column;
    }

    #graph-page.active {
      display: flex;
    }

    #graph-page-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 1rem 2rem;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
    }

    #graph-page-title {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    #graph-page-title h2 {
      margin: 0;
      font-size: 1.5rem;
      color: var(--text-primary);
    }

    #graph-page-actions {
      display: flex;
      gap: 0.75rem;
      align-items: center;
    }

    #graph-page-actions button {
      padding: 0.5rem 1rem;
      border-radius: 6px;
      font-size: 0.9rem;
      font-weight: 500;
      cursor: pointer;
      border: 1px solid var(--border);
      background: var(--bg-primary);
      color: var(--text-primary);
      transition: all 0.2s;
    }

    #graph-page-actions button:hover {
      background: var(--bg-tertiary);
      border-color: var(--accent);
      color: var(--accent);
    }

    #graph-page-content {
      flex: 1;
      overflow: auto;
      padding: 2rem;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #graph-container {
      width: 100%;
      max-width: 100%;
      height: 100%;
      overflow: auto;
    }

    #graph-svg {
      width: 100%;
      min-height: 100%;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 2rem;
    }

    #graph-svg svg {
      max-width: 100%;
      height: auto;
    }

    /* Mermaid flowchart node styling */
    .node rect,
    .node circle,
    .node ellipse,
    .node polygon {
      stroke-width: 2px;
      transition: all 0.2s;
    }

    .node:hover rect,
    .node:hover circle,
    .node:hover ellipse,
    .node:hover polygon {
      filter: brightness(0.95);
    }
  </style>
</head>
<body>
  <header class="app-header">
    <div class="logo" id="app-title">
      <img src="main_logo.svg" alt="UCP Logo">
      <h1>UCP Explorer</h1>
    </div>
    <div class="header-actions">
      <button id="graph-btn" title="Knowledge Graph">üó∫Ô∏è</button>
      <button id="specs-btn" title="Browse Specs">üìã</button>
      <button id="history-btn" title="History">üìú</button>
      <button id="bookmarks-btn" title="Saved Topics">‚≠ê</button>
      <button id="theme-toggle" title="Toggle dark mode">üåô</button>
      <img id="user-avatar" src="" alt="User" style="display: none;">
    </div>
  </header>

  <div class="search-container">
    <div class="search-box">
      <input type="text" id="search-input" placeholder="Ask anything about UCP..." autocomplete="off">
      <button id="search-btn">Search</button>
    </div>
    <div id="suggestions"></div>
  </div>

  <div class="app-layout">
    <aside class="sidebar">
      <nav class="category-nav">
        <h3>Learning Topics</h3>
        <ul id="categories"></ul>
      </nav>
    </aside>

    <main class="main-content">
      <div class="breadcrumb" id="breadcrumb"></div>

      <div class="welcome-card" id="welcome">
        <h2>Welcome to UCP Explorer</h2>
        <div class="popular-questions">
          <h3>Popular Questions</h3>
          <div id="popular-list"></div>
        </div>
      </div>

      <div class="error-message" id="error-message"></div>

      <div class="content-card" id="content-card">
        <div class="content-section">
          <div class="question-card" id="question-display"></div>
        </div>

        <div class="content-divider"></div>

        <div class="content-section">
          <div class="answer-card" id="answer-display">
            <div id="answer-text"></div>
          </div>
        </div>

        <div class="content-divider" id="sources-divider"></div>

        <div class="content-section" id="sources-section-wrapper">
          <div class="sources-section" id="sources">
            <h4>üìö Learn More</h4>
            <div id="source-links"></div>
          </div>
        </div>

        <div class="content-divider"></div>

        <div class="content-section">
          <div class="actions">
            <div class="action-group">
              <button id="bookmark-action-btn" title="Save Topic">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"/>
                </svg>
              </button>
              <button id="share-btn" title="Share Link">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <circle cx="18" cy="5" r="3"/>
                  <circle cx="6" cy="12" r="3"/>
                  <circle cx="18" cy="19" r="3"/>
                  <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"/>
                  <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"/>
                </svg>
              </button>
              <button id="slack-answer-btn" title="Send to Slack">
                <svg viewBox="0 0 24 24" fill="currentColor">
                  <path d="M6 15c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0-8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm5 10h8c1.1 0 2-.9 2-2s-.9-2-2-2h-8c-1.1 0-2 .9-2 2s.9 2 2 2zm-3-3v-2H5c-1.1 0-2 .9-2 2s.9 2 2 2h3v-2zm11-4h-8c-1.1 0-2 .9-2 2s.9 2 2 2h8c1.1 0 2-.9 2-2s-.9-2-2-2zm0-6h-8c-1.1 0-2 .9-2 2s.9 2 2 2h8c1.1 0 2-.9 2-2s-.9-2-2-2z"/>
                </svg>
              </button>
            </div>
            <div class="actions-divider"></div>
            <div class="action-group">
              <button id="prev-question-btn">
                <svg viewBox="0 0 24 24" fill="currentColor">
                  <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/>
                </svg>
                Previous
              </button>
              <button id="next-question-btn">
                Next
                <svg viewBox="0 0 24 24" fill="currentColor">
                  <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/>
                </svg>
              </button>
            </div>
          </div>
        </div>
      </div>
    </main>
  </div>

  <!-- Chat Modal -->
  <div class="modal" id="chat-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3>üí¨ AI Chat</h3>
        <button class="modal-close" id="chat-close">√ó</button>
      </div>
      <div class="modal-body">
        <div class="chat-messages-wrapper">
          <div class="chat-messages" id="chat-messages">
            <div class="chat-empty">
              <div class="chat-empty-icon">üí≠</div>
              <p>Ask AI a question to start a conversation</p>
            </div>
          </div>
          <button class="scroll-to-bottom" id="scroll-to-bottom" title="Scroll to bottom">
            <svg fill="currentColor" viewBox="0 0 16 16">
              <path d="M8 12.5l-4-4h8l-4 4z"/>
              <path d="M8 8.5l-4-4h8l-4 4z"/>
            </svg>
          </button>
        </div>
      </div>
      <div class="chat-input-container">
        <div class="chat-input-box">
          <textarea
            class="chat-input"
            id="chat-input"
            placeholder="Ask a follow-up question..."
            rows="1"
          ></textarea>
          <button class="chat-slack-btn" id="chat-slack-btn">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
              <path d="M6 15c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0-8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm5 10h8c1.1 0 2-.9 2-2s-.9-2-2-2h-8c-1.1 0-2 .9-2 2s.9 2 2 2zm-3-3v-2H5c-1.1 0-2 .9-2 2s.9 2 2 2h3v-2zm11-4h-8c-1.1 0-2 .9-2 2s.9 2 2 2h8c1.1 0 2-.9 2-2s-.9-2-2-2zm0-6h-8c-1.1 0-2 .9-2 2s.9 2 2 2h8c1.1 0 2-.9 2-2s-.9-2-2-2z"/>
            </svg>
            Slack
          </button>
          <button class="chat-send" id="chat-send">Send</button>
        </div>
      </div>
    </div>
  </div>

  <!-- History Modal -->
  <div class="modal" id="history-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3>üìú History</h3>
        <div style="display: flex; gap: 0.5rem; align-items: center;">
          <button id="clear-history-btn">Clear All</button>
          <button class="modal-close" onclick="closeModal('history-modal')">√ó</button>
        </div>
      </div>
      <div class="modal-body">
        <div id="history-list"></div>
      </div>
    </div>
  </div>

  <!-- Bookmarks Modal -->
  <div class="modal" id="bookmarks-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3>‚≠ê Saved Topics</h3>
        <button class="modal-close" onclick="closeModal('bookmarks-modal')">√ó</button>
      </div>
      <div class="modal-body">
        <div id="bookmarks-list"></div>
      </div>
    </div>
  </div>

  <!-- Spec Viewer Modal -->
  <div class="modal" id="spec-modal">
    <div class="modal-content modal-large">
      <div class="modal-header">
        <h3 id="spec-modal-title">üìã Schema Specification</h3>
        <button class="modal-close" onclick="closeModal('spec-modal')">√ó</button>
      </div>
      <div class="modal-body">
        <div id="spec-viewer-content"></div>
      </div>
    </div>
  </div>

  <div class="notification" id="notification"></div>

  <!-- Specs Full Page View -->
  <div id="specs-page">
    <div id="specs-page-header">
      <div id="specs-page-title">
        <h2>üìã Specification Browser</h2>
      </div>
      <div id="specs-page-actions">
        <a id="specs-github-btn" href="https://github.com/Universal-Commerce-Protocol/ucp/tree/main/spec" target="_blank" rel="noopener noreferrer">
          üìÅ GitHub
        </a>
        <button id="specs-close-btn">‚úï Close</button>
      </div>
    </div>
    <div id="specs-page-content">
      <div id="specs-sidebar">
        <div id="specs-sidebar-search">
          <input type="text" id="specs-search-input" placeholder="Filter specs...">
        </div>
        <div id="specs-sidebar-tree"></div>
      </div>
      <div id="specs-viewer-pane">
        <div id="specs-viewer-header">
          <div id="specs-viewer-title-row">
            <h3 id="specs-current-title">Select a specification</h3>
          </div>
          <div id="specs-view-tabs" style="display: none;">
            <button class="spec-view-tab active" data-view="tree">üå≥ Tree View</button>
            <button class="spec-view-tab" data-view="raw">üìÑ Raw JSON</button>
          </div>
        </div>
        <div id="specs-viewer-body">
          <div id="specs-viewer-content-pane"></div>
          <div id="raw-json-view"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Graph Page View -->
  <div id="graph-page">
    <div id="graph-page-header">
      <div id="graph-page-title">
        <h2>üó∫Ô∏è Knowledge Graph</h2>
      </div>
      <div id="graph-page-actions">
        <button id="graph-back-btn" style="display: none;">‚Üê Back</button>
        <button id="graph-close-btn">‚úï Close</button>
      </div>
    </div>
    <div id="graph-page-content">
      <div id="graph-container">
        <div id="graph-svg"></div>
      </div>
    </div>
  </div>

  <!-- Highlight.js for syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/json.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/typescript.min.js"></script>

  <!-- Marked.js for markdown rendering - load BEFORE our script -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <script src="/client/quick.js"></script>
  <script type="module">
    import OpenAI from 'https://cdn.jsdelivr.net/npm/openai/+esm';

    // State
    let knowledgeBase = null;
    let currentQuestion = null;
    let currentCategory = null; // Store current category for breadcrumb
    let openaiClient = null;
    let abortController = null;
    let chatHistory = [];
    let currentChatContext = null;
    let currentUser = null;
    let allQuestions = []; // Flat list of all questions for navigation
    let currentQuestionIndex = -1; // Current position in allQuestions array

    // Auto-scroll state for chat
    let autoScrollEnabled = true;
    let isGenerating = false;
    let lastScrollTop = 0;

    // Database collections
    let bookmarksCollection = null;
    let historyCollection = null;
    let chatHistoryCollection = null;

    // Initialize OpenAI client
    openaiClient = new OpenAI({
      baseURL: `${window.location.origin}/api/ai`,
      apiKey: 'not-needed',
      dangerouslyAllowBrowser: true
    });

    // Configure marked.js to open all links in new window
    window.marked.use({
      renderer: {
        link(token) {
          // Handle both old API (href, title, text) and new API (token object)
          const href = token.href || token;
          const title = token.title || arguments[1];
          const text = token.text || arguments[2];

          // Debug logging for link rendering
          console.log('Marked link renderer:', { href, title, text, token, allArgs: arguments });

          // Handle undefined text
          const linkText = text || href || 'Link';
          const titleAttr = title ? ` title="${title}"` : '';
          return `<a href="${href}"${titleAttr} target="_blank" rel="noopener noreferrer">${linkText}</a>`;
        }
      }
    });

    // Initialize user authentication and database
    async function initializeUser() {
      try {
        currentUser = await quick.id.waitForUser();
        console.log('User authenticated:', currentUser.email);

        // Set user avatar if available
        const avatarImg = document.getElementById('user-avatar');
        if (currentUser.slackImageUrl) {
          avatarImg.src = currentUser.slackImageUrl;
          avatarImg.style.display = 'block';
          avatarImg.title = `${currentUser.fullName || currentUser.name || currentUser.email}`;
        }

        // Initialize database collections
        bookmarksCollection = quick.db.collection('user_bookmarks');
        historyCollection = quick.db.collection('user_search_history');
        chatHistoryCollection = quick.db.collection('user_chat_history');

        // Migrate localStorage data to database (one-time migration)
        await migrateLocalStorageToDatabase();
      } catch (error) {
        console.error('Error initializing user:', error);
        showError('Failed to initialize user authentication');
      }
    }

    // Migrate localStorage data to database (one-time migration)
    async function migrateLocalStorageToDatabase() {
      try {
        // Migrate bookmarks
        const localBookmarks = JSON.parse(localStorage.getItem('ucp-ama-bookmarks') || '[]');
        if (localBookmarks.length > 0) {
          const existingBookmarks = await bookmarksCollection
            .where({ userId: currentUser.id })
            .find();

          if (existingBookmarks.length === 0) {
            for (const questionId of localBookmarks) {
              await bookmarksCollection.create({
                userId: currentUser.id,
                questionId: questionId,
                timestamp: new Date().toISOString()
              });
            }
            console.log('Migrated bookmarks to database');
          }
        }

        // Migrate search history
        const localHistory = JSON.parse(localStorage.getItem('ucp-ama-history') || '[]');
        if (localHistory.length > 0) {
          const existingHistory = await historyCollection
            .where({ userId: currentUser.id })
            .find();

          if (existingHistory.length === 0) {
            for (const item of localHistory) {
              await historyCollection.create({
                userId: currentUser.id,
                questionId: item.id,
                questionText: item.question,
                timestamp: item.timestamp || new Date().toISOString()
              });
            }
            console.log('Migrated search history to database');
          }
        }

        // Keep theme preference in localStorage (user preference, not critical data)
      } catch (error) {
        console.error('Error migrating localStorage:', error);
      }
    }

    // Load knowledge base
    async function loadKnowledgeBase() {
      try {
        console.log('Loading knowledge base...');
        const response = await fetch('ucp-learning.json');
        console.log('Response status:', response.status);
        knowledgeBase = await response.json();
        console.log('Knowledge base loaded:', knowledgeBase);
        console.log('marked available:', typeof marked !== 'undefined');

        // Build flat list of all questions for navigation
        buildAllQuestionsList();

        // Initialize user authentication
        await initializeUser();

        initializeUI();
      } catch (error) {
        showError('Failed to load knowledge base');
        console.error('Error loading knowledge base:', error);
      }
    }

    // Build flat list of all questions from all categories
    function buildAllQuestionsList() {
      allQuestions = [];
      if (knowledgeBase && knowledgeBase.categories) {
        knowledgeBase.categories.forEach(category => {
          if (category.questions) {
            category.questions.forEach(question => {
              allQuestions.push(question);
            });
          }
        });
      }
      console.log(`Total questions for navigation: ${allQuestions.length}`);
    }

    // Initialize UI
    function initializeUI() {
      renderCategories();
      renderPopularQuestions();
      loadBookmarks();
      loadHistory();
      loadTheme();
      loadFromURL();
    }

    // Render categories in sidebar
    function renderCategories() {
      const categoriesEl = document.getElementById('categories');
      knowledgeBase.categories.forEach(cat => {
        const li = document.createElement('li');
        li.className = 'category-item';
        li.dataset.categoryId = cat.id; // Add data attribute for easy selection
        li.innerHTML = `
          <span>${cat.title}</span>
          <span class="question-count">${cat.question_count}</span>
        `;
        li.onclick = () => showCategoryQuestions(cat);
        categoriesEl.appendChild(li);
      });
    }

    // Highlight active category in sidebar
    function highlightActiveCategory(categoryId) {
      // Remove active class from all categories
      document.querySelectorAll('.category-item').forEach(item => {
        item.classList.remove('active');
      });

      // Add active class to current category
      const activeCategory = document.querySelector(`.category-item[data-category-id="${categoryId}"]`);
      if (activeCategory) {
        activeCategory.classList.add('active');
      }
    }

    // Show category questions
    function showCategoryQuestions(category) {
      if (abortController) {
        abortController.abort();
        abortController = null;
      }

      // Store current category
      currentCategory = category;

      // Update breadcrumb
      updateBreadcrumb(category);

      // Highlight active category
      highlightActiveCategory(category.id);

      document.getElementById('welcome').style.display = 'none';
      document.getElementById('content-card').classList.add('active');

      // Hide sources section for category view
      document.getElementById('sources-divider').style.display = 'none';
      document.getElementById('sources-section-wrapper').style.display = 'none';

      // Hide action buttons
      document.getElementById('bookmark-action-btn').style.display = 'none';
      document.getElementById('share-btn').style.display = 'none';
      document.getElementById('slack-answer-btn').style.display = 'none';
      document.getElementById('prev-question-btn').style.display = 'none';
      document.getElementById('next-question-btn').style.display = 'none';

      const questionCard = document.getElementById('question-display');
      questionCard.innerHTML = `
        <div class="question-category">${category.title}</div>
        <div class="question-text">${category.question_count} ${category.question_count === 1 ? 'Topic' : 'Topics'} to Explore</div>
      `;

      const answerText = document.getElementById('answer-text');

      answerText.innerHTML = '<div class="category-questions-list">';
      category.questions.forEach((q, index) => {
        answerText.innerHTML += `
          <div class="category-question-item" data-index="${index}">
            <div class="category-question-number">${index + 1}</div>
            <div class="category-question-text">${q.question}</div>
          </div>
        `;
      });
      answerText.innerHTML += '</div>';

      const questionDivs = answerText.querySelectorAll('.category-question-item');
      questionDivs.forEach((div, index) => {
        div.onclick = () => selectQuestion(category.questions[index]);
      });

      window.location.hash = '';
    }

    // Update breadcrumb navigation
    function updateBreadcrumb(category, question = null) {
      const breadcrumb = document.getElementById('breadcrumb');

      if (!category) {
        breadcrumb.classList.remove('active');
        return;
      }

      breadcrumb.classList.add('active');

      if (question) {
        // Show: Category > Question
        breadcrumb.innerHTML = `
          <div class="breadcrumb-item" id="breadcrumb-back-to-category">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M15 18l-6-6 6-6"/>
            </svg>
            ${category.title}
          </div>
          <span class="breadcrumb-separator">/</span>
          <span class="breadcrumb-current">${question.question.substring(0, 60)}${question.question.length > 60 ? '...' : ''}</span>
        `;
        // Add event listener after setting innerHTML
        setTimeout(() => {
          const backBtn = document.getElementById('breadcrumb-back-to-category');
          if (backBtn) {
            backBtn.onclick = () => showCategoryQuestions(currentCategory);
          }
        }, 0);
      } else {
        // Show: Category only
        breadcrumb.innerHTML = `
          <div class="breadcrumb-item" id="breadcrumb-home">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/>
            </svg>
            Home
          </div>
          <span class="breadcrumb-separator">/</span>
          <span class="breadcrumb-current">${category.title}</span>
        `;
        // Add event listener after setting innerHTML
        setTimeout(() => {
          const homeBtn = document.getElementById('breadcrumb-home');
          if (homeBtn) {
            homeBtn.onclick = () => {
              document.getElementById('welcome').style.display = 'block';
              document.getElementById('content-card').classList.remove('active');
              document.getElementById('breadcrumb').classList.remove('active');
              currentCategory = null;
            };
          }
        }, 0);
      }
    }

    // Render popular questions
    // Fisher-Yates shuffle algorithm
    function shuffleArray(array) {
      const shuffled = [...array];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    }

    function renderPopularQuestions() {
      const popularEl = document.getElementById('popular-list');
      const questions = [];
      knowledgeBase.categories.forEach(cat => {
        questions.push(...cat.questions);
      });

      // Shuffle and pick random 6 questions
      const shuffled = shuffleArray(questions);
      shuffled.slice(0, 6).forEach(q => {
        const div = document.createElement('div');
        div.className = 'popular-question';
        div.textContent = q.question;
        div.onclick = () => selectQuestion(q);
        popularEl.appendChild(div);
      });
    }

    // Search functionality
    const searchInput = document.getElementById('search-input');
    const searchBtn = document.getElementById('search-btn');
    const suggestionsEl = document.getElementById('suggestions');

    let currentSuggestionIndex = -1;
    let currentSuggestions = [];

    searchInput.addEventListener('input', (e) => {
      const query = e.target.value.toLowerCase();
      if (query.length < 2) {
        suggestionsEl.classList.remove('active');
        currentSuggestionIndex = -1;
        return;
      }

      const matches = findRelevantQuestions(query);
      currentSuggestions = matches.slice(0, 10);
      renderSuggestions(currentSuggestions);
      currentSuggestionIndex = -1;
    });

    searchInput.addEventListener('keydown', (e) => {
      const suggestionItems = suggestionsEl.querySelectorAll('.suggestion-item');

      if (e.key === 'ArrowDown') {
        e.preventDefault();
        if (suggestionItems.length > 0) {
          currentSuggestionIndex = Math.min(currentSuggestionIndex + 1, suggestionItems.length - 1);
          highlightSuggestion(suggestionItems, currentSuggestionIndex);
        }
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        if (currentSuggestionIndex > 0) {
          currentSuggestionIndex--;
          highlightSuggestion(suggestionItems, currentSuggestionIndex);
        }
      } else if (e.key === 'Enter') {
        e.preventDefault();
        if (currentSuggestionIndex >= 0 && currentSuggestions[currentSuggestionIndex]) {
          selectQuestion(currentSuggestions[currentSuggestionIndex]);
        } else {
          handleSearch();
        }
      } else if (e.key === 'Escape') {
        suggestionsEl.classList.remove('active');
        currentSuggestionIndex = -1;
      }
    });

    function highlightSuggestion(items, index) {
      items.forEach((item, i) => {
        if (i === index) {
          item.classList.add('highlighted');
          item.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
        } else {
          item.classList.remove('highlighted');
        }
      });
    }

    searchBtn.addEventListener('click', handleSearch);

    function findRelevantQuestions(query) {
      const results = [];
      knowledgeBase.categories.forEach(cat => {
        cat.questions.forEach(q => {
          let score = 0;
          const qLower = q.question.toLowerCase();
          if (qLower.includes(query)) score += 10;
          q.keywords.forEach(kw => {
            if (kw.includes(query) || query.includes(kw)) score += 5;
          });
          if (score > 0) {
            results.push({ ...q, category: cat.title, score });
          }
        });
      });
      return results.sort((a, b) => b.score - a.score);
    }

    function renderSuggestions(matches) {
      suggestionsEl.innerHTML = '';
      if (matches.length === 0) {
        suggestionsEl.innerHTML = '<div class="suggestion-item">No matches found</div>';
      } else {
        matches.forEach(q => {
          const div = document.createElement('div');
          div.className = 'suggestion-item';
          div.innerHTML = `
            <div class="suggestion-question">${q.question}</div>
            <div class="suggestion-category">${q.category}</div>
          `;
          div.onclick = () => selectQuestion(q);
          suggestionsEl.appendChild(div);
        });
      }
      suggestionsEl.classList.add('active');
    }

    async function handleSearch() {
      const query = searchInput.value.trim();
      if (!query) return;

      suggestionsEl.classList.remove('active');
      document.getElementById('welcome').style.display = 'none';

      // Show content card
      document.getElementById('content-card').classList.add('active');

      // Hide sources section for custom questions
      document.getElementById('sources-divider').style.display = 'none';
      document.getElementById('sources-section-wrapper').style.display = 'none';

      const relevantQA = findRelevantQuestions(query).slice(0, 5);
      displayCustomQuestion(query);
      await askAIDirect(query, relevantQA);
    }

    function selectQuestion(question, clearSearch = false) {
      if (abortController) {
        abortController.abort();
        abortController = null;
      }

      // Clear search only when explicitly requested (navigating away)
      if (clearSearch && currentQuestion && currentQuestion.id !== question.id) {
        searchInput.value = '';
      }

      currentQuestion = question;
      suggestionsEl.classList.remove('active');
      document.getElementById('welcome').style.display = 'none';

      // Show content card
      document.getElementById('content-card').classList.add('active');

      displayQuestion(question);
      displayFAQAnswer(question);

      window.location.hash = `q=${question.id}`;
    }

    function displayQuestion(question) {
      const questionCard = document.getElementById('question-display');

      // Find the category this question belongs to
      let category = null;
      for (const cat of knowledgeBase.categories) {
        if (cat.questions.some(q => q.id === question.id)) {
          category = cat;
          currentCategory = cat; // Store for breadcrumb navigation
          // Highlight active category in sidebar
          highlightActiveCategory(cat.id);
          break;
        }
      }

      // Update breadcrumb
      if (category) {
        updateBreadcrumb(category, question);
      }

      questionCard.innerHTML = `
        ${category ? `<div class="question-category">${category.title}</div>` : ''}
        <div class="question-text">${question.question}</div>
      `;

      // Find current question index in allQuestions
      currentQuestionIndex = allQuestions.findIndex(q => q.id === question.id);

      // Show action buttons
      document.getElementById('bookmark-action-btn').style.display = 'flex';
      document.getElementById('share-btn').style.display = 'flex';
      document.getElementById('slack-answer-btn').style.display = 'flex';
      document.getElementById('prev-question-btn').style.display = 'flex';
      document.getElementById('next-question-btn').style.display = 'flex';

      // Update navigation button states
      updateNavigationButtons();

      updateBookmarkButton();
    }

    function displayCustomQuestion(question) {
      const questionCard = document.getElementById('question-display');
      questionCard.innerHTML = `
        <div class="question-text">${question}</div>
      `;

      // Hide action buttons for custom questions
      document.getElementById('bookmark-action-btn').style.display = 'none';
      document.getElementById('share-btn').style.display = 'none';
      document.getElementById('slack-answer-btn').style.display = 'none';
      document.getElementById('prev-question-btn').style.display = 'none';
      document.getElementById('next-question-btn').style.display = 'none';
    }

    // Update navigation button states (disabled/enabled)
    function updateNavigationButtons() {
      const prevBtn = document.getElementById('prev-question-btn');
      const nextBtn = document.getElementById('next-question-btn');

      if (currentQuestionIndex <= 0) {
        prevBtn.disabled = true;
        prevBtn.style.opacity = '0.5';
        prevBtn.style.cursor = 'not-allowed';
      } else {
        prevBtn.disabled = false;
        prevBtn.style.opacity = '1';
        prevBtn.style.cursor = 'pointer';
      }

      if (currentQuestionIndex >= allQuestions.length - 1) {
        nextBtn.disabled = true;
        nextBtn.style.opacity = '0.5';
        nextBtn.style.cursor = 'not-allowed';
      } else {
        nextBtn.disabled = false;
        nextBtn.style.opacity = '1';
        nextBtn.style.cursor = 'pointer';
      }
    }

    // Navigate to previous question
    function navigateToPrevQuestion() {
      if (currentQuestionIndex > 0) {
        const prevQuestion = allQuestions[currentQuestionIndex - 1];
        selectQuestion(prevQuestion, true); // Clear search when navigating
      }
    }

    // Navigate to next question
    function navigateToNextQuestion() {
      if (currentQuestionIndex < allQuestions.length - 1) {
        const nextQuestion = allQuestions[currentQuestionIndex + 1];
        selectQuestion(nextQuestion, true); // Clear search when navigating
      }
    }

    function displayFAQAnswer(question) {
      const answerText = document.getElementById('answer-text');

      // Display answer as-is (content is pre-cleaned in JSON)
      answerText.innerHTML = window.marked.parse(question.answer);

      // Apply syntax highlighting to code blocks
      highlightCodeBlocks(answerText);

      // Enhance JSON blocks
      enhanceJSONBlocks(answerText);

      const followUpButton = document.createElement('div');
      followUpButton.innerHTML = `
        <button id="ask-ai-btn" class="ask-ai-button">
          üí¨ Ask AI
        </button>
      `;
      answerText.appendChild(followUpButton);

      document.getElementById('ask-ai-btn').addEventListener('click', () => {
        openChat(question);
      });

      const links = question.ucp_docs_links || [];
      if (links.length > 0) {
        // Show sources section
        document.getElementById('sources-divider').style.display = 'block';
        document.getElementById('sources-section-wrapper').style.display = 'block';
        displaySources(links);
      } else {
        // Hide sources section if no links
        document.getElementById('sources-divider').style.display = 'none';
        document.getElementById('sources-section-wrapper').style.display = 'none';
      }

      // Display relevant diagram if available
      displayDiagram(question);

      saveToHistory(question.question, question.answer);
      trackQuestion(question.question);
    }

    async function askAIDirect(question, context) {
      const answerText = document.getElementById('answer-text');
      const errorEl = document.getElementById('error-message');

      answerText.innerHTML = '<div class="streaming-dots"><div class="streaming-dot"></div><div class="streaming-dot"></div><div class="streaming-dot"></div></div>';
      errorEl.classList.remove('show');

      const contextText = context.map(q => {
        let text = `Q: ${q.question}\nA: ${q.answer}`;
        if (q.ucp_docs_links && q.ucp_docs_links.length > 0) {
          text += `\nDocumentation: ${q.ucp_docs_links.join(', ')}`;
        }
        return text;
      }).join('\n\n---\n\n');

      const systemPrompt = `You are an expert on the Universal Commerce Protocol (UCP).
You help developers understand UCP concepts, architecture, and implementation.

IMPORTANT: Format your responses using Markdown for better readability:
- Use **bold** for emphasis
- Use \`code\` for inline code and technical terms
- Use code blocks with \`\`\` for multi-line code examples
- Use headings (##) to organize longer responses
- Use bullet points and numbered lists when appropriate
- Use [links](url) for references

Guidelines:
- Base your answers on the provided context from UCP documentation
- Be concise but comprehensive
- Use code examples when helpful
- If you don't know something, say so clearly

CRITICAL - Documentation Links:
- NEVER create or generate documentation URLs yourself
- NEVER link to any ucp.dev pages unless the EXACT URL is provided in the context above
- If the context includes "Documentation: [URLs]", you may use ONLY those exact URLs
- Do not modify, guess, or construct URLs - use them exactly as provided or don't use them at all
- If you want to reference a concept but don't have a link in the context, just explain it without linking`;

      try {
        abortController = new AbortController();

        const userMessage = `Context:\n${contextText}\n\nQuestion: ${question}`;

        // Console log AI inputs
        console.group('ü§ñ AI Request (askAIDirect)');
        console.log('System Prompt:', systemPrompt);
        console.log('Context Text:', contextText);
        console.log('User Question:', question);
        console.log('Full User Message:', userMessage);
        console.groupEnd();

        const stream = await openaiClient.chat.completions.create({
          model: 'gpt-5.1',
          messages: [
            { role: 'system', content: systemPrompt },
            { role: 'user', content: userMessage }
          ],
          temperature: 0.7,
          stream: true,
        }, {
          signal: abortController.signal
        });

        let fullResponse = '';
        for await (const chunk of stream) {
          const content = chunk.choices[0]?.delta?.content;
          if (content) {
            fullResponse += content;
            answerText.innerHTML = window.marked.parse(fullResponse);
          }
        }

        // Apply syntax highlighting after streaming completes
        highlightCodeBlocks(answerText);

        // Console log AI output
        console.group('‚úÖ AI Response (askAIDirect)');
        console.log('Full Response:', fullResponse);
        console.groupEnd();

        // Enhance JSON blocks after streaming completes
        enhanceJSONBlocks(answerText);

        const links = extractUCPLinks(fullResponse, context);

        console.group('üîó Extracted Links');
        console.log('Links found:', links);
        console.log('Context objects:', context);
        console.groupEnd();

        if (links.length > 0) {
          // Show sources section
          document.getElementById('sources-divider').style.display = 'block';
          document.getElementById('sources-section-wrapper').style.display = 'block';
          displaySources(links);
        }

        // Set currentQuestion for AI responses (needed for Slack/share buttons)
        currentQuestion = {
          id: 'ai-' + Date.now(),
          question: question,
          answer: fullResponse
        };

        // Show action buttons for AI responses
        document.getElementById('bookmark-action-btn').style.display = 'flex';
        document.getElementById('share-btn').style.display = 'flex';
        document.getElementById('slack-answer-btn').style.display = 'flex';
        // Don't show prev/next for AI responses since they're not in the FAQ list
        document.getElementById('prev-question-btn').style.display = 'none';
        document.getElementById('next-question-btn').style.display = 'none';

        saveToHistory(question, fullResponse);
        trackQuestion(question);

        abortController = null;

      } catch (error) {
        if (error.name !== 'AbortError') {
          showError('Failed to get AI response. Please try again.');
          console.error(error);
        }
        abortController = null;
      }
    }

    function extractUCPLinks(text, context) {
      const links = new Set();
      const urlRegex = /https?:\/\/ucp\.dev\/[^\s\)]+/g;
      const matches = text.match(urlRegex) || [];
      matches.forEach(link => {
        // Validate link before adding
        if (isValidUCPLink(link)) {
          links.add(link);
        }
      });

      context.forEach(q => {
        q.ucp_docs_links?.forEach(link => {
          // Validate link before adding
          if (typeof link === 'string' && isValidUCPLink(link)) {
            links.add(link);
          }
        });
      });

      return Array.from(links);
    }

    function isValidUCPLink(link) {
      // Must be a string
      if (typeof link !== 'string') return false;

      // Must have valid path after domain
      if (link === 'https://ucp.dev/' || link === 'https://ucp.dev') return false;

      // Must not contain placeholder patterns
      if (link.includes('...') || link.includes('undefined')) return false;

      // Must not end with backtick or other invalid characters
      if (/[`'"<>]$/.test(link)) return false;

      return true;
    }

    // Display relevant diagram images based on question content
    function displayDiagram(question) {
      const questionLower = question.question.toLowerCase();
      const answerLower = question.answer.toLowerCase();
      let imagePath = null;
      let altText = '';

      // Map keywords to images
      if (questionLower.includes('checkout') || answerLower.includes('checkout flow')) {
        imagePath = 'ucp-checkout-flow.png';
        altText = 'UCP Checkout Flow Diagram';
      } else if (questionLower.includes('payment') && questionLower.includes('flow')) {
        imagePath = 'ucp-payment-flow.png';
        altText = 'UCP Payment Flow Diagram';
      } else if (questionLower.includes('discovery') || questionLower.includes('negotiation')) {
        imagePath = 'ucp-discovery-negotiation.png';
        altText = 'UCP Discovery and Negotiation Diagram';
      } else if (questionLower.includes('ap2') || answerLower.includes('account payable')) {
        imagePath = 'ucp-ap2-checkout-flow.png';
        altText = 'UCP AP2 Checkout Flow Diagram';
      } else if (questionLower.includes('architecture') || questionLower.includes('overview')) {
        imagePath = 'ucp-diagram.jpg';
        altText = 'UCP Architecture Overview';
      }

      if (imagePath) {
        const answerText = document.getElementById('answer-text');
        const imageContainer = document.createElement('div');
        imageContainer.style.margin = '1.5rem 0';
        imageContainer.style.textAlign = 'center';
        imageContainer.innerHTML = `
          <img src="${imagePath}" alt="${altText}" style="max-width: 100%; height: auto; border-radius: 8px; border: 1px solid var(--border);">
          <p style="font-size: 1rem; color: var(--text-secondary); margin-top: 0.5rem;">${altText}</p>
        `;
        answerText.appendChild(imageContainer);
      }
    }

    // Apply syntax highlighting to code blocks
    function highlightCodeBlocks(container) {
      const codeBlocks = container.querySelectorAll('pre code');
      codeBlocks.forEach(block => {
        // Only highlight if not already highlighted
        if (!block.classList.contains('hljs')) {
          hljs.highlightElement(block);
        }
      });
    }

    // Enhance JSON code blocks with interactive viewer
    function enhanceJSONBlocks(container) {
      const codeBlocks = container.querySelectorAll('pre code.language-json, pre code.language-jsonc');

      codeBlocks.forEach((codeBlock, index) => {
        try {
          const jsonText = codeBlock.textContent;
          const jsonData = JSON.parse(jsonText);

          // Create container for JSON editor
          const editorContainer = document.createElement('div');
          editorContainer.className = 'json-viewer-container';
          editorContainer.id = `json-editor-${Date.now()}-${index}`;

          // Replace code block with editor
          const preElement = codeBlock.parentElement;
          preElement.parentElement.replaceChild(editorContainer, preElement);

          // Initialize JSON editor (read-only view mode)
          const options = {
            mode: 'view',
            modes: ['view'],
            search: true,
            navigationBar: false,
            statusBar: true,
            mainMenuBar: false,
            onError: function (err) {
              console.error('JSON Editor error:', err);
            }
          };

          const editor = new JSONEditor(editorContainer, options);
          editor.set(jsonData);
          editor.expandAll();
        } catch (e) {
          // If JSON is invalid, leave the code block as is
          console.log('Non-JSON or invalid JSON, keeping as code block');
        }
      });
    }

    // Spec Viewer Functions
    async function loadAndDisplaySpec(specPath) {
      const modal = document.getElementById('spec-modal');
      const titleEl = document.getElementById('spec-modal-title');
      const contentEl = document.getElementById('spec-viewer-content');

      // Extract friendly name from path
      const fileName = specPath.split('/').pop();
      const displayName = fileName.replace('.json', '').replace(/_/g, ' ');
      titleEl.textContent = `üìã ${displayName}`;

      // Show modal with loading state
      contentEl.innerHTML = '<div style="padding: 2rem; text-align: center;"><div class="loading-spinner"></div><p>Loading specification...</p></div>';
      modal.classList.add('active');

      try {
        // Load from local symlink
        const response = await fetch(specPath);

        if (!response.ok) {
          throw new Error(`Failed to load spec: ${response.statusText}`);
        }

        const specJson = await response.json();

        // Create container for JSON editor
        const editorContainer = document.createElement('div');
        editorContainer.className = 'json-viewer-container';
        editorContainer.id = 'spec-json-viewer';
        contentEl.innerHTML = '';
        contentEl.appendChild(editorContainer);

        // Initialize JSON editor
        const options = {
          mode: 'view',
          modes: ['view', 'code'],
          search: true,
          navigationBar: true,
          statusBar: true,
          mainMenuBar: false,
          onError: function (err) {
            console.error('JSON Editor error:', err);
          }
        };

        const editor = new JSONEditor(editorContainer, options);
        editor.set(specJson);

        // Add GitHub button
        const githubBtn = document.createElement('a');
        githubBtn.href = `https://github.com/Universal-Commerce-Protocol/ucp/blob/main/${specPath}`;
        githubBtn.target = '_blank';
        githubBtn.rel = 'noopener noreferrer';
        githubBtn.textContent = 'üìÅ GitHub';
        githubBtn.className = 'btn-primary';
        githubBtn.style.cssText = 'text-decoration: none; padding: 0.5rem 1rem; background: var(--accent); color: white; border-radius: 6px; font-size: 0.9rem; position: absolute; top: 1rem; right: 1rem; z-index: 10;';
        contentEl.style.position = 'relative';
        contentEl.appendChild(githubBtn);

      } catch (error) {
        console.error('Error loading spec:', error);
        contentEl.innerHTML = `
          <div style="padding: 2rem; text-align: center; color: var(--error);">
            <p>‚ùå Failed to load specification</p>
            <p style="font-size: 0.9rem; opacity: 0.8;">${error.message}</p>
            <p style="font-size: 0.9rem; margin-top: 1rem;">
              <a href="https://github.com/Universal-Commerce-Protocol/ucp/blob/main/${specPath}"
                 target="_blank"
                 rel="noopener noreferrer"
                 style="color: var(--accent); text-decoration: none; font-weight: 500;">üìÅ View on GitHub</a>
            </p>
          </div>
        `;
      }
    }

    // Intercept clicks on spec links
    function setupSpecLinkHandlers() {
      document.addEventListener('click', (e) => {
        const target = e.target.closest('a');
        if (!target) return;

        const href = target.getAttribute('href');
        if (!href) return;

        // Check if this is a spec link
        if (href.startsWith('spec:')) {
          e.preventDefault();
          const specPath = href.replace('spec:', '');
          loadAndDisplaySpec(specPath);
        }
      });
    }

    function displaySources(links) {
      const sourcesEl = document.getElementById('sources');
      const linksEl = document.getElementById('source-links');
      linksEl.innerHTML = '';

      // Filter out any undefined/null links
      const validLinks = links.filter(link => link && typeof link === 'string');

      if (validLinks.length === 0) {
        return;
      }

      // Fix known broken URL patterns
      const fixedLinks = validLinks.map(link => {
        // Fix incorrect documentation paths based on mkdocs.yml structure
        return link
          // Fix overview path
          .replace('https://ucp.dev/documentation/overview/', 'https://ucp.dev/specification/overview/')
          // Fix architecture/concepts paths - redirect to core-concepts
          .replace(/https:\/\/ucp\.dev\/documentation\/(architecture|concepts|discovery|flows|implementation)\/[^\/]*\/?/, 'https://ucp.dev/documentation/core-concepts/')
          // Ensure trailing slash for consistency
          .replace(/([^\/])$/, '$1/');
      });

      fixedLinks.forEach(link => {
        const a = document.createElement('a');
        a.href = link;
        a.className = 'source-link';
        a.target = '_blank';
        a.rel = 'noopener noreferrer';

        // Extract readable link text from URL
        const linkText = link
          .replace('https://ucp.dev/', '')
          .replace(/\/$/, '') // Remove trailing slash
          .split('/')
          .map(part => part.split('-').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' '))
          .join(' > ');

        a.textContent = linkText || link;
        linksEl.appendChild(a);
      });
    }

    // Chat functions
    function openChat(question) {
      const chatModal = document.getElementById('chat-modal');
      const chatMessages = document.getElementById('chat-messages');
      const chatInput = document.getElementById('chat-input');

      chatHistory = [];
      currentChatContext = question;

      // Reset auto-scroll state
      autoScrollEnabled = true;
      isGenerating = false;
      lastScrollTop = 0;

      chatMessages.innerHTML = '';

      addMessageToChat('user', `Tell me more about: ${question.question}`);

      chatModal.classList.add('active');

      askAIChat(`Tell me more about: ${question.question}`, [question]);

      chatInput.focus();
    }

    function closeChat() {
      const chatModal = document.getElementById('chat-modal');
      chatModal.classList.remove('active');
      chatHistory = [];
      currentChatContext = null;

      // Reset auto-scroll state
      autoScrollEnabled = true;
      isGenerating = false;
      lastScrollTop = 0;

      if (abortController) {
        abortController.abort();
        abortController = null;
      }
    }

    function addMessageToChat(role, content, streaming = false) {
      const chatMessages = document.getElementById('chat-messages');

      const emptyState = chatMessages.querySelector('.chat-empty');
      if (emptyState) {
        emptyState.remove();
      }

      const messageDiv = document.createElement('div');
      messageDiv.className = `chat-message ${role}`;

      const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

      if (streaming) {
        messageDiv.innerHTML = `
          <div class="chat-bubble">
            <div class="streaming-dots">
              <div class="streaming-dot"></div>
              <div class="streaming-dot"></div>
              <div class="streaming-dot"></div>
            </div>
          </div>
          <div class="chat-timestamp">${timestamp}</div>
        `;
        messageDiv.id = 'streaming-message';
      } else {
        messageDiv.innerHTML = `
          <div class="chat-bubble">
            ${window.marked.parse(content)}
          </div>
          <div class="chat-timestamp">${timestamp}</div>
        `;
      }

      chatMessages.appendChild(messageDiv);

      // Only auto-scroll if enabled - use requestAnimationFrame to ensure DOM is updated
      if (autoScrollEnabled) {
        requestAnimationFrame(() => {
          chatMessages.scrollTop = chatMessages.scrollHeight;
        });
      }

      return messageDiv;
    }

    async function askAIChat(userMessage, context) {
      abortController = new AbortController();

      chatHistory.push({ role: 'user', content: userMessage });

      const streamingMsg = addMessageToChat('assistant', '', true);

      // Enable auto-scroll for streaming
      isGenerating = true;
      autoScrollEnabled = true;

      let contextText = '';
      if (context && context.length > 0) {
        contextText = context.map(q => {
          let text = `Q: ${q.question}\nA: ${q.answer}`;
          if (q.ucp_docs_links && q.ucp_docs_links.length > 0) {
            text += `\nDocumentation: ${q.ucp_docs_links.join(', ')}`;
          }
          return text;
        }).join('\n\n---\n\n');
      }

      const systemPrompt = `You are an expert on the Universal Commerce Protocol (UCP).
You help developers understand UCP concepts, architecture, and implementation.

IMPORTANT: Always format your responses using Markdown:
- Use **bold** for key terms and emphasis
- Use \`code\` for inline code, technical terms, and property names
- Use code blocks with \`\`\`language\` for multi-line code examples
- Use ## for section headings in longer responses
- Use bullet points (-) and numbered lists (1.) for better organization
- Use [links](url) when referencing documentation

Guidelines:
- Base your answers on the provided context from UCP documentation
- Be concise but comprehensive
- Use code examples when helpful
- Break down complex topics into digestible sections
- If you don't know something, say so clearly

CRITICAL - Documentation Links:
- NEVER create or generate documentation URLs yourself
- NEVER link to any ucp.dev pages unless the EXACT URL is provided in the context above
- If the context includes "Documentation: [URLs]", you may use ONLY those exact URLs
- Do not modify, guess, or construct URLs - use them exactly as provided or don't use them at all
- If you want to reference a concept but don't have a link in the context, just explain it without linking`;

      try {
        const messages = [
          { role: 'system', content: systemPrompt }
        ];

        if (contextText) {
          messages.push({ role: 'user', content: `Context:\n${contextText}` });
        }

        messages.push(...chatHistory);

        // Console log AI inputs
        console.group('üí¨ AI Chat Request (askAIChat)');
        console.log('System Prompt:', systemPrompt);
        console.log('Context Text:', contextText);
        console.log('Chat History:', chatHistory);
        console.log('All Messages:', messages);
        console.groupEnd();

        const stream = await openaiClient.chat.completions.create({
          model: 'gpt-5.1',
          messages: messages,
          temperature: 0.7,
          stream: true,
        }, {
          signal: abortController.signal
        });

        let fullResponse = '';
        const chatMessages = document.getElementById('chat-messages');
        let scrollPending = false;

        for await (const chunk of stream) {
          const content = chunk.choices[0]?.delta?.content;
          if (content) {
            fullResponse += content;
            const bubble = streamingMsg.querySelector('.chat-bubble');
            bubble.innerHTML = window.marked.parse(fullResponse);

            // Only auto-scroll if enabled - throttle using requestAnimationFrame
            if (autoScrollEnabled && !scrollPending) {
              scrollPending = true;
              requestAnimationFrame(() => {
                chatMessages.scrollTop = chatMessages.scrollHeight;
                scrollPending = false;
              });
            }
          }
        }

        // Apply syntax highlighting and enhance JSON blocks after streaming completes
        const bubble = streamingMsg.querySelector('.chat-bubble');
        highlightCodeBlocks(bubble);
        enhanceJSONBlocks(bubble);

        // Console log AI output
        console.group('‚úÖ AI Chat Response (askAIChat)');
        console.log('Full Response:', fullResponse);
        console.groupEnd();

        chatHistory.push({ role: 'assistant', content: fullResponse });

        streamingMsg.removeAttribute('id');

        // Save chat history to database
        await saveChatConversation();

        abortController = null;
        isGenerating = false;

      } catch (error) {
        isGenerating = false;

        if (streamingMsg && streamingMsg.parentNode) {
          streamingMsg.remove();
        }

        if (error.name !== 'AbortError') {
          addMessageToChat('assistant', '‚ùå Sorry, I encountered an error. Please try again.');
          console.error(error);
        }

        abortController = null;
      }
    }

    async function sendChatMessage() {
      const chatInput = document.getElementById('chat-input');
      const message = chatInput.value.trim();

      if (!message) return;

      chatInput.value = '';
      chatInput.style.height = 'auto';

      addMessageToChat('user', message);

      await askAIChat(message, currentChatContext ? [currentChatContext] : []);
    }

    // Modal functions
    window.closeModal = function(modalId) {
      document.getElementById(modalId).classList.remove('active');
    };

    // Close modal on backdrop click
    document.querySelectorAll('.modal').forEach(modal => {
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.classList.remove('active');
        }
      });
    });

    // Bookmarks
    async function toggleBookmark() {
      if (!currentQuestion || !currentUser) return;

      try {
        const existingBookmarks = await bookmarksCollection
          .where({ userId: currentUser.id, questionId: currentQuestion.id })
          .find();

        if (existingBookmarks.length > 0) {
          // Remove bookmark
          await bookmarksCollection.delete(existingBookmarks[0].id);
          showNotification('Bookmark removed');
        } else {
          // Add bookmark
          await bookmarksCollection.create({
            userId: currentUser.id,
            questionId: currentQuestion.id,
            questionText: currentQuestion.question,
            questionAnswer: currentQuestion.answer,
            timestamp: new Date().toISOString()
          });
          showNotification('Topic saved');
        }

        await loadBookmarks();
        await updateBookmarkButton();
      } catch (error) {
        console.error('Error toggling bookmark:', error);
        showError('Failed to update bookmark');
      }
    }

    async function loadBookmarks() {
      if (!currentUser) return;

      try {
        const bookmarks = await bookmarksCollection
          .where({ userId: currentUser.id })
          .find();

        const bookmarksEl = document.getElementById('bookmarks-list');

        if (bookmarks.length === 0) {
          bookmarksEl.innerHTML = '<div class="list-empty">No saved topics yet</div>';
          return;
        }

        // Sort by timestamp (most recent first)
        bookmarks.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

        bookmarksEl.innerHTML = '';
        bookmarks.forEach(bookmark => {
          const div = document.createElement('div');
          div.className = 'list-item';
          div.textContent = bookmark.questionText;
          div.onclick = () => {
            closeModal('bookmarks-modal');
            // Find the full question object from knowledgeBase
            const question = findQuestionById(bookmark.questionId);
            if (question) {
              selectQuestion(question);
            }
          };
          bookmarksEl.appendChild(div);
        });
      } catch (error) {
        console.error('Error loading bookmarks:', error);
      }
    }

    async function updateBookmarkButton() {
      if (!currentQuestion || !currentUser) return;

      try {
        const existingBookmarks = await bookmarksCollection
          .where({ userId: currentUser.id, questionId: currentQuestion.id })
          .find();

        const isBookmarked = existingBookmarks.length > 0;
        const btn = document.getElementById('bookmark-action-btn');

        if (isBookmarked) {
          btn.classList.add('bookmarked');
          btn.title = 'Remove Bookmark';
          // Change to filled bookmark icon
          btn.innerHTML = `
            <svg viewBox="0 0 24 24" fill="currentColor">
              <path d="M17 3H7c-1.1 0-2 .9-2 2v16l7-3 7 3V5c0-1.1-.9-2-2-2z"/>
            </svg>
          `;
        } else {
          btn.classList.remove('bookmarked');
          btn.title = 'Bookmark';
          // Change to outline bookmark icon
          btn.innerHTML = `
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"/>
            </svg>
          `;
        }
      } catch (error) {
        console.error('Error updating bookmark button:', error);
      }
    }

    document.getElementById('bookmark-action-btn').addEventListener('click', toggleBookmark);

    // Share link
    function shareLink() {
      if (!currentQuestion) return;

      const url = `${window.location.origin}${window.location.pathname}#q=${currentQuestion.id}`;
      navigator.clipboard.writeText(url);
      showNotification('Link copied to clipboard!');
    }

    document.getElementById('share-btn').addEventListener('click', shareLink);

    // Send to Slack
    async function sendAnswerToSlack() {
      if (!currentQuestion || !currentUser) return;

      try {
        const answerText = document.getElementById('answer-text').textContent || currentQuestion.answer;

        // Format the message for Slack
        const slackMessage = `*UCP Explorer Q&A*\n\n*Q:* ${currentQuestion.question}\n\n*A:* ${answerText.substring(0, 2000)}${answerText.length > 2000 ? '...' : ''}\n\n_Shared from UCP Explorer_`;

        // Send to user's Slack DM
        await quick.slack.sendMessage(currentUser.slackId, slackMessage);

        showNotification('‚úÖ Sent to your Slack!');
      } catch (error) {
        console.error('Error sending to Slack:', error);
        showError('Failed to send to Slack. Please try again.');
      }
    }

    document.getElementById('slack-answer-btn').addEventListener('click', sendAnswerToSlack);

    // Send chat conversation to Slack
    async function sendChatToSlack() {
      if (!currentUser || chatHistory.length === 0) return;

      try {
        // Format the chat conversation for Slack
        let slackMessage = '*UCP Explorer Chat Conversation*\n\n';

        // Add chat messages
        chatHistory.forEach((msg, index) => {
          if (msg.role === 'user') {
            slackMessage += `*You:* ${msg.content}\n\n`;
          } else if (msg.role === 'assistant') {
            // Limit assistant response length
            const content = msg.content.substring(0, 1500);
            slackMessage += `*AI:* ${content}${msg.content.length > 1500 ? '...' : ''}\n\n`;
          }
        });

        slackMessage += '_Shared from UCP Explorer Chat_';

        // Send to user's Slack DM
        await quick.slack.sendMessage(currentUser.slackId, slackMessage);

        showNotification('‚úÖ Chat sent to your Slack!');
      } catch (error) {
        console.error('Error sending chat to Slack:', error);
        showError('Failed to send chat to Slack. Please try again.');
      }
    }

    document.getElementById('chat-slack-btn').addEventListener('click', sendChatToSlack);

    // Navigation buttons
    document.getElementById('prev-question-btn').addEventListener('click', navigateToPrevQuestion);
    document.getElementById('next-question-btn').addEventListener('click', navigateToNextQuestion);

    // History
    async function saveToHistory(question, answer) {
      if (!currentUser) return;

      try {
        // Check if this question already exists in history
        const existing = await historyCollection
          .where({ userId: currentUser.id, questionText: question })
          .find();

        if (existing.length > 0) {
          // Update timestamp to move it to top
          await historyCollection.update(existing[0].id, {
            timestamp: new Date().toISOString(),
            answerPreview: answer.substring(0, 200)
          });
        } else {
          // Create new history entry
          await historyCollection.create({
            userId: currentUser.id,
            questionText: question,
            answerPreview: answer.substring(0, 200),
            timestamp: new Date().toISOString()
          });
        }

        await loadHistory();
      } catch (error) {
        console.error('Error saving to history:', error);
      }
    }

    async function loadHistory() {
      if (!currentUser) return;

      try {
        const history = await historyCollection
          .where({ userId: currentUser.id })
          .limit(20)
          .find();

        // Sort by timestamp (most recent first)
        history.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

        const historyEl = document.getElementById('history-list');

        if (history.length === 0) {
          historyEl.innerHTML = '<div class="list-empty">No history yet</div>';
          return;
        }

        historyEl.innerHTML = '';
        history.slice(0, 10).forEach(item => {
          const div = document.createElement('div');
          div.className = 'list-item';
          div.textContent = item.questionText.substring(0, 100) + (item.questionText.length > 100 ? '...' : '');
          div.onclick = () => {
            closeModal('history-modal');
            searchInput.value = item.questionText;
            handleSearch();
          };
          historyEl.appendChild(div);
        });
      } catch (error) {
        console.error('Error loading history:', error);
      }
    }

    async function clearHistory() {
      if (!currentUser) return;

      try {
        // Get all history items for this user
        const history = await historyCollection
          .where({ userId: currentUser.id })
          .find();

        // Delete each item
        for (const item of history) {
          await historyCollection.delete(item.id);
        }

        // Reload the display
        await loadHistory();

        showNotification('History cleared');
      } catch (error) {
        console.error('Error clearing history:', error);
        showNotification('Failed to clear history');
      }
    }

    // Chat history storage
    async function saveChatConversation() {
      if (!currentUser || !currentChatContext || chatHistory.length === 0) return;

      try {
        // Save or update the chat conversation
        await chatHistoryCollection.create({
          userId: currentUser.id,
          questionId: currentChatContext.id,
          questionText: currentChatContext.question,
          messages: chatHistory,
          timestamp: new Date().toISOString(),
          messageCount: chatHistory.length
        });
      } catch (error) {
        console.error('Error saving chat conversation:', error);
      }
    }

    // Specs Browser Functions
    let specsCache = null;
    let currentSpecPath = null;
    let currentSpecData = null;
    let currentSpecEditor = null;

    async function loadSpecs() {
      if (specsCache) return specsCache;

      try {
        const response = await fetch('specs-list.json');
        const specs = await response.json();
        specsCache = specs;
        return specs;
      } catch (error) {
        console.error('Error loading specs:', error);
        return [];
      }
    }

    async function loadSpecInPane(specPath) {
      const titleEl = document.getElementById('specs-current-title');
      const contentEl = document.getElementById('specs-viewer-content-pane');
      const rawJsonEl = document.getElementById('raw-json-view');
      const tabsEl = document.getElementById('specs-view-tabs');

      // Extract friendly name from path
      const fileName = specPath.split('/').pop();
      const displayName = fileName.replace('.json', '').replace(/_/g, ' ');
      titleEl.textContent = displayName;

      // Update active state in sidebar
      document.querySelectorAll('.spec-file').forEach(el => el.classList.remove('active'));
      const clickedFile = Array.from(document.querySelectorAll('.spec-file')).find(el =>
        el.getAttribute('data-path') === specPath
      );
      if (clickedFile) {
        clickedFile.classList.add('active');
      }

      // Show loading state
      contentEl.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%;"><div class="loading-spinner"></div></div>';
      rawJsonEl.style.display = 'none';

      try {
        // Always fetch from GitHub
        const githubUrl = `https://raw.githubusercontent.com/Universal-Commerce-Protocol/ucp/main/${specPath}`;
        const response = await fetch(githubUrl);

        if (!response.ok) {
          throw new Error(`Failed to load spec from GitHub: ${response.statusText}`);
        }

        const specJson = await response.json();
        currentSpecData = specJson;
        currentSpecPath = specPath;

        // Show tabs
        tabsEl.style.display = 'flex';

        // Render tree view by default
        renderTreeView();

        // Render raw JSON view (but keep it hidden)
        renderRawJsonView();

      } catch (error) {
        console.error('Error loading spec:', error);
        tabsEl.style.display = 'none';
        contentEl.innerHTML = `
          <div style="display: flex; align-items: center; justify-content: center; height: 100%; flex-direction: column; padding: 2rem; color: var(--error);">
            <p style="font-size: 1.2rem; margin-bottom: 0.5rem;">‚ùå Failed to load specification</p>
            <p style="font-size: 0.9rem; opacity: 0.8;">${error.message}</p>
            <p style="font-size: 0.9rem; margin-top: 1rem;">
              <a href="https://github.com/Universal-Commerce-Protocol/ucp/blob/main/${specPath}"
                 target="_blank"
                 rel="noopener noreferrer"
                 style="color: var(--accent); text-decoration: none; font-weight: 500;">üìÅ View on GitHub</a>
            </p>
          </div>
        `;
      }
    }

    function renderTreeView() {
      const contentEl = document.getElementById('specs-viewer-content-pane');

      // Create container for JSON editor
      const editorContainer = document.createElement('div');
      editorContainer.className = 'json-viewer-container';
      editorContainer.id = 'spec-json-viewer';
      contentEl.innerHTML = '';
      contentEl.appendChild(editorContainer);

      // Initialize JSON editor
      const options = {
        mode: 'view',
        modes: ['view', 'code'],
        search: true,
        navigationBar: true,
        statusBar: true,
        mainMenuBar: false,
        onError: function (err) {
          console.error('JSON Editor error:', err);
        }
      };

      currentSpecEditor = new JSONEditor(editorContainer, options);
      currentSpecEditor.set(currentSpecData);
    }

    function renderRawJsonView() {
      const rawJsonEl = document.getElementById('raw-json-view');
      const formattedJson = JSON.stringify(currentSpecData, null, 2);

      rawJsonEl.innerHTML = `<pre><code class="language-json">${escapeHtml(formattedJson)}</code></pre>`;

      // Apply syntax highlighting
      const codeBlock = rawJsonEl.querySelector('code');
      if (codeBlock && window.hljs) {
        hljs.highlightElement(codeBlock);
      }
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function switchSpecView(view) {
      const contentEl = document.getElementById('specs-viewer-content-pane');
      const rawJsonEl = document.getElementById('raw-json-view');
      const tabs = document.querySelectorAll('.spec-view-tab');

      // Update active tab
      tabs.forEach(tab => {
        if (tab.getAttribute('data-view') === view) {
          tab.classList.add('active');
        } else {
          tab.classList.remove('active');
        }
      });

      // Show/hide appropriate view
      if (view === 'tree') {
        contentEl.style.display = 'block';
        rawJsonEl.style.display = 'none';
      } else if (view === 'raw') {
        contentEl.style.display = 'none';
        rawJsonEl.style.display = 'block';
      }
    }

    function buildSpecsTree(specs) {
      const tree = {};

      specs.forEach(specPath => {
        // Remove 'spec/' prefix
        const path = specPath.replace(/^spec\//, '');
        const parts = path.split('/');
        const fileName = parts.pop();

        let current = tree;
        let currentPath = '';

        parts.forEach((part, index) => {
          currentPath = currentPath ? `${currentPath}/${part}` : part;

          if (!current[part]) {
            current[part] = {
              _type: 'folder',
              _path: currentPath,
              _files: [],
              _subfolders: {}
            };
          }
          current = current[part]._subfolders;
        });

        // Add file to the deepest folder
        const parentFolder = parts.reduce((acc, part) => acc[part]._subfolders, tree);
        const lastPart = parts[parts.length - 1];
        if (lastPart && tree[parts[0]]) {
          let target = tree[parts[0]];
          for (let i = 1; i < parts.length; i++) {
            target = target._subfolders[parts[i]];
          }
          target._files.push({
            name: fileName,
            path: specPath
          });
        } else if (parts.length === 0) {
          // Root level file
          if (!tree._rootFiles) tree._rootFiles = [];
          tree._rootFiles.push({
            name: fileName,
            path: specPath
          });
        }
      });

      return tree;
    }

    function renderFolder(name, folder, level = 0) {
      const folderDiv = document.createElement('div');
      folderDiv.className = 'spec-folder';

      const header = document.createElement('div');
      header.className = 'spec-folder-header';

      const fileCount = folder._files.length + Object.keys(folder._subfolders).reduce((sum, key) => {
        return sum + countFilesInFolder(folder._subfolders[key]);
      }, 0);

      header.innerHTML = `
        <span class="spec-folder-icon">‚ñ∂</span>
        <span class="spec-folder-name">${name}</span>
        <span class="spec-folder-count">${fileCount} specs</span>
      `;

      header.addEventListener('click', () => {
        folderDiv.classList.toggle('expanded');
      });

      const content = document.createElement('div');
      content.className = 'spec-folder-content';

      // Render subfolders
      Object.keys(folder._subfolders).sort().forEach(subName => {
        content.appendChild(renderFolder(subName, folder._subfolders[subName], level + 1));
      });

      // Render files
      folder._files.sort((a, b) => a.name.localeCompare(b.name)).forEach(file => {
        const fileDiv = document.createElement('div');
        fileDiv.className = 'spec-file';
        fileDiv.setAttribute('data-path', file.path);
        fileDiv.innerHTML = `
          <span class="spec-file-icon">üìÑ</span>
          <span>${file.name}</span>
        `;
        fileDiv.addEventListener('click', () => {
          loadSpecInPane(file.path);
        });
        content.appendChild(fileDiv);
      });

      folderDiv.appendChild(header);
      folderDiv.appendChild(content);

      return folderDiv;
    }

    function countFilesInFolder(folder) {
      let count = folder._files.length;
      Object.keys(folder._subfolders).forEach(key => {
        count += countFilesInFolder(folder._subfolders[key]);
      });
      return count;
    }

    async function displaySpecsTree(filterText = '') {
      const specsTree = document.getElementById('specs-sidebar-tree');
      specsTree.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-secondary);">Loading specs...</div>';

      const specs = await loadSpecs();

      let filteredSpecs = specs;
      if (filterText) {
        const lower = filterText.toLowerCase();
        filteredSpecs = specs.filter(spec =>
          spec.toLowerCase().includes(lower)
        );
      }

      if (filteredSpecs.length === 0) {
        specsTree.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-secondary);">No specs found</div>';
        return filteredSpecs;
      }

      const tree = buildSpecsTree(filteredSpecs);
      specsTree.innerHTML = '';

      // Render root level files
      if (tree._rootFiles && tree._rootFiles.length > 0) {
        tree._rootFiles.forEach(file => {
          const fileDiv = document.createElement('div');
          fileDiv.className = 'spec-file';
          fileDiv.setAttribute('data-path', file.path);
          fileDiv.innerHTML = `
            <span class="spec-file-icon">üìÑ</span>
            <span>${file.name}</span>
          `;
          fileDiv.addEventListener('click', () => {
            loadSpecInPane(file.path);
          });
          specsTree.appendChild(fileDiv);
        });
      }

      // Render folders
      Object.keys(tree).filter(k => !k.startsWith('_')).sort().forEach(folderName => {
        specsTree.appendChild(renderFolder(folderName, tree[folderName]));
      });

      return filteredSpecs;
    }

    document.getElementById('specs-btn').addEventListener('click', async () => {
      document.getElementById('specs-page').classList.add('active');
      const specs = await displaySpecsTree();
      // Load first spec by default
      if (specs && specs.length > 0) {
        await loadSpecInPane(specs[0]);
      }
    });

    document.getElementById('specs-close-btn').addEventListener('click', () => {
      document.getElementById('specs-page').classList.remove('active');
    });

    document.getElementById('specs-search-input').addEventListener('input', (e) => {
      displaySpecsTree(e.target.value);
    });

    // Spec view tabs
    document.querySelectorAll('.spec-view-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        const view = tab.getAttribute('data-view');
        switchSpecView(view);
      });
    });

    // Graph functionality
    function sanitizeMermaidText(text) {
      // Remove or escape special characters that break Mermaid syntax
      return text
        .replace(/[()[\]{}]/g, '') // Remove all brackets and parens
        .replace(/["'`]/g, '') // Remove quotes
        .replace(/\n/g, ' ')  // Replace newlines with spaces
        .replace(/\s+/g, ' ') // Normalize whitespace
        .trim();
    }

    // Track current drill-down state
    let currentGraphCategory = null;

    function buildMermaidFlowchart(categoryId = null) {
      if (!knowledgeBase || !knowledgeBase.categories) {
        return 'flowchart TD\n  START[UCP Explorer]\n';
      }

      let mermaidCode = 'flowchart TD\n';
      let nodeIndex = 0;

      if (categoryId === null) {
        // Top level - show categories as a flowchart showing conceptual flow
        mermaidCode += '  START([Start Here])\n';

        // Group categories by their conceptual flow
        const categoryGroups = {
          fundamentals: ['foundations_why'],
          concepts: ['core_concepts'],
          implementation: ['checkout_core', 'transport_protocols'],
          security: ['security_privacy'],
          operations: ['order_management', 'extensions_customization'],
          advanced: ['implementation_guide', 'advanced_topics', 'real_world_use_cases'],
          reference: ['best_practices', 'roadmap_community', 'quick_reference']
        };

        // Create nodes for each category
        const categoryNodes = {};
        knowledgeBase.categories.forEach(category => {
          const nodeId = `cat_${category.id}`;
          const title = sanitizeMermaidText(category.title);
          categoryNodes[category.id] = nodeId;

          // Use different shapes for visual interest
          if (category.id.includes('foundations') || category.id.includes('core')) {
            mermaidCode += `  ${nodeId}[${title}]\n`;
          } else if (category.id.includes('quick_reference')) {
            mermaidCode += `  ${nodeId}[[${title}]]\n`;
          } else {
            mermaidCode += `  ${nodeId}(${title})\n`;
          }
        });

        // Create flow connections showing learning path
        mermaidCode += '  START --> cat_foundations_why\n';
        mermaidCode += '  cat_foundations_why --> cat_core_concepts\n';
        mermaidCode += '  cat_core_concepts --> cat_checkout_core\n';
        mermaidCode += '  cat_core_concepts --> cat_transport_protocols\n';
        mermaidCode += '  cat_checkout_core --> cat_security_privacy\n';
        mermaidCode += '  cat_transport_protocols --> cat_security_privacy\n';
        mermaidCode += '  cat_security_privacy --> cat_order_management\n';
        mermaidCode += '  cat_order_management --> cat_extensions_customization\n';
        mermaidCode += '  cat_extensions_customization --> cat_implementation_guide\n';
        mermaidCode += '  cat_implementation_guide --> cat_advanced_topics\n';
        mermaidCode += '  cat_advanced_topics --> cat_real_world_use_cases\n';
        mermaidCode += '  cat_real_world_use_cases --> cat_best_practices\n';
        mermaidCode += '  cat_best_practices --> cat_roadmap_community\n';
        mermaidCode += '  cat_quick_reference -.-> cat_foundations_why\n';
        mermaidCode += '  cat_quick_reference -.-> cat_core_concepts\n';

      } else {
        // Drilled down - show questions as a flowchart
        const category = knowledgeBase.categories.find(c => c.id === categoryId);
        if (category) {
          const categoryTitle = sanitizeMermaidText(category.title);
          mermaidCode += `  CAT[${categoryTitle}]\n`;

          if (category.questions && category.questions.length > 0) {
            category.questions.forEach((question, idx) => {
              const nodeId = `q_${idx}`;
              let questionText = question.question.length > 50
                ? question.question.substring(0, 47) + '...'
                : question.question;
              questionText = sanitizeMermaidText(questionText);
              mermaidCode += `  ${nodeId}(${questionText})\n`;

              // Connect questions in sequence
              if (idx === 0) {
                mermaidCode += `  CAT --> ${nodeId}\n`;
              } else {
                mermaidCode += `  q_${idx-1} --> ${nodeId}\n`;
              }
            });
          }
        }
      }

      console.log('Generated Mermaid flowchart:', mermaidCode);
      return mermaidCode;
    }

    async function renderGraph() {
      const graphContainer = document.getElementById('graph-svg');
      const mermaidCode = buildMermaidFlowchart(currentGraphCategory);

      // Update back button visibility
      const backBtn = document.getElementById('graph-back-btn');
      if (currentGraphCategory === null) {
        backBtn.style.display = 'none';
      } else {
        backBtn.style.display = 'block';
      }

      try {
        // Clear previous graph
        graphContainer.innerHTML = '';

        // Generate unique ID for this render
        const graphId = 'mermaid-flowchart-' + Date.now();

        // Render with Mermaid
        const { svg } = await window.mermaid.render(graphId, mermaidCode);
        graphContainer.innerHTML = svg;

        // Build maps for click handling
        const nodeIdToCategoryMap = {};
        const nodeIdToQuestionMap = {};

        if (currentGraphCategory === null) {
          // Top level - map node IDs to category IDs
          knowledgeBase.categories.forEach(category => {
            const nodeId = `cat_${category.id}`;
            nodeIdToCategoryMap[nodeId] = category.id;
          });
        } else {
          // Drilled down - map node indices to question IDs
          const category = knowledgeBase.categories.find(c => c.id === currentGraphCategory);
          if (category && category.questions) {
            category.questions.forEach((question, idx) => {
              nodeIdToQuestionMap[`q_${idx}`] = question.id;
            });
          }
        }

        // Add click handlers to nodes
        setTimeout(() => {
          // Find all flowchart nodes
          const nodes = graphContainer.querySelectorAll('[id^="flowchart-"]');
          nodes.forEach(node => {
            const nodeId = node.id;

            // Extract the actual node identifier from the Mermaid-generated ID
            // Mermaid generates IDs like "flowchart-cat_foundations_why-123"
            let actualNodeId = null;

            // Try to match category nodes
            for (const [catNodeId, categoryId] of Object.entries(nodeIdToCategoryMap)) {
              if (nodeId.includes(catNodeId)) {
                actualNodeId = categoryId;
                // This is a category node - drill down on click
                node.style.cursor = 'pointer';
                node.addEventListener('click', async (e) => {
                  e.stopPropagation();
                  currentGraphCategory = actualNodeId;
                  await renderGraph();
                });
                break;
              }
            }

            // Try to match question nodes
            if (!actualNodeId) {
              for (const [qNodeId, questionId] of Object.entries(nodeIdToQuestionMap)) {
                if (nodeId.includes(qNodeId)) {
                  actualNodeId = questionId;
                  // This is a question node - navigate to question
                  node.style.cursor = 'pointer';
                  node.addEventListener('click', (e) => {
                    e.stopPropagation();
                    // Close graph page
                    document.getElementById('graph-page').classList.remove('active');
                    // Reset drill-down state
                    currentGraphCategory = null;
                    // Navigate to question
                    navigateToQuestion(actualNodeId);
                  });
                  break;
                }
              }
            }
          });
        }, 100);
      } catch (error) {
        console.error('Error rendering Mermaid flowchart:', error);
        graphContainer.innerHTML = `<div style="color: var(--text-secondary); padding: 2rem;">
          <p>Error rendering knowledge graph.</p>
          <p style="font-size: 0.9rem; margin-top: 0.5rem;">${error.message}</p>
        </div>`;
      }
    }

    document.getElementById('graph-btn').addEventListener('click', async () => {
      // Reset to top level when opening graph
      currentGraphCategory = null;
      document.getElementById('graph-page').classList.add('active');
      await renderGraph();
    });

    document.getElementById('graph-back-btn').addEventListener('click', async () => {
      // Go back to top level
      currentGraphCategory = null;
      await renderGraph();
    });

    document.getElementById('graph-close-btn').addEventListener('click', () => {
      document.getElementById('graph-page').classList.remove('active');
      // Reset drill-down state when closing
      currentGraphCategory = null;
    });

    document.getElementById('history-btn').addEventListener('click', () => {
      document.getElementById('history-modal').classList.add('active');
    });

    document.getElementById('clear-history-btn').addEventListener('click', clearHistory);

    document.getElementById('bookmarks-btn').addEventListener('click', () => {
      document.getElementById('bookmarks-modal').classList.add('active');
    });

    // Dark mode
    function toggleDarkMode() {
      const isDark = document.body.classList.toggle('dark-mode');
      localStorage.setItem('ucp-ama-theme', isDark ? 'dark' : 'light');
      document.getElementById('theme-toggle').textContent = isDark ? '‚òÄÔ∏è' : 'üåô';
    }

    function loadTheme() {
      const theme = localStorage.getItem('ucp-ama-theme') || 'light';
      if (theme === 'dark') {
        document.body.classList.add('dark-mode');
        document.getElementById('theme-toggle').textContent = '‚òÄÔ∏è';
      }
    }

    document.getElementById('theme-toggle').addEventListener('click', toggleDarkMode);

    // Deep linking
    function loadFromURL() {
      const hash = window.location.hash;
      if (hash.startsWith('#q=')) {
        const questionId = hash.substring(3);
        const question = findQuestionById(questionId);
        if (question) {
          selectQuestion(question);
        }
      }
    }

    function findQuestionById(id) {
      for (const cat of knowledgeBase.categories) {
        const q = cat.questions.find(q => q.id === id);
        if (q) return q;
      }
      return null;
    }

    window.addEventListener('hashchange', loadFromURL);

    // Analytics
    async function trackQuestion(question) {
      try {
        const analytics = quick.db.collection('ama-analytics');
        await analytics.create({
          question_text: question,
          timestamp: new Date().toISOString(),
          user_id: quick.id.email || 'anonymous'
        });
      } catch (error) {
        console.error('Analytics error:', error);
      }
    }

    // Notifications
    function showNotification(message) {
      const notif = document.getElementById('notification');
      notif.textContent = message;
      notif.classList.add('show');
      setTimeout(() => notif.classList.remove('show'), 3000);
    }

    function showError(message) {
      const errorEl = document.getElementById('error-message');
      errorEl.textContent = message;
      errorEl.classList.add('show');
    }

    // Close suggestions when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.search-container')) {
        suggestionsEl.classList.remove('active');
      }
    });

    // Go back to home
    function goHome() {
      if (abortController) {
        abortController.abort();
        abortController = null;
      }

      document.getElementById('welcome').style.display = 'block';
      document.getElementById('content-card').classList.remove('active');
      document.getElementById('breadcrumb').classList.remove('active');
      document.getElementById('error-message').classList.remove('show');

      searchInput.value = '';
      window.location.hash = '';
      currentQuestion = null;
      currentCategory = null;

      // Remove active category highlight
      document.querySelectorAll('.category-item').forEach(item => {
        item.classList.remove('active');
      });
    }

    document.getElementById('app-title').addEventListener('click', goHome);

    // Clear search input when clicked
    searchInput.addEventListener('focus', () => {
      searchInput.value = '';
      suggestionsEl.classList.remove('active');
    });

    // Chat event listeners
    document.getElementById('chat-send').addEventListener('click', sendChatMessage);

    document.getElementById('chat-input').addEventListener('keypress', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendChatMessage();
      }
    });

    // Auto-resize textarea
    document.getElementById('chat-input').addEventListener('input', (e) => {
      e.target.style.height = 'auto';
      e.target.style.height = e.target.scrollHeight + 'px';
    });

    // Auto-scroll management for chat
    const chatMessages = document.getElementById('chat-messages');
    const scrollToBottomBtn = document.getElementById('scroll-to-bottom');

    function isAtBottom(threshold = 20) {
      return chatMessages.scrollHeight - chatMessages.scrollTop - chatMessages.clientHeight < threshold;
    }

    function scrollChatToBottom(smooth = false) {
      chatMessages.scrollTo({
        top: chatMessages.scrollHeight,
        behavior: smooth ? 'smooth' : 'auto'
      });
    }

    function updateScrollButton() {
      if (isAtBottom(100)) {
        scrollToBottomBtn.classList.remove('visible');
      } else {
        scrollToBottomBtn.classList.add('visible');
      }
    }

    // Detect user scroll
    chatMessages.addEventListener('scroll', () => {
      const currentScrollTop = chatMessages.scrollTop;

      if (!isGenerating) {
        updateScrollButton();
        lastScrollTop = currentScrollTop;
        return;
      }

      const scrollingUp = currentScrollTop < lastScrollTop;

      if (isAtBottom()) {
        autoScrollEnabled = true;
      } else if (scrollingUp && (lastScrollTop - currentScrollTop) > 50) {
        // User scrolled up significantly (50px threshold)
        autoScrollEnabled = false;
      }

      lastScrollTop = currentScrollTop;
      updateScrollButton();
    });

    // Scroll to bottom button click
    scrollToBottomBtn.addEventListener('click', () => {
      autoScrollEnabled = true;
      scrollChatToBottom(true);
      scrollToBottomBtn.classList.remove('visible');
    });

    document.getElementById('chat-close').addEventListener('click', closeChat);

    // Initialize
    setupSpecLinkHandlers();
    loadKnowledgeBase();
  </script>
</body>
</html>
